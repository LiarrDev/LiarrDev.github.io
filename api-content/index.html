{"posts":[{"title":"如何追踪 Android 依赖来源","content":"相信在日常开发中你已经发现，当我们添加某个库的依赖时，它会帮助我们同步它所依赖的库，比如我们常用的网络请求库 OkHttp 就依赖了 Okio，但我们依赖 OkHttp 时并不需要把 Okio 的依赖也添加进去，这是由 POM 声明的。 这种方案能够帮助我们屏蔽掉一些多余的信息，降低上手门槛，但有时候却不利于追踪。 追踪 AAR / JAR 依赖 好在 Android 官方已经帮我们准备好一个 Gradle 任务用于分析项目中的依赖关系，我们只需要一行命令就可以查询。 ➜ ./gradlew app:dependencies 控制台中会输出整个项目的依赖树： +--- androidx.appcompat:appcompat:1.7.1 | +--- androidx.activity:activity:1.8.0 -&gt; 1.10.1 | | +--- androidx.annotation:annotation:1.8.1 | | | \\--- androidx.annotation:annotation-jvm:1.8.1 | | | \\--- org.jetbrains.kotlin:kotlin-stdlib:1.7.10 -&gt; 1.8.22 | | | +--- org.jetbrains.kotlin:kotlin-stdlib-common:1.8.22 | | | \\--- org.jetbrains:annotations:13.0 -&gt; 23.0.0 | | +--- androidx.core:core-ktx:1.13.0 | | | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | | +--- androidx.core:core:1.13.0 | | | | +--- androidx.annotation:annotation:1.6.0 -&gt; 1.8.1 (*) | | | | +--- androidx.annotation:annotation-experimental:1.4.0 | | | | | \\--- org.jetbrains.kotlin:kotlin-stdlib:1.7.10 -&gt; 1.8.22 (*) | | | | +--- androidx.lifecycle:lifecycle-runtime:2.6.2 | | | | | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | | | | +--- androidx.arch.core:core-common:2.2.0 | | | | | | \\--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | | | | +--- androidx.lifecycle:lifecycle-common:2.6.2 | | | | | | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | | | | | +--- org.jetbrains.kotlin:kotlin-stdlib:1.8.10 -&gt; 1.8.22 (*) | | | | | | +--- org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4 -&gt; 1.7.3 | | | | | | | +--- org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3 | | | | | | | | \\--- org.jetbrains.kotlinx:kotlinx-coroutines-core-jvm:1.7.3 | | | | | | | | +--- org.jetbrains:annotations:23.0.0 | | | | | | | | +--- org.jetbrains.kotlinx:kotlinx-coroutines-bom:1.7.3 | | | | | | | | | +--- org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3 (c) | | | | | | | | | +--- org.jetbrains.kotlinx:kotlinx-coroutines-core-jvm:1.7.3 (c) | | | | | | | | | \\--- org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3 (c) | | | | | | | | +--- org.jetbrains.kotlin:kotlin-stdlib-common:1.8.20 -&gt; 1.8.22 | | | | | | | | \\--- org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.8.20 -&gt; 1.8.22 | | | | | | | | +--- org.jetbrains.kotlin:kotlin-stdlib:1.8.22 (*) | | | | | | | | \\--- org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.8.22 | | | | | | | | \\--- org.jetbrains.kotlin:kotlin-stdlib:1.8.22 (*) | | | | | | | +--- org.jetbrains.kotlinx:kotlinx-coroutines-bom:1.7.3 (*) | | | | | | | \\--- org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.8.20 -&gt; 1.8.22 (*) | | | | | | +--- androidx.lifecycle:lifecycle-livedata-core:2.6.2 (c) | | | | | | +--- androidx.lifecycle:lifecycle-runtime:2.6.2 (c) | | | | | | +--- androidx.lifecycle:lifecycle-viewmodel:2.6.2 (c) | | | | | | +--- androidx.lifecycle:lifecycle-viewmodel-savedstate:2.6.2 (c) | | | | | | \\--- androidx.lifecycle:lifecycle-livedata:2.6.2 (c) | | | | | +--- org.jetbrains.kotlin:kotlin-stdlib:1.8.10 -&gt; 1.8.22 (*) | | | | | +--- androidx.lifecycle:lifecycle-common:2.6.2 (c) | | | | | +--- androidx.lifecycle:lifecycle-livedata-core:2.6.2 (c) | | | | | +--- androidx.lifecycle:lifecycle-viewmodel:2.6.2 (c) | | | | | +--- androidx.lifecycle:lifecycle-viewmodel-savedstate:2.6.2 (c) | | | | | \\--- androidx.lifecycle:lifecycle-livedata:2.6.2 (c) | | | | +--- androidx.versionedparcelable:versionedparcelable:1.1.1 | | | | | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | | | | \\--- androidx.collection:collection:1.0.0 -&gt; 1.1.0 | | | | | \\--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | | | \\--- org.jetbrains.kotlin:kotlin-stdlib:1.8.22 (*) | | | \\--- org.jetbrains.kotlin:kotlin-stdlib:1.8.22 (*) | | +--- androidx.core:core-viewtree:1.0.0 | | | +--- org.jetbrains.kotlin:kotlin-stdlib -&gt; 1.8.22 (*) | | | \\--- org.jetbrains.kotlin:kotlin-stdlib:1.8.22 (c) | | +--- androidx.lifecycle:lifecycle-common:2.6.1 -&gt; 2.6.2 (*) | | +--- androidx.lifecycle:lifecycle-runtime:2.6.1 -&gt; 2.6.2 (*) | | +--- androidx.lifecycle:lifecycle-viewmodel:2.6.1 -&gt; 2.6.2 | | | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | | +--- org.jetbrains.kotlin:kotlin-stdlib:1.8.10 -&gt; 1.8.22 (*) | | | +--- androidx.lifecycle:lifecycle-common:2.6.2 (c) | | | +--- androidx.lifecycle:lifecycle-livedata-core:2.6.2 (c) | | | +--- androidx.lifecycle:lifecycle-runtime:2.6.2 (c) | | | +--- androidx.lifecycle:lifecycle-viewmodel-savedstate:2.6.2 (c) | | | \\--- androidx.lifecycle:lifecycle-livedata:2.6.2 (c) | | +--- androidx.lifecycle:lifecycle-viewmodel-savedstate:2.6.1 -&gt; 2.6.2 | | | +--- androidx.annotation:annotation:1.0.0 -&gt; 1.8.1 (*) | | | +--- androidx.core:core-ktx:1.2.0 -&gt; 1.13.0 (*) | | | +--- androidx.lifecycle:lifecycle-livedata-core:2.6.2 | | | | +--- androidx.lifecycle:lifecycle-common:2.6.2 (*) | | | | +--- org.jetbrains.kotlin:kotlin-stdlib:1.8.10 -&gt; 1.8.22 (*) | | | | +--- androidx.lifecycle:lifecycle-common:2.6.2 (c) | | | | +--- androidx.lifecycle:lifecycle-runtime:2.6.2 (c) | | | | +--- androidx.lifecycle:lifecycle-viewmodel:2.6.2 (c) | | | | +--- androidx.lifecycle:lifecycle-viewmodel-savedstate:2.6.2 (c) | | | | \\--- androidx.lifecycle:lifecycle-livedata:2.6.2 (c) | | | +--- androidx.lifecycle:lifecycle-viewmodel:2.6.2 (*) | | | +--- androidx.savedstate:savedstate:1.2.1 | | | | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | | | \\--- org.jetbrains.kotlin:kotlin-stdlib:1.8.10 -&gt; 1.8.22 (*) | | | +--- org.jetbrains.kotlin:kotlin-stdlib:1.8.10 -&gt; 1.8.22 (*) | | | +--- org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4 -&gt; 1.7.3 (*) | | | +--- androidx.lifecycle:lifecycle-common:2.6.2 (c) | | | +--- androidx.lifecycle:lifecycle-livedata-core:2.6.2 (c) | | | +--- androidx.lifecycle:lifecycle-runtime:2.6.2 (c) | | | +--- androidx.lifecycle:lifecycle-viewmodel:2.6.2 (c) | | | \\--- androidx.lifecycle:lifecycle-livedata:2.6.2 (c) | | +--- androidx.savedstate:savedstate:1.2.1 (*) | | +--- org.jetbrains.kotlin:kotlin-stdlib -&gt; 1.8.22 (*) | | \\--- org.jetbrains.kotlin:kotlin-stdlib:1.8.22 (c) | +--- androidx.annotation:annotation:1.3.0 -&gt; 1.8.1 (*) | +--- androidx.appcompat:appcompat-resources:1.7.1 | | +--- androidx.annotation:annotation:1.2.0 -&gt; 1.8.1 (*) | | +--- androidx.core:core:1.6.0 -&gt; 1.13.0 (*) | | +--- androidx.vectordrawable:vectordrawable:1.1.0 | | | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | | +--- androidx.core:core:1.1.0 -&gt; 1.13.0 (*) | | | \\--- androidx.collection:collection:1.1.0 (*) | | +--- androidx.vectordrawable:vectordrawable-animated:1.1.0 | | | +--- androidx.vectordrawable:vectordrawable:1.1.0 (*) | | | +--- androidx.interpolator:interpolator:1.0.0 | | | | \\--- androidx.annotation:annotation:1.0.0 -&gt; 1.8.1 (*) | | | \\--- androidx.collection:collection:1.1.0 (*) | | \\--- androidx.appcompat:appcompat:1.7.1 (c) | +--- androidx.core:core:1.13.0 (*) | +--- androidx.cursoradapter:cursoradapter:1.0.0 | | \\--- androidx.annotation:annotation:1.0.0 -&gt; 1.8.1 (*) | +--- androidx.drawerlayout:drawerlayout:1.0.0 -&gt; 1.1.1 | | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | +--- androidx.core:core:1.2.0 -&gt; 1.13.0 (*) | | \\--- androidx.customview:customview:1.1.0 | | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | \\--- androidx.core:core:1.3.0 -&gt; 1.13.0 (*) | +--- androidx.fragment:fragment:1.5.4 | | +--- androidx.activity:activity:1.5.1 -&gt; 1.10.1 (*) | | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | +--- androidx.annotation:annotation-experimental:1.0.0 -&gt; 1.4.0 (*) | | +--- androidx.collection:collection:1.1.0 (*) | | +--- androidx.core:core-ktx:1.2.0 -&gt; 1.13.0 (*) | | +--- androidx.lifecycle:lifecycle-livedata-core:2.5.1 -&gt; 2.6.2 (*) | | +--- androidx.lifecycle:lifecycle-viewmodel:2.5.1 -&gt; 2.6.2 (*) | | +--- androidx.lifecycle:lifecycle-viewmodel-savedstate:2.5.1 -&gt; 2.6.2 (*) | | +--- androidx.loader:loader:1.0.0 | | | +--- androidx.annotation:annotation:1.0.0 -&gt; 1.8.1 (*) | | | +--- androidx.core:core:1.0.0 -&gt; 1.13.0 (*) | | | +--- androidx.lifecycle:lifecycle-livedata:2.0.0 -&gt; 2.6.2 | | | | +--- androidx.arch.core:core-runtime:2.1.0 -&gt; 2.2.0 | | | | | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | | | | \\--- androidx.arch.core:core-common:2.2.0 (*) | | | | +--- androidx.lifecycle:lifecycle-livedata-core:2.6.2 (*) | | | | +--- org.jetbrains.kotlin:kotlin-stdlib:1.8.10 -&gt; 1.8.22 (*) | | | | +--- androidx.lifecycle:lifecycle-common:2.6.2 (c) | | | | +--- androidx.lifecycle:lifecycle-livedata-core:2.6.2 (c) | | | | +--- androidx.lifecycle:lifecycle-runtime:2.6.2 (c) | | | | +--- androidx.lifecycle:lifecycle-viewmodel:2.6.2 (c) | | | | \\--- androidx.lifecycle:lifecycle-viewmodel-savedstate:2.6.2 (c) | | | \\--- androidx.lifecycle:lifecycle-viewmodel:2.0.0 -&gt; 2.6.2 (*) | | +--- androidx.savedstate:savedstate:1.2.0 -&gt; 1.2.1 (*) | | +--- androidx.viewpager:viewpager:1.0.0 | | | +--- androidx.annotation:annotation:1.0.0 -&gt; 1.8.1 (*) | | | +--- androidx.core:core:1.0.0 -&gt; 1.13.0 (*) | | | \\--- androidx.customview:customview:1.0.0 -&gt; 1.1.0 (*) | | \\--- org.jetbrains.kotlin:kotlin-stdlib:1.6.21 -&gt; 1.8.22 (*) | +--- androidx.savedstate:savedstate:1.2.1 (*) | \\--- androidx.appcompat:appcompat-resources:1.7.1 (c) +--- com.google.android.material:material:1.12.0 | +--- androidx.activity:activity:1.8.0 -&gt; 1.10.1 (*) | +--- androidx.annotation:annotation:1.2.0 -&gt; 1.8.1 (*) | +--- androidx.appcompat:appcompat:1.6.1 -&gt; 1.7.1 (*) | +--- androidx.cardview:cardview:1.0.0 | | \\--- androidx.annotation:annotation:1.0.0 -&gt; 1.8.1 (*) | +--- androidx.coordinatorlayout:coordinatorlayout:1.1.0 | | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | +--- androidx.core:core:1.1.0 -&gt; 1.13.0 (*) | | +--- androidx.customview:customview:1.0.0 -&gt; 1.1.0 (*) | | \\--- androidx.collection:collection:1.0.0 -&gt; 1.1.0 (*) | +--- androidx.constraintlayout:constraintlayout:2.0.1 -&gt; 2.2.1 | +--- androidx.core:core:1.6.0 -&gt; 1.13.0 (*) | +--- androidx.drawerlayout:drawerlayout:1.1.1 (*) | +--- androidx.dynamicanimation:dynamicanimation:1.0.0 | | +--- androidx.core:core:1.0.0 -&gt; 1.13.0 (*) | | +--- androidx.collection:collection:1.0.0 -&gt; 1.1.0 (*) | | \\--- androidx.legacy:legacy-support-core-utils:1.0.0 | | +--- androidx.annotation:annotation:1.0.0 -&gt; 1.8.1 (*) | | +--- androidx.core:core:1.0.0 -&gt; 1.13.0 (*) | | +--- androidx.documentfile:documentfile:1.0.0 | | | \\--- androidx.annotation:annotation:1.0.0 -&gt; 1.8.1 (*) | | +--- androidx.loader:loader:1.0.0 (*) | | +--- androidx.localbroadcastmanager:localbroadcastmanager:1.0.0 | | | \\--- androidx.annotation:annotation:1.0.0 -&gt; 1.8.1 (*) | | \\--- androidx.print:print:1.0.0 | | \\--- androidx.annotation:annotation:1.0.0 -&gt; 1.8.1 (*) | +--- androidx.annotation:annotation-experimental:1.0.0 -&gt; 1.4.0 (*) | +--- androidx.fragment:fragment:1.2.5 -&gt; 1.5.4 (*) | +--- androidx.lifecycle:lifecycle-runtime:2.0.0 -&gt; 2.6.2 (*) | +--- androidx.recyclerview:recyclerview:1.0.0 -&gt; 1.1.0 | | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | | +--- androidx.core:core:1.1.0 -&gt; 1.13.0 (*) | | +--- androidx.customview:customview:1.0.0 -&gt; 1.1.0 (*) | | \\--- androidx.collection:collection:1.0.0 -&gt; 1.1.0 (*) | +--- androidx.resourceinspection:resourceinspection-annotation:1.0.1 | +--- androidx.transition:transition:1.5.0 | | +--- androidx.annotation:annotation:1.2.0 -&gt; 1.8.1 (*) | | \\--- androidx.core:core:1.13.0 (*) | +--- androidx.vectordrawable:vectordrawable:1.1.0 (*) | \\--- androidx.viewpager2:viewpager2:1.0.0 | +--- androidx.annotation:annotation:1.1.0 -&gt; 1.8.1 (*) | +--- androidx.fragment:fragment:1.1.0 -&gt; 1.5.4 (*) | +--- androidx.recyclerview:recyclerview:1.1.0 (*) | +--- androidx.core:core:1.1.0 -&gt; 1.13.0 (*) | \\--- androidx.collection:collection:1.1.0 (*) +--- androidx.activity:activity:1.10.1 (*) +--- androidx.constraintlayout:constraintlayout:2.2.1 追踪 SO 依赖 在添加的 AAR 依赖中还可能存在 SO 库，这追踪起来就相对麻烦一些，相信近期适配 Android 16KB Page Size 的小伙伴可能深有体会。 我目前没找到官方有类似的任务供我们一键调用，所以写了个任务： def variantName = &quot;dokitDebug&quot; def soName = &quot;librtmp-jni.so&quot; android.applicationVariants.all { variant -&gt; if (variant.name != variantName) return // 只处理你关心的变体 tasks.register(&quot;findSoOwner${variant.name.capitalize()}&quot;) { group = &quot;verification&quot; description = &quot;查找 ${soName} 来自哪个 AAR&quot; def artifacts = variant.runtimeConfiguration.incoming.artifacts doLast { artifacts.artifacts.each { artifact -&gt; def file = artifact.file if (file.name.endsWith(&quot;.aar&quot;)) { new java.util.zip.ZipFile(file).withCloseable { zf -&gt; zf.entries().each { entry -&gt; if (entry.name.endsWith(soName)) { println &quot;Found ${soName} in ${artifact.id.componentIdentifier} (${file.name})&quot; } } } } } } } } 将最开始的两个变量要修改为自己实际项目中的内容，比如我这里就在一个名为 dokitDebug 的变体下查询 librtmp-jni.so 这个 SO 的来源，只需在终端中执行命令： ➜ ./gradlew :app:findSoOwner 就可以得到以下输出： &gt; Task :app:findSoOwnerDokitDebug Found librtmp-jni.so in io.antmedia:rtmp-client:3.2.0 (rtmp-client-3.2.0.aar) Found librtmp-jni.so in io.antmedia:rtmp-client:3.2.0 (rtmp-client-3.2.0.aar) Found librtmp-jni.so in io.antmedia:rtmp-client:3.2.0 (rtmp-client-3.2.0.aar) Found librtmp-jni.so in io.antmedia:rtmp-client:3.2.0 (rtmp-client-3.2.0.aar) 我们可以在结果中看到查找的 SO 库来源于哪个依赖，结果可能会输出多次。 查询到的依赖也许并不是你自己添加的，这时候只需再使用上一节提到的命令打印依赖树，就可以追踪到根依赖了。 ","link":"https://LiarrDev.github.io/post/How-to-Trace-Android-Dependency-Sources/"},{"title":"用 DataStore 将你拉出 SharedPreferences 泥潭","content":"简介 DataStore 是一种数据存储解决方案，允许您使用 ProtoBuf 存储键值对或类型化对象，由 Android 官方在 2020 年推出，并在 2021 年正式发布的库，旨在替代服役多年的 SharedPreferences。 SharedPreferences 的缺陷 文件数据的读取加锁，如果 SharedPreferences 文件未被加载或解析到内存中，读写操作都需要等待，可能会对 UI 线程流畅度造成一定影响，甚至ANR. 在保存数据时，无论是 commit() 还是 apply() 都有可能引发 ANR 问题。 没有错误提示机制。 DataStore 的优点 基于 Flow 实现，保证主线程的安全性。 以事务方式处理更新数据。 可以监听到操作成功或者失败结果。 多进程使用。 Preferences DataStore 和 Proto DataStore DataStore 提供两种不同的实现：Preferences DataStore 和 Proto DataStore。 Preferences DataStore 使用键存储和访问数据。此实现不需要预定义的架构，也不确保类型安全。 Proto DataStore 将数据作为自定义数据类型的实例进行存储。此实现要求您使用 ProtoBuf 来定义架构，但可以确保类型安全。 Preferences DataStore Preferences DataStore 用于存储键值对，相当于 SharedPreferences 的改良版。 dependencies { implementation(&quot;androidx.datastore:datastore-preferences:1.1.0&quot;) } 实例： // At the top level of your kotlin file: val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = &quot;settings&quot;) 读取： val EXAMPLE_COUNTER = intPreferencesKey(&quot;example_counter&quot;) val exampleCounterFlow: Flow&lt;Int&gt; = context.dataStore.data.map { preferences -&gt; // No type safety. preferences[EXAMPLE_COUNTER] ?: 0 } 支持的类型基本与 SharedPreferences 一致。 写入： suspend fun incrementCounter() { context.dataStore.edit { settings -&gt; val currentCounterValue = settings[EXAMPLE_COUNTER] ?: 0 settings[EXAMPLE_COUNTER] = currentCounterValue + 1 } } 转换块中的所有代码均被视为单个事务。 Proto DataStore Proto DataStore 用于存储类型化对象，相当于 SharedPreferences 的升级版。它使用了 Protocol Buffers。 dependencies { implementation(&quot;androidx.datastore:datastore:1.1.0&quot;) } 在 app/src/main/proto/ 目录下预定义： // Settings.proto syntax = &quot;proto3&quot;; option java_package = &quot;com.example.application&quot;; option java_multiple_files = true; message Settings { int32 example_counter = 1; } 用于告知 DataStore 如何读取和写入数据的序列化器： object SettingsSerializer : Serializer&lt;Settings&gt; { override val defaultValue: Settings = Settings.getDefaultInstance() override suspend fun readFrom(input: InputStream): Settings { try { return Settings.parseFrom(input) } catch (e: InvalidProtocolBufferException) { throw CorruptionException(&quot;Cannot read proto.&quot;, e) } } override suspend fun writeTo(t: Settings, output: OutputStream) = t.writeTo(output) } 实例： // At the top level of your kotlin file: val Context.settingsDataStore: DataStore&lt;Settings&gt; by dataStore( fileName = &quot;settings.pb&quot;, serializer = SettingsSerializer ) 读取： val exampleCounterFlow: Flow&lt;Int&gt; = context.settingsDataStore.data.map { settings -&gt; // The exampleCounter property is generated from the proto schema. settings.exampleCounter } 写入： suspend fun incrementCounter() { context.settingsDataStore.updateData { it.toBuilder() .setExampleCounter(it.exampleCounter + 1) .build() } } 同样以事务方式更新数据。 从 SharedPreferences 中迁移 private val Context.migrationDataStore: DataStore&lt;Preferences&gt; by preferencesDataStore( name = PREF_FILE_NAME, produceMigrations = { listOf(SharedPreferencesMigration(it, PREF_FILE_NAME)) } ) 数据的迁移在创建 DataStore 的过程中自动完成，迁移完成后，原 SharedPreferences 的 XML 文件会被删除。 对比 MMKV MMKV 是微信团队开源的基于 mmap 内存映射的 Key-Value 组件，底层序列化与反序列化同样使用 ProtoBuf，性能高，稳定性强。 虽然 MMKV 的初衷并不是替代 SharedPreferences，但是同样作为 Key-Value 组件，大多数人都将 MMKV 视为 SharedPreferences 的替代品。 官方文档中也对 MMKV 和 SharedPreferences 的性能进行了对比： 事实上，MMKV 并不是任何时候都更强。由于内存映射这种方案是自行管理一块独立的内存，所以它在尺寸的伸缩上面就比较受限，这就导致它在写大一点的数据时，速度会慢。 另一方面，该写入耗时对于正常开发来说并非特别重要，界面的流畅度更在意主线程的耗时，而 SharedPreferences 本身也提供了异步写入的 API，所以它们都足够快了。但 MMKV 的诞生场景决定了，它更在意同步处理机制下的耗时。 MMKV 还有一个缺陷——丢数据。操作系统在往磁盘写数据的过程中发生意外都会导致文件损坏，这种问题不可避免。MMKV 虽然由于底层机制的原因，在程序崩溃的时候不会影响数据往磁盘的写入，但断电关机之类的操作系统级别的崩溃，MMKV 就没办法了，文件照样会损坏。 对于这种文件损坏，SharedPreferences 和 DataStore 的应对方式是在每次写入新数据之前都对现有文件做一次自动备份，这样在发生了意外出现了文件损坏之后，它们就会把备份的数据恢复过来。 而 MMKV，没有这种自动的备份和恢复，那么当文件发生了损坏，数据就丢了，之前保存的各种信息只能被重置。据官方统计，iOS 微信平均约有 70 万日次的数据校验不通过。 因此 MMKV 更适合同步高频写入非重要信息的场景。 参考内容 应用架构：数据层 - DataStore - Android 开发者 | App architecture | Android Developers ","link":"https://LiarrDev.github.io/post/DataStore-Pull-You-Out-of-SharedPreferences-Quagmire/"},{"title":"在 Android 中使用 Protocol Buffers","content":"简介 Protocol Buffers（简称 Protobuf）是 Google 开发的一种独立于语言和平台的结构化数据序列化可扩展机制。它与 JSON 类似，只是体积更小、速度更快，而且能生成本地语言绑定。您只需定义一次数据的结构化方式，然后就可以使用特殊生成的源代码，使用各种语言轻松地将结构化数据写入各种数据流或从各种数据流中读取结构化数据。 Google 提供了多种语言的实现，每一种实现都包含了相应语言的编译器以及库文件。由于它是一种二进制的格式，比使用 XML 进行数据交换快许多（体积小 3～10 倍，速度快 20～100 倍）。作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于诸如网络传输、配置文件、数据存储等诸多领域。 它有一个非常棒的特性，即“向后”兼容性好，人们不必破坏已部署的、依靠“老”数据格式的程序就可以对数据结构进行升级。这样您的程序就可以不必担心因为消息结构的改变而造成的大规模的代码重构或者迁移的问题。因为添加新的消息中的 field 并不会引起已经发布的程序的任何改变。 Protobuf 与 XML 和 JSON 相比也有不足之处。由于 XML 和 JSON 具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上 Protobuf 不行，它以二进制的方式存储。 语法 syntax = &quot;proto3&quot;; message SearchRequest { string query = 1; int32 page_number = 2; int32 results_per_page = 3; } 第一行说明使用的是 proto3 语法：如果不这样做，Protobuf 编译器会认为使用的是 proto2。这必须是文件中第一行非空、非注释的内容。 SearchRequest 报文定义指定了三个字段（名称/值对），每个字段代表一条要包含在此类报文中的数据。每个字段都有名称和类型。 须为信息定义中的每个字段赋予一个介于 1 到 536,870,911（229−12^{29} -1229−1）之间的数字，在该报文中必须唯一，编号 19,000 至 19,999 保留给 Protocol Buffers 实现。 不能使用任何先前保留的编号。更改字段编号相当于删除该字段，然后创建一个类型相同但编号不同的新字段。删除字段定义时必须保留已删除的字段编号，如果不保留字段编号，开发人员将来有可能重新使用该编号。 使用 libs.versions.toml 定义版本： [libraries] protobuf-protoc = { group = &quot;com.google.protobuf&quot;, name = &quot;protoc&quot;, version.ref = &quot;protobuf&quot; } protobuf-javalite = { group = &quot;com.google.protobuf&quot;, name = &quot;protobuf-javalite&quot;, version.ref = &quot;protobuf&quot; } [plugins] googleProtobuf = { id = &quot;com.google.protobuf&quot;, version.ref = &quot;protobufPlugin&quot; } 项目的 build.gradle.kts： plugins { // ... alias(libs.plugins.googleProtobuf) apply false } app 的 build.gradle.kts： import com.google.protobuf.gradle.proto plugins { // ... alias(libs.plugins.googleProtobuf) } android { //... sourceSets { getByName(&quot;main&quot;).java.srcDir(&quot;src/main/java&quot;) getByName(&quot;main&quot;).proto { srcDir(&quot;src/main/proto&quot;) include(&quot;**/*.proto&quot;) } } } protobuf { protoc { artifact = libs.protoc.get().toString() } plugins { generateProtoTasks { all().forEach { it.builtins { create(&quot;java&quot;) { option(&quot;lite&quot;) } } } } } } dependencies { // ... implementation(libs.protobuf.protoc) implementation(libs.protobuf.javalite) } 混淆配置： -keep class * extends com.google.protobuf.GeneratedMessageLite { *; } 在 app/src/main/proto 目录中创建 proto 文件： 内容如下： syntax = &quot;proto3&quot;; // 声明 proto 协议版本 package com.example.proto; // 定义 Protobuf 自动生成类的包名 option java_package = &quot;com.example.proto&quot;; // Java 类所在的包名 option java_outer_classname= &quot;SearchRequestProto&quot;; // 定义 Protobuf 自动生成类的类名 message SearchRequest { string query = 1; int32 page_number = 2; int32 results_per_page = 3; } Build 项目，会在 app/build/generated/source/proto 中生成对应的 Java 文件： 生成的 Java 文件内容太长，就不贴在这里了，但是结构简单，无非就是一堆 Getter 和 Setter 以及一些解析方法，相信你也可以轻易读懂。 接下来就可以在代码中调用它： @Test fun proto() { // 序列化 val request = SearchRequestProto.SearchRequest.newBuilder() .setQuery(&quot;Proto&quot;) .setPageNumber(1) .setResultsPerPage(10) .build() val bytes = request.toByteArray() // 反序列化 try { val result = SearchRequestProto.SearchRequest.parseFrom(bytes) val query = result.query val pageNumber = result.pageNumber val resultPerPage = result.resultsPerPage } catch (e: Exception) { e.printStackTrace() } } 序列化利用的是 Builder 模式，构建成一个 SearchRequest 对象后，再将其转换成 ByteArray。反序列化则利用 parseFrom() 方法将 ByteArray 或者 InputStream 转成 SearchRequest 对象，parseFrom() 方法就是在上方生成的 Java 文件中自动帮我们插入的方法。 参考内容 Language Guide (proto 3) | Protocol Buffers Documentation ","link":"https://LiarrDev.github.io/post/Protocol-Buffers-Usage-on-Android/"},{"title":"Design Pattern: Builder","content":"建造者模式（Builder Pattern，也叫生成器模式）是最常用的设计模式之一，它与之前介绍的『Design Pattern: Singleton』和『Design Pattern: Factory』都属于创建类型的设计模式。 它可以将复杂对象的构建过程抽象出来，使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 在讲 Builder 模式实现之前，先看看之前我们构建复杂对象时是如何编写的。 构造器重载（Telescoping Constructor anti-pattern） public class Article { private String title; private String content; private String author; private Date date; public Article(String title, String content) { ... } public Article(String title, String content, String author) { ... } public Article(String title, String content, Date date) { ... } public Article(String title, String content, String author, Date date) { ... } } 通过在构造器中传递不同数量的参数，从而实现构建不同属性组合的对象。这种方法简单直观，但随着属性增加，构造器的参数组合呈指数级增长，你就很难记住参数的顺序以及在特定情况下你可能需要的特定构造函数，难以维护和理解。 Kotlin 的出现倒是很大程度上解决了这个问题： data class Article( val title: String = &quot;&quot;, val content: String = &quot;&quot;, val author: String = &quot;&quot;, val date: Date = Date() ) 尽管如此，它在扩展性上还是稍有欠缺，比如同一属性不同类型的构造，这时候还是要回到构造函数重载的方案。 data class Article( val title: String = &quot;&quot;, val content: String = &quot;&quot;, val author: String = &quot;&quot;, val date: Date = Date() ) { constructor( title: String = &quot;&quot;, content: String = &quot;&quot;, author: String = &quot;&quot;, millis: Long = System.currentTimeMillis() ) : this(title, content, author, Date(millis)) } Setter Setter 方法可以很好地解决构造函数膨胀的问题，只需添加对应的重载方法即可： class Article { private var title: String = &quot;&quot; private var content: String = &quot;&quot; private var author: String = &quot;&quot; private var date: Date = Date() fun setTitle(title: String) { ... } fun setContent(content: String) { ... } fun setAuthor(author: String) { ... } fun setDate(date: Date) { this.date = date } fun setDate(millis: Long) { this.date = Date(millis) } } 使用 Setter 逐个设置属性的值，灵活性较强，但也可能导致对象在构建过程中处于不完整状态，可变性带来的线程安全性问题，无法保证对象的不变性。 建造者模式 建造者模式通过一个独立的 Builder 类负责构建对象，可以确保对象在构建时处于合法状态。 建造者模式包含如下角色： Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：指挥者 Product：产品角色 下面是一个简单的示例： /** &quot;Product&quot; */ data class Pizza(var dough: String = &quot;&quot;, var sauce: String = &quot;&quot;, var topping: String = &quot;&quot;) /** &quot;Abstract Builder&quot; */ abstract class PizzaBuilder { lateinit var pizza: Pizza private set fun createPizza() { pizza = Pizza() } abstract fun buildDough() abstract fun buildSauce() abstract fun buildTopping() } /** &quot;Concrete Builder&quot; */ class HawaiianPizzaBuilder : PizzaBuilder() { override fun buildDough() { pizza.dough = &quot;cross&quot; } override fun buildSauce() { pizza.sauce = &quot;mild&quot; } override fun buildTopping() { pizza.topping = &quot;ham + pineapple&quot; } } /** &quot;Concrete Builder&quot; */ class SpicyPizzaBuilder : PizzaBuilder() { override fun buildDough() { pizza.dough = &quot;pan baked&quot; } override fun buildSauce() { pizza.sauce = &quot;hot&quot; } override fun buildTopping() { pizza.topping = &quot;pepperoni + salami&quot; } } /** &quot;Director&quot; */ class Chef { lateinit var pizzaBuilder: PizzaBuilder fun getPizza() = pizzaBuilder.pizza fun constructPizza() { pizzaBuilder.createPizza() pizzaBuilder.buildDough() pizzaBuilder.buildSauce() pizzaBuilder.buildTopping() } } fun main() { val chef = Chef() val hawaiianBuilder = HawaiianPizzaBuilder() val spicyPizzaBuilder = SpicyPizzaBuilder() chef.pizzaBuilder = hawaiianBuilder chef.constructPizza() val pizza = chef.getPizza() } 这里构建了一个厨师做披萨了例子，Chef 并不会直接构建 Pizza 对象，因为这个过程很容易出错，而是根据菜谱，也就是 Builder 实例来制作，PizzaBuilder 是个抽象类，由子类来实现具体的制作过程中所需的材料，Chef 无须关心做这个披萨需要菠萝还是火腿，这个由 PizzaBuilder 构建，Chef 拿到菜谱，按照上面的步骤执行即可。 以上这个就是建造者模式比较官方的例子。 抽象的引入似乎很容易会与之前介绍的工厂模式混淆，工厂模式的目的是实现多态性，而建造者模式的目的是找到一种解决伸缩构造器反模式的方法，它使用一个构造器，逐步接收每个初始化参数，然后一次性返回所构造的对象。 简单来说，两者都可以创建复杂的对象，主要区别是工厂模式着重于多个产品对象，且产品对象是立即返回的，而建造者模式着重于一步步构造一个复杂对象，产品在最后的一步返回。 另一方面，虽然利用建造者模式可以创建出不同类型的产品，但是如果产品之间的差异巨大，则需要编写多个建造者类才能实现，如果这时结合工厂模式会是一个更好的选择。 为了更好地理解建造者模式，下面是一个对于 Android 开发者来说更常见的例子，OkHttp 网络请求库内部就大量应用了建造者模式，以创建 Request 为例： object HttpUtils { private val client = OkHttpClient() fun doRequest(url: String) { val request = Request.Builder().url(url).build() client.newCall(request).enqueue(object : Callback { ... }) } } Request 的构造方法一共 5 个参数，还有其他成员变量，我们通过它的静态内部类 Builder 按需设置它的 url 和 method 等参数，最后调用 build() 方法，Builder 会自动帮我们构建 Request 对象。 可以简单看看 Request 的源码： class Request internal constructor( @get:JvmName(&quot;url&quot;) val url: HttpUrl, @get:JvmName(&quot;method&quot;) val method: String, @get:JvmName(&quot;headers&quot;) val headers: Headers, @get:JvmName(&quot;body&quot;) val body: RequestBody?, internal val tags: Map&lt;Class&lt;*&gt;, Any&gt; ) { ... open class Builder { internal var url: HttpUrl? = null internal var method: String internal var headers: Headers.Builder internal var body: RequestBody? = null internal var tags: MutableMap&lt;Class&lt;*&gt;, Any&gt; = mutableMapOf() ... constructor() { this.method = &quot;GET&quot; this.headers = Headers.Builder() } open fun url(url: HttpUrl): Builder = apply { this.url = url } open fun url(url: String): Builder { val finalUrl: String = when { url.startsWith(&quot;ws:&quot;, ignoreCase = true) -&gt; { &quot;http:${url.substring(3)}&quot; } url.startsWith(&quot;wss:&quot;, ignoreCase = true) -&gt; { &quot;https:${url.substring(4)}&quot; } else -&gt; url } return url(finalUrl.toHttpUrl()) } open fun build(): Request { return Request( checkNotNull(url) { &quot;url == null&quot; }, method, headers.build(), body, tags.toImmutableMap() ) } } } 我们设置的参数经过处理后首先存储在 Builder 中，调用 build() 方法创建 Request 对象时用其构建实例，如果我们没有配置则使用 Builder 中设定的默认值。 在这里，Builder 同时扮演了上文中提到的 Builder、ConcreteBuilder 角色，在 Builder 模式中如果 ConcreteBuilder 只有一个，我们都可以使用这种写法，省略抽象，简化 Builder 模式的设计。 同时，因为 Builder 里的每一个 Setter 方法都返回了 Builder 对象本身，所以我们在调用的时候就可以使用链式写法，更加简洁。 在 Android SDK 中也时常可以见到建造者模式的身影，比如常用的 AlertDialog、Notification 等，由于其涉及到 UI 相关的处理逻辑，代码量较大，就不在这里展开了，可自行阅读源码理解。 优缺点 优点 提高可读性和可维护性：通过使用建造者模式，代码的可读性和可维护性得到提高。建造者模式允许开发者在代码中清晰地看到对象的构建过程，从而更容易理解和修改代码。此外，可以使用链式调用，代码的组织结构更加清晰，易于阅读和编写。 增强对象的不可变性：建造者模式通常与不可变对象（Immutable Objects）一起使用。通过使用建造者模式，可以在对象创建过程中设置所有必要的属性，并在对象构建完成后将其设置为不可变，从而确保对象的一致性和线程安全性，这是一种保护机制，也是建造者模式的特性。 处理可选参数：某些对象可能具有许多可选参数，而不是所有参数都需要在每次创建对象时提供。使用建造者模式，可以通过提供一些设置方法来设置可选参数，而不是在构造函数中使用大量的参数。这使得代码更加简洁，避免了长参数列表的问题。 更好的扩展性：可以通过扩展 Builder 类来支持新的构建步骤，或者通过引入不同的具体 Builder 类来构建不同的对象变种。 缺点 代码量增加：使用建造者模式通常会引入额外的代码，包括 Builder 类本身以及目标类中的 Setter 方法。 可能导致过多的类：如果每个类都需要一个独立的建造者，可能会导致类的数量激增，增加了类的管理和维护的复杂性。 对象状态分散：在建造者模式中，对象的状态可能分散在构造器和目标类中，这使得对象的状态分散，可能导致维护和修改代码更加困难。 ","link":"https://LiarrDev.github.io/post/Design-Pattern-Builder/"},{"title":"Android TextView HTML 超文本跳转","content":"之前在『Android 改变 TextView 内局部样式』中介绍过利用 HTML 标签来设置样式，使用时你可能会遇到超文本跳转的需求，很容易你就能想到给 HTML 字符串添加 &lt;a&gt; 标签： class MainActivity : AppCompatActivity() { // ... override fun onCreate(savedInstanceState: Bundle?) { // ... val content = Html.fromHtml( &quot;这是一个超链接：&lt;a href='https://google.com'&gt;Google&lt;/a&gt;&quot;, Html.FROM_HTML_MODE_LEGACY ) binding.textView.text = content } } TextView 确实出现了超文本的显示效果，但是却不能够响应点击。 我们还需要对其做进一步处理。这里同样用到了『Android 改变 TextView 内局部样式』中介绍的另一种方式，也就是 SpannableString，代码如下： class MainActivity : AppCompatActivity() { // ... override fun onCreate(savedInstanceState: Bundle?) { // ... val content = Html.fromHtml( &quot;这是一个超链接：&lt;a href='https://google.com'&gt;Google&lt;/a&gt;&quot;, Html.FROM_HTML_MODE_LEGACY ) binding.textView.text = content handleHtmlClick(binding.textView) } private fun handleHtmlClick(textView: TextView) { textView.movementMethod = LinkMovementMethod.getInstance() val text = textView.text if (text is Spannable) { val end = text.length val spans = text.getSpans(0, end, URLSpan::class.java) val sb = SpannableStringBuilder(text) sb.clearSpans() for (span in spans) { sb.setSpan( URLSpan(span.url), text.getSpanStart(span), text.getSpanEnd(span), Spanned.SPAN_EXCLUSIVE_INCLUSIVE ) } textView.text = sb } } } 通过 Spanned.getSpans() 方法提取到可点击的 URLSpan，并重新构造 URLSpan 再添加到 SpannableString 中即可。URLSpan 是 ClickableSpan 的实现，当点击其中设置了 Span 的文本时，URLSpan 将尝试通过启动带有 Intent.ACTION_VIEW 的 Activity 来打开 URL。 上面代码的效果就是跳转到浏览器打开超链接。 除了我们常见的网页超链接外，超文本其实还包含其他场景的应用，而上面说到 URLSpan 尝试通过启动带有 Intent.ACTION_VIEW 的 Activity 来打开 URL，这让我们很容易就想起之前介绍过的发送邮件。可以这么写： class MainActivity : AppCompatActivity() { // ... override fun onCreate(savedInstanceState: Bundle?) { // ... val content = Html.fromHtml( &quot;发邮件给 &lt;a href='mailto:foo@bar.com'&gt;foo@bar.com&lt;/a&gt;&quot;, Html.FROM_HTML_MODE_LEGACY ) binding.textView.text = content handleHtmlClick(binding.textView) } private fun handleHtmlClick(textView: TextView) { textView.movementMethod = LinkMovementMethod.getInstance() val text = textView.text if (text is Spannable) { val end = text.length val spans = text.getSpans(0, end, URLSpan::class.java) val sb = SpannableStringBuilder(text) sb.clearSpans() for (span in spans) { sb.setSpan( URLSpan(span.url), text.getSpanStart(span), text.getSpanEnd(span), Spanned.SPAN_EXCLUSIVE_INCLUSIVE ) } textView.text = sb } } } 它也会直接拉起手机的邮件应用： 如果希望接管点击后的逻辑，我们可以自行实现 ClickableSpan： class MainActivity : AppCompatActivity() { // ... override fun onCreate(savedInstanceState: Bundle?) { // ... val content = Html.fromHtml( &quot;这是一个超链接：&lt;a href='https://google.com'&gt;Google&lt;/a&gt;&quot;, Html.FROM_HTML_MODE_LEGACY ) binding.textView.text = content handleHtmlClick(binding.textView) } private fun handleHtmlClick(textView: TextView) { textView.movementMethod = LinkMovementMethod.getInstance() val text = textView.text if (text is Spannable) { val end = text.length val spans = text.getSpans(0, end, URLSpan::class.java) val sb = SpannableStringBuilder(text) sb.clearSpans() for (span in spans) { sb.setSpan( HypertextSpan(this, span.url), text.getSpanStart(span), text.getSpanEnd(span), Spanned.SPAN_EXCLUSIVE_INCLUSIVE ) } textView.text = sb } } } class HypertextSpan(private val context: Context, private val url: String) : ClickableSpan() { override fun onClick(widget: View) { // 处理点击逻辑 } } 我们构造一个 HypertextSpan 来接管点击逻辑，只需将上一步的 URLSpan 替换即可，构造方法中传入 Context 和 URL 可以方便我们处理判断及跳转。 比如在应用内打开网页： ","link":"https://LiarrDev.github.io/post/Handle-Android-Textview-Html-Hypertext-Action/"},{"title":"Android 调用邮箱客户端发送邮件","content":"做商业项目的时候，应用往往需要提供一些用户的反馈渠道，尽管现在有微信公众号、微博等等方便快捷的途径可以与应用开发者取得联系，但邮箱也是不可或缺的一种反馈途径。 在应用开发中，我们时常会拉起邮箱应用来完成发送邮件的操作，同时还会自动帮用户填写部分信息，减少用户的操作步骤，今天就教大家在 Android 开发中如何实现这一操作。 前提是手机需要安装并登录邮箱客户端，你可以使用一些邮箱服务商提供的官方应用，比如『Gmail』、『QQMail』等等，也可以使用手机内置的邮箱应用，具体配置操作可参考『用好手机系统自带的邮件客户端』。 最简单的场景，我们只需要给指定的官方邮箱发送一些文本内容，可以这么写： object EmailSender { fun mailToOne(context: Context) { val intent = Intent(Intent.ACTION_SENDTO, Uri.parse(&quot;mailto:foo@bar.com&quot;)) intent.putExtra(Intent.EXTRA_SUBJECT, &quot;这是主题&quot;) intent.putExtra(Intent.EXTRA_TEXT, &quot;这是内容&quot;) context.startActivity(intent); } } 这里用到了 Activity 的隐式启动，首先需要把 Intent 的 action 设置为 Intent.ACTION_SENDTO，再将 data 设置为 mailto: 开头的 Uri，并在后面拼接邮箱地址，这样就只有邮箱应用才能够响应我们的 Intent。如果需要设置主题和内容，可以填充 Intent.EXTRA_SUBJECT 和 Intent.EXTRA_TEXT 这两个字段。 效果如下： 邮件不仅支持发送给单一收件人，我们可以指定多个收件人，还支持抄送、密送。 object EmailSender { fun mailToMultiple(context: Context) { val intent = Intent(Intent.ACTION_SENDTO) intent.setData(Uri.parse(&quot;mailto:&quot;)) intent.putExtra(Intent.EXTRA_EMAIL, arrayOf(&quot;foo@bar.com&quot;, &quot;bar@foo.com&quot;)) intent.putExtra(Intent.EXTRA_CC, arrayOf(&quot;cc@bar.com&quot;)) // 抄送 intent.putExtra(Intent.EXTRA_BCC, arrayOf(&quot;bcc@bar.com&quot;)) // 密送 intent.putExtra(Intent.EXTRA_SUBJECT, &quot;这是主题&quot;) intent.putExtra(Intent.EXTRA_TEXT, &quot;这是内容&quot;) context.startActivity(intent) } } action 的配置与上文一致，但是 data 不需要拼接收件人的邮箱地址，而是改成在 Intent.EXTRA_EMAIL 字段传入，抄送和密送的邮箱地址则分别在 Intent.EXTRA_CC 和 Intent.EXTRA_BCC 字段传入，这三个字段都接收字符串类型的数组，也就意味着我们可以填充多个邮箱地址。 效果如下： 邮件同时还能上传附件，我们可以这么写： object EmailSender { fun mailAttachments(context: Context) { val file = File(PathUtils.getInternalAppFilesPath(), &quot;screenshot.png&quot;) val intent = Intent(Intent.ACTION_SEND_MULTIPLE) intent.selector = Intent(Intent.ACTION_SENDTO, Uri.parse(&quot;mailto:&quot;)) intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION) intent.putExtra(Intent.EXTRA_EMAIL, arrayOf(&quot;foo@bar.com&quot;)) intent.putExtra(Intent.EXTRA_SUBJECT, &quot;这是主题&quot;) intent.putExtra(Intent.EXTRA_STREAM, arrayListOf(UriUtils.file2Uri(file))) context.startActivity(intent) } } 这里将 action 改成 Intent.ACTION_SEND_MULTIPLE，如果仅仅是这样修改，除了邮箱应用外，许多应用都能够响应我们的 Intent，因此还需要调用 setSelector() 方法，为此 Intent 设置选择器。最后再向 Intent.EXTRA_STREAM 字段传入附件的 Uri，它也接收数组，意味着我们可以传输多个附件。 效果如下： ","link":"https://LiarrDev.github.io/post/Android-Calling-Email-App-to-Send-Email/"},{"title":"ViewPager2 横向嵌套滚动","content":"之前『TabLayout &amp; ViewPager2 快速打造选项卡切换效果]』一文介绍了如何实现一个简单的页面滑动切换效果，随着开发的深入，你可能会遇到 ViewPager2 嵌套滑动的问题，也就是当 ViewPager2 内有一个可以同方向滚动的 View，比如 RecyclerView，它并不能够按照我们的预期工作。 嵌套？之前我们用 NestedScrollView 解决 Android 嵌套滚动问题，这次能不能依葫芦画瓢？ 很显然，并不适合。 既然如此，我们能否通过修改 ViewPager2 的事件分发逻辑，使其根据我们的需要进行分发？ 很遗憾，ViewPager2 被标记为 final，我们无法继承修改。 public final class ViewPager2 extends ViewGroup { ... } RecyclerView 总该不会被标记为 final 吧，我们重写 RecyclerView 是否行得通？ 我们换个角度思考这个问题，这次我们重写 RecyclerView，假如说下次我们需要往 ViewPager2 里嵌套一个 ScrollView 或者其他任意可滚动的 View，岂不是每一个都要重写？有没有一劳永逸的方法？ 其实可以单独自定义一个 ViewGroup 用于处理 ViewPager2 内的事件分发，当添加了需要处理嵌套滑动问题的 View 时，只需要在该 View 外面包一层我们自定义的 ViewGroup，就可以实现对嵌套滑动事件的处理。 class ViewPager2NestedFrameLayout @JvmOverloads constructor(context: Context, attrs: AttributeSet? = null) : FrameLayout(context, attrs) { private val parentViewPager: ViewPager2? get() { var v: View? = parent as? View while (v != null &amp;&amp; v !is ViewPager2) { v = v.parent as? View } return v as? ViewPager2 } override fun dispatchTouchEvent(ev: MotionEvent?): Boolean { when (ev?.action) { MotionEvent.ACTION_DOWN -&gt; { parentViewPager?.isUserInputEnabled = false } MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; { parentViewPager?.isUserInputEnabled = true } } return super.dispatchTouchEvent(ev) } } 我们继承 FrameLayout 来实现，一般情况下该 ViewGroup 仅会包裹我们需要嵌套滚动的 View，所以 FrameLayout 对原有代码的入侵性最小，同时性能也最优。 这其中一个关键点是如何获取 ViewPager2 的实例，当然我们可以通过外部传入，但这样每次使用时都需要手动设置一遍，非常麻烦。于是这里采用另一种方式，通过 View 的 getParent() 方法获取其父 View，然后判断其是否为 ViewPager2，如果是则返回，否则继续向上查找。 拿到 ViewPager2 的实例就好办了，当接收到 ACTION_DOWN 事件时，我们调用 setUserInputEnabled() 设置为 false，禁止 ViewPager2 滚动，当接收到 ACTION_UP 或 ACTION_CANCEL 事件时，我们设置为 true，允许 ViewPager2 滚动。 使用方法正如我们前面所述，包裹在需要嵌套滑动的 View 外即可： &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.NestedFragment&quot;&gt; ... &lt;com.example.nested.ViewPager2NestedFrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layoutManager=&quot;androidx.recyclerview.widget.LinearLayoutManager&quot; /&gt; &lt;/com.example.nested.ViewPager2NestedFrameLayout&gt; &lt;/FrameLayout&gt; 效果如下： 正如我们所期望的那样工作，由于范围仅限制在该 ViewGroup 范围内，所以触摸该 ViewGroup 以外的区域仍能够使 ViewPager2 正常滑动。 ","link":"https://LiarrDev.github.io/post/ViewPager2-Horizontal-Nested-Scroll/"},{"title":"ArkUI 自定义组件：KeyCap 实践","content":"之前在『「MOJiKana」中模仿实体按键的动效是如何实现的？』一文中介绍了 Android 平台 View 体系以及 Compose 体系关于 KeyCap 的开发实践。文中我顺嘴提了一句 ArkUI 的实现方式，但并未给出实际代码，今天单独来讲下 ArkUI 中的实现方式。 因为 Android 平台无论是 View 还是 Compose 默认情况下都不支持单独设置某一方向上的边框，所以我们采用两个图层叠加的方式来模拟。采用两个图层有个小缺陷，就是当两个图层之间的间隔过高时，视觉效果就不再像是一个实体按键了。 当然，这既可以归咎为使用不当，也可以说是我设计的时候并没有兼容，其实只需要将底部图层的高度撑满整个父布局就可以解决这个问题。 但是像 ArkUI 就可以使用单边 border 来规避这种问题。 @Component export struct KeyCap { keyFlatColor: ResourceColor = Color.Transparent keyShadowColor: ResourceColor = Color.Transparent keyStroke: Length = 0 keyCapRadius: Length = 0 @BuilderParam child: () =&gt; void = this.customBuilder @State private pressed: boolean = false @Builder customBuilder() { } build() { RelativeContainer() { Stack({ alignContent: Alignment.Center }) { this.child() } .width('100%') .backgroundColor(this.keyFlatColor) .margin({ top: this.pressed ? this.keyStroke : 0 }) .borderRadius(this.keyCapRadius) .borderColor(this.keyShadowColor) .borderWidth({ bottom: this.pressed ? 0 : this.keyStroke }) .alignRules({ top: { anchor: '__container__', align: VerticalAlign.Top }, bottom: { anchor: '__container__', align: VerticalAlign.Bottom } }) }.onTouch((event: TouchEvent) =&gt; { if (event.type == TouchType.Down) { this.pressed = true } else if (event.type == TouchType.Up || event.type == TouchType.Cancel) { this.pressed = false } }) } } 属性还是跟之前一样，可以看到这里少了一层组件，通过判断是否按压来调节底部边框宽度以及顶部边距，整体代码量又简洁了不少。 虽说这种方式值的一夸，但众所周知，ArkUI 从不经夸。在自定义组件中，如果需要添加子组件，我们无法像 Compose 一样采用高阶函数，甚至由于系统组件无法查看具体实现，我们没办法模拟出这种闭包的写法，只能将子组件通过属性传递。 子组件需要通过 @BuilderParam 传递，它用来承接 @Builder 函数，这意味着我们还需要单独写一个 @Builder 函数来实现子组件： @Entry @Component struct MainPage { Stack({ alignContent: Alignment.Center }) { KeyCap({ keyFlatColor: Color.Brown, keyShadowColor: Color.Orange, keyStroke: 6, keyCapRadius: 60, child: this.keyCapChildBuilder }) .width(120) .height(54) .onClick(() =&gt; {}) } @Builder keyCapChildBuilder() { Text() // 子组件实现 } } 这种设计非常蠢，仿佛 View Tree 层次缺失，不利于阅读。 又能怎么样呢，甩甩手上的屎继续写呗。 ","link":"https://LiarrDev.github.io/post/ArkUI-Custom-Components-KeyCap/"},{"title":"Design Pattern: Factory","content":"前言 工厂模式（Factory Pattern）是最常用的设计模式之一，它与之前介绍的『Design Pattern: Singleton』都属于创建类型的设计模式。 它在创建对象时提供了一种封装机制，将实际创建对象的代码与使用代码分离。在创建对象时不会对客户端暴露创建逻辑，而是使其创建过程延迟到子类进行，并且通过一个共同的接口来指向新创建的对象。它主要解决接口选择的问题。 一般情况下，工厂模式有三种实现：简单工厂模式（Simple Factory）、工厂方法模式（Factory Method）、抽象工厂模式（Abstract Factory）。 这三种模式从上到下逐步抽象，不过值得一提的是，简单工厂模式并不在 GoF 23 种设计模式之列。 下面我们逐一介绍这三种实现。 实现 假设我们需要生产两款手机（以 Apple 和 Samsung 为例），在不使用设计模式的情况下，我们可能会这么写： class Apple(val screen: String, val usb: String) { fun hardware() = println(&quot;[Apple] screen: $screen, usb: $usb&quot;) } class Samsung(val screen: String, val usb: String) { fun hardware() = println(&quot;[Samsung] screen: $screen, usb: $usb&quot;) } fun main() { val apple = Apple(&quot;LCD&quot;, &quot;Lightning&quot;) apple.hardware() val samsung = Samsung(&quot;OLed&quot;, &quot;Type-C&quot;) samsung.hardware() } 即由用户手动去创建实际的对象，在上面这个例子中，用户需要知道如何创建一台手机，需要知道什么手机使用什么屏幕和什么类型的 USB 插口，用户和手机的生产就耦合在一起了。 为了降低耦合性，我们引入工厂模式，把手机的生产细节放到工厂里，用户无需关心这台手机使用什么屏幕和 USB 插口，直接调用工厂的创建方法，不必知道创建的细节。 Simple Factory 简单工厂模式 简介 简单工厂模式又叫作静态工厂方法模式（Static Factory Method）。它将对象的创建逻辑封装在一个工厂类中，客户端通过调用工厂类的静态方法来创建对象。 简单工厂模式包含如下角色： Factory：工厂角色，负责实现创建所有实例的内部逻辑。 AbstractProduct：抽象产品角色，是创建的所有对象的父类，负责描述所有实例的公共接口。 Product：具体产品角色，即创建目标，所有创建的对象都是该角色。 abstract class Phone { abstract fun hardware() } class Apple(val screen: String, val usb: String) : Phone() { override fun hardware() = println(&quot;[Apple] screen: $screen, usb: $usb&quot;) } class Samsung(val screen: String, val usb: String) : Phone() { override fun hardware() = println(&quot;[Samsung] screen: $screen, usb: $usb&quot;) } object PhoneFactory { fun createPhone(type: String): Phone? { return when (type) { &quot;Apple&quot; -&gt; Apple(&quot;LCD&quot;, &quot;Lightning&quot;) &quot;Samsung&quot; -&gt; Samsung(&quot;OLed&quot;, &quot;Type-C&quot;) else -&gt; null } } } fun main() { val apple: Phone? = PhoneFactory.createPhone(&quot;Apple&quot;) apple?.hardware() val samsung: Phone? = PhoneFactory.createPhone(&quot;Samsung&quot;) samsung?.hardware() } 在这个例子中，Phone 就充当了抽象产品角色，Apple 和 Samsung 都是具体产品，工厂提供了静态方法用于创建具体产品，用户只需要传入手机的品牌即可获取手机实例。 优缺点 优点：简单工厂模式提供专门的工厂类用于创建对象，实现了对象创建和使用的职责分离，客户端不需知道所创建的具体产品类的类名以及创建过程，只需要知道具体产品类所对应的参数即可。通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 缺点：不符合设计模式的开闭原则（对扩展开放，对修改关闭），每次添加新的产品就需要修改工厂类。在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展维护。 Factory Method 工厂方法模式 简介 工厂方法模式又被称为虚拟构造子模式（Virtual Constructor）或者多态工厂模式（Polymorphic Factory）。工厂方法模式是目标是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。 工厂方法模式包含如下角色： AbstractFactory：抽象工厂角色，与应用程序无关，主要在创建模式中规范和产品对应的工厂对象的标准化定义。 Factory：具体工厂角色，和用户直接交互的具体实现，用户创建产品对象。 AbstractProduct：抽象产品角色，是创建的所有对象的父类，负责描述所有实例的公共接口。 Product：具体产品角色，即创建目标，所有创建的对象都是该角色。 abstract class Phone { abstract fun hardware() } class Apple(val screen: String, val usb: String) : Phone() { override fun hardware() = println(&quot;[Apple] screen: $screen, usb: $usb&quot;) } class Samsung(val screen: String, val usb: String) : Phone() { override fun hardware() = println(&quot;[Samsung] screen: $screen, usb: $usb&quot;) } interface PhoneFactory { fun createPhone(): Phone } class AppleFactory : PhoneFactory { override fun createPhone(): Phone = Apple(&quot;LCD&quot;, &quot;Lightning&quot;) } class SamsungFactory : PhoneFactory { override fun createPhone(): Phone = Samsung(&quot;OLed&quot;, &quot;Type-C&quot;) } fun main() { val factory: PhoneFactory = AppleFactory() val phone: Phone = factory.createPhone() phone.hardware() } 工厂方法模式在简单工厂模式的基础上抽象了工厂类，即将具体的手机创建过程交给专门的工厂子类去完成。 工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 优缺点 优点：最直接的优点就是在满足开闭原则的基础上实现功能的扩展，核心工厂类不再负责所有产品的构建，而是将具体的工作交给工厂子类实现，需要增加新产品时，无须修改已有的抽象或具体的工厂或产品，只要添加一个具体工厂和具体产品就可以。 缺点：由于在添加新产品时需要编写新的产品类和工厂类，系统中类的个数将成对增加，在一定程度上增加了复杂度，有更多的类需要编译和运行，也会给系统带来一些额外开销。 Abstract Factory 抽象工厂模式 简介 抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。 为了更清晰地理解工厂方法模式，需要先引入两个概念： 产品等级结构：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、索尼电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。 抽象工厂模式包含如下角色： AbstractFactory：抽象工厂角色，与应用程序无关，主要在创建模式中规范和产品对应的工厂对象的标准化定义。 Factory：具体工厂角色，用于生产不同的产品族。 AbstractProduct：抽象产品角色，定义了产品的规范，描述了产品的共同主要特性和功能，抽象工厂模式有多个抽象产品。 Product：具体产品角色，由专门的具体工厂来创建，具体产品和具体工厂之间往往一一对应。 interface Tablet { fun play() } interface Earphone { fun play() } class iPad : Tablet { override fun play() = println(&quot;Apple iPad play game&quot;) } class Tab : Tablet { override fun play() = println(&quot;Samsung Tab play game&quot;) } class AirPods : Earphone { override fun play() = println(&quot;Apple AirPods play music&quot;) } class Buds : Earphone { override fun play() = println(&quot;Samsung Buds play music&quot;) } interface Factory { fun createTablet(): Tablet fun createEarphone(): Earphone } class AppleFactory : Factory { override fun createTablet(): Tablet = iPad() override fun createEarphone(): Earphone = AirPods() } class SamsungFactory : Factory { override fun createTablet(): Tablet = Tab() override fun createEarphone(): Earphone = Buds() } fun main() { val appleFactory: Factory = AppleFactory() appleFactory.createTablet().play() appleFactory.createEarphone().play() val samsungFactory: Factory = SamsungFactory() samsungFactory.createTablet().play() samsungFactory.createEarphone().play() } 这里定义了平板和耳机两类产品，各为一个产品等级结构，Apple 和 Samsung 都生产这两类产品，所以旗下的产品可视为产品族 抽象工厂可以通过多态，来动态设置不同的工厂，生产不同的产品，同时每个工厂中的产品又不属于同一个产品等级结构。 优缺点 优点：可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。增加新的具体工厂和产品族很方便，因为一个具体的工厂实现代表的是一个产品族，无须修改已有系统，符合开闭原则。 缺点：开闭原则的倾斜性。增加新的工厂和产品族容易，增加新的产品等级结构却比较麻烦，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。 ","link":"https://LiarrDev.github.io/post/Design-Pattern-Factory/"},{"title":"『MOJiKana』中模仿实体按键的动效是如何实现的？","content":"在『MOJiKana』中你可以看到我们大量使用了模仿实体按键的按压动效： 一开始这种动效仅在五十音列表中使用到，我们只需在 Adapter 中对子项进行处理即可，随着版本的迭代，该动效开始广泛应用到其他按钮设计中，如果针对每个按钮都做这种动效处理，项目中会存在大量的冗余代码，不易于维护，所以我考虑将其封装成一个组件，让每个需要用到的地方都尽可能简单地接入。 先来看看原理，如下图所示，我们只需要通过叠加两个图层，上面的图层采用较浅的颜色，下面的图层采用较深的颜色，并在上下两个图层的底部制造一个间距，即可在视觉上形成一个实体按键的效果。 当按钮被按下时，我们取消两个图层底部的间距，使底部的深色图层被覆盖隐藏，再给图层与父布局顶部添加同样的间距，就能够模仿出实体按键被按下的效果。 使用两个图层其实是 Android 的能力限制，像 ArkUI 中我们实际上只采用一个图层，然后通过调整底部边框的宽度来实现的，尽管如此，实现思路大体一致。 知道了原理，下面开始编码。 考虑到需要封装成通用组件，我们把几个重要的属性提取出来： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;declare-styleable name=&quot;KeyCapLayout&quot;&gt; &lt;attr name=&quot;keyCapFlatColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;keyCapShadowColor&quot; format=&quot;color&quot; /&gt; &lt;attr name=&quot;keyStroke&quot; format=&quot;dimension&quot; /&gt; &lt;attr name=&quot;keyCapRadius&quot; format=&quot;dimension&quot; /&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; 我把这个组件命名为 KeyCapLayout，因为它很像我们键盘中的键帽。keyCapFlatColor 表示的是按键表面的颜色，也就是原理中上面图层的颜色，keyCapShadowColor 表示的是按键的侧面阴影颜色，也就是原理中下面图层的颜色，keyStroke 表示的是按键的厚度，也可以理解为在机械键盘中我们常说的键程，keyCapRadius 表示的是按键的圆角半径，我这里没有区分上下两个图层的半径，而是采用同样的大小，读者可按需添加。 接下来封装组件： class KeyCapLayout @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyle: Int = 0 ) : FrameLayout(context, attrs, defStyle) { private val keyCapFlat: QMUIFrameLayout // 键盘顶部 private val keyCapShadow: QMUIFrameLayout // 键盘侧面 private val tagFlat = &quot;keyCapFlat&quot; private val tagShadow = &quot;keyCapShadow&quot; private var keystroke = 0 // 键程 init { val a = context.obtainStyledAttributes(attrs, R.styleable.KeyCapLayout) val flat = a.getColor(R.styleable.KeyCapLayout_keyCapFlatColor, Color.YELLOW) val shadow = a.getColor(R.styleable.KeyCapLayout_keyCapShadowColor, Color.GRAY) keystroke = a.getDimension(R.styleable.KeyCapLayout_keyStroke, 4.dp.toFloat()).toInt() val radius = a.getDimension(R.styleable.KeyCapLayout_keyCapRadius, 8.dp.toFloat()).toInt() a.recycle() keyCapFlat = QMUIFrameLayout(context).apply { layoutParams = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT) tag = tagFlat } keyCapShadow = QMUIFrameLayout(context).apply { layoutParams = LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT) tag = tagShadow } setKeyCapFlatColor(flat) setKeyCapShadowColor(shadow) setKeyCapRadius(radius) setKeyStroke(keystroke) addView(keyCapShadow) addView(keyCapFlat) } /** * 设置键帽颜色 */ fun setKeyCapFlatColor(@ColorInt color: Int) { keyCapFlat.setBackgroundColor(color) } /** * 设置竖面阴影色 */ fun setKeyCapShadowColor(@ColorInt color: Int) { keyCapShadow.setBackgroundColor(color) } /** * 设置圆角 */ fun setKeyCapRadius(radius: Int) { keyCapFlat.radius = radius keyCapShadow.radius = radius } /** * 设置键程 */ fun setKeyStroke(height: Int) { val lp = keyCapFlat.layoutParams as LayoutParams lp.setMargins(0, 0, 0, height) keyCapFlat.layoutParams = lp } /** * 处理按压 * @param press 是否按压 */ private fun handlePress(press: Boolean) { val lpFlat = keyCapFlat.layoutParams as LayoutParams val lpShadow = keyCapShadow.layoutParams as LayoutParams if (press) { lpFlat.setMargins(0, keystroke, 0, 0) lpShadow.setMargins(0, keystroke, 0, 0) } else { lpFlat.setMargins(0, 0, 0, keystroke) lpShadow.setMargins(0) } keyCapFlat.layoutParams = lpFlat } override fun onTouchEvent(event: MotionEvent?): Boolean { when (event?.action) { MotionEvent.ACTION_DOWN -&gt; { handlePress(true) } MotionEvent.ACTION_UP -&gt; { handlePress(false) performClick() } MotionEvent.ACTION_CANCEL -&gt; { handlePress(false) } } return true } override fun addView(child: View?) { if (child?.tag == tagFlat || child?.tag == tagShadow) { super.addView(child) } else { keyCapFlat.addView(child) } } override fun addView(child: View?, index: Int) { if (child?.tag == tagFlat || child?.tag == tagShadow) { super.addView(child, index) } else { keyCapFlat.addView(child, index) } } override fun addView(child: View?, params: ViewGroup.LayoutParams?) { if (child?.tag == tagFlat || child?.tag == tagShadow) { super.addView(child, params) } else { keyCapFlat.addView(child, params) } } override fun addView(child: View?, index: Int, params: ViewGroup.LayoutParams?) { if (child?.tag == tagFlat || child?.tag == tagShadow) { super.addView(child, index, params) } else { keyCapFlat.addView(child, index, params) } } override fun addView(child: View?, width: Int, height: Int) { if (child?.tag == tagFlat || child?.tag == tagShadow) { super.addView(child, width, height) } else { keyCapFlat.addView(child, width, height) } } } KeyCapLayout 继承自 FrameLayout，无论是简单的文字图片，或是复杂的自定义视图，都可以很方便地往里面添加。 原理中提到的上下两个图层，为了方便圆角的设置，我采用了 @Tencent/QMUI_Android 这个库的 QMUIFrameLayout 来作容器，你也可以采用其他的圆角方案。 写 XML 布局时，如果我们直接在 KeyCapLayout 中添加子视图，子视图默认会被插入到 KeyCapLayout 中，这样在处理按压效果时还需要额外处理子视图的上下偏移，如果我们能够将它插入到上图层中，它就仿佛印在按键表面一样，跟随图层上下偏移，所以我们重写 addView() 方法，将子视图添加到上图层中。 因为我们首先需要调用 addView() 把上下两个图层添加到 KeyCapLayout 中，所以为了避免递归死循环，我们给上下图层分别配置 Tag，addView() 时判断不是这两个上下图层则添加到上图层中。 按压效果就重写触摸事件 onTouchEvent() 处理，上面的原理已经介绍过了，不再重复。 调用时只需包裹在我们的内容上即可： &lt;com.example.banner.KeyCapLayout android:layout_width=&quot;120dp&quot; android:layout_height=&quot;56dp&quot; app:keyCapFlatColor=&quot;#595959&quot; app:keyCapRadius=&quot;56dp&quot; app:keyCapShadowColor=&quot;#404040&quot; app:keyStroke=&quot;6dp&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:textStyle=&quot;bold&quot; android:textColor=&quot;@color/white&quot; android:textSize=&quot;18sp&quot; android:text=&quot;Button&quot; /&gt; &lt;/com.example.banner.KeyCapLayout&gt; 点击事件也是直接调用 KeyCapLayout 的 setOnClickListener() 方法，我们在 onTouchEvent() 中处理了相关逻辑，当接收到 MotionEvent.ACTION_UP 事件时，会自动触发 onClick() 方法。 『MOJiKana』中同时也使用了 Jetpack Compose 技术，为了复用上面的代码，我不得不每次都使用 AndroidView 进行包裹，并在内部完成整个 KeyCapLayout 的创建、配置，还要创建它的子 View 再添加到其中。比如： @Preview @Composable private fun KeyCapLayoutPreview() { Box( modifier = Modifier .fillMaxSize() .background(color = Color.White), contentAlignment = Alignment.Center ) { AndroidView(factory = { context -&gt; KeyCapLayout(context).apply { layoutParams = ViewGroup.LayoutParams(SizeUtils.dp2px(120f), SizeUtils.dp2px(54f)) setKeyCapFlatColor(context.getColor(R.color.color_595959)) setKeyCapShadowColor(context.getColor(R.color.color_404040)) setKeyCapRadius(SizeUtils.dp2px(60f)) setKeyStroke(SizeUtils.dp2px(6f)) val imageView = ImageView(context).apply { layoutParams = ViewGroup.LayoutParams(SizeUtils.dp2px(24f), SizeUtils.dp2px(24f)) setImageResource(R.drawable.ic_common_complete) } addView( imageView, FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT, FrameLayout.LayoutParams.WRAP_CONTENT).apply { gravity = Gravity.CENTER } ) setOnClickListener { // do something... } } }) } } 随着项目中使用的场景逐渐增加，这种胶水代码也在慢慢膨胀。终于到了无法忍受之际，我又顺手搓了个 Compose 版本： @Composable fun KeyCap( modifier: Modifier = Modifier, keyFlatColor: Color = Color.Transparent, keyShadowColor: Color = Color.Transparent, keyStroke: Dp = 0.dp, keyCapRadius: Dp = 0.dp, content: @Composable BoxScope.() -&gt; Unit ) { var pressed by remember { mutableStateOf(false) } Box(modifier = modifier.pointerInput(pressed) { awaitPointerEventScope { if (pressed) { waitForUpOrCancellation() pressed = false } else { awaitFirstDown(false) pressed = true } } }) { Box( modifier = Modifier .padding(top = keyStroke) .fillMaxSize() .clip(RoundedCornerShape(size = keyCapRadius)) .background(keyShadowColor) ) Box( modifier = Modifier .padding( top = if (pressed) keyStroke else 0.dp, bottom = if (pressed) 0.dp else keyStroke ) .fillMaxSize() .clip(RoundedCornerShape(size = keyCapRadius)) .background(color = keyFlatColor), contentAlignment = Alignment.Center ) { content() } } } 属性依然是那几个属性，不再赘述。 触摸事件在 awaitPointerEventScope() 内处理，使用一个状态来标记按钮是否被按下。 得益于 Jetpack Compose 的声明式理念，无需再考虑上述原始 View 体系中 addView() 的问题，而是直接添加到对应的组件中即可。为了符合 Compose 的编写方式，可以直接参考其他组件的设计，在最后一个参数传入 @Composable 方法即可。 使用方式也很简单： @Preview @Composable fun KeyCapPreview() { val interactionSource = remember { MutableInteractionSource() } Box( modifier = Modifier .fillMaxSize() .background(color = Color.White), contentAlignment = Alignment.Center ) { KeyCap( keyFlatColor = colorResource(R.color.color_595959), keyShadowColor = colorResource(R.color.color_404040), keyStroke = 6.dp, keyCapRadius = 60.dp, modifier = Modifier .size(120.dp, 54.dp) .clickableWithoutRipple(interactionSource) { // 去除默认的点击效果 // do something... } ) { Text( text = stringResource(id = R.string.confirm), color = Color.White ) } } } 需要留意的是，Compose 默认情况下会给组件添加一个点击的 Ripple 效果，因为我们是通过组合视图来实现，并且还有圆角，所以这个默认的点击效果反而会影响体验，要把它去除。 去除点击效果的方法有很多种，Compose 官方也在后续的版本中做了更新，因为我目前使用的版本还比较低，所以我使用扩展方法来支持，其他实现方式可以自行搜索。 fun Modifier.clickableWithoutRipple( interactionSource: MutableInteractionSource, onClick: () -&gt; Unit ) = composed( factory = { this.then( Modifier.clickable( interactionSource = interactionSource, indication = null, onClick = { onClick() } ) ) } ) 最后浅浅吐槽一下，虽然这个设计挺有意思，但是我个人觉得其实违反了透视原理。 因为视觉上近大远小，所以按钮上的文字或图片按道理来说也应当被拉伸，左右两侧的延长线最终会在消失点相交。即使这个变换并不难实现，可是由于按钮的大小是动态配置的，导致变换的角度以及消失点就不太好确定，因此我们最终并没有实现这个效果。 ","link":"https://LiarrDev.github.io/post/MOJiKana-Physical-Button-Motion-Effect/"},{"title":"FastScroller & AlphabetIndexer 构建 Android 字母索引器","content":"之前我在『ArkUI AlphabetIndexer 真香』一文中提到，Android 平台也自带了一个 AlphabetIndexer，不少 Android 开发者都表示没见过这玩意儿。 Android 中的字母索引器的 UI 其实应该叫 FastScroller，即「快速滑动块」，而 AlphabetIndexer 这个类也确实存在，只不过它是作为辅助类来处理逻辑，FastScroller 才是处理滑块的显示。 因为使用起来不方便又或者是样式不符合国人使用习惯等原因，在国内的 App 中都不常见，我们可以先看看它的效果： 今天就来聊聊怎么实现，虽然日常基本不会使用，就当涨涨见识。 首先来看看布局，列表的子项就一个 TextView，没什么好说的。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/tv_contact&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;16dp&quot; android:textSize=&quot;16sp&quot; android:textStyle=&quot;bold&quot; /&gt; 页面则使用一个 ListView 来做展示。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.google.android.material.appbar.MaterialToolbar android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@android:color/holo_purple&quot; app:title=&quot;Contacts&quot; /&gt; &lt;ListView android:id=&quot;@+id/list_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fastScrollEnabled=&quot;true&quot; tools:listitem=&quot;@layout/item_contact&quot; /&gt; &lt;/LinearLayout&gt; 注意这里要配置 android:fastScrollEnabled 属性。 不使用 RecyclerView 的原因是它还需要配置其他属性，相对来说更加复杂，后续后机会再单独介绍。 接下来编写适配器： class ContactAdapter( context: Context, cursor: Cursor, data: List&lt;Map&lt;String, String&gt;&gt;, @LayoutRes resource: Int, from: Array&lt;String&gt;, @IdRes to: IntArray ) : SimpleAdapter(context, data, resource, from, to), SectionIndexer { private val indexer = AlphabetIndexer(cursor, 0, &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;) override fun getSections(): Array&lt;Any&gt; { return indexer.sections } override fun getPositionForSection(sectionIndex: Int): Int { return indexer.getPositionForSection(sectionIndex) } override fun getSectionForPosition(position: Int): Int { return indexer.getSectionForPosition(position) } } 前面的布局中可以看到样式十分简单，所以这里直接继承 SimpleAdapter，同时实现 SectionIndexer，这里十分关键。 构建 AlphabetIndexer，需要用到 Cursor，我们从上一层传入，并将 26 个字母作为索引。 AlphabetIndexer 本身也是 SectionIndexer 的子类，所以在我们实现的 SectionIndexer 的接口中调用 AlphabetIndexer 的对应方法返回。 提到 Cursor，我们最先想到可以直接查询本地通讯录的数据，它会给我们返回一个 Cursor 对象，就不用我们手动封装数据源了： class MainActivity : AppCompatActivity() { private val binding by lazy { ActivityMainBinding.inflate(layoutInflater) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(binding.root) val cursor = contentResolver.query( ContactsContract.Contacts.CONTENT_URI, arrayOf(ContactsContract.Contacts.DISPLAY_NAME_PRIMARY), null, null, ContactsContract.Contacts.DISPLAY_NAME_PRIMARY ) startManagingCursor(cursor) cursor?.let { val list = getData(it) val adapter = ContactAdapter( this, it, list, R.layout.item_contact, arrayOf(ContactsContract.Contacts.DISPLAY_NAME_PRIMARY), intArrayOf(R.id.tv_contact) ) binding.listView.adapter = adapter } } private fun getData(cursor: Cursor): List&lt;Map&lt;String, String&gt;&gt; { val list = mutableListOf&lt;Map&lt;String, String&gt;&gt;() if (cursor.moveToFirst()) { do { val column = cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME_PRIMARY) val name = cursor.getString(column) list.add(mapOf(ContactsContract.Contacts.DISPLAY_NAME_PRIMARY to name)) } while (cursor.moveToNext()) } return list } } Cursor 数据取出 ContactsContract.Contacts.DISPLAY_NAME_PRIMARY 这一列用于组装子项，再将 Cursor 传入刚刚的 ContactAdapter 中构建 AlphabetIndexer。 获取联系人还需要动态申请权限，这部分代码没有给出，自行处理即可。 有些朋友敲完之后可能会发现侧边的索引器出不来，其实不是代码的问题，只是数据量不够导致的，你可以配置 android:fastScrollAlwaysVisible 属性让它保持显示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout ...&gt; ... &lt;ListView ... android:fastScrollAlwaysVisible=&quot;true&quot; android:fastScrollEnabled=&quot;true&quot; /&gt; &lt;/LinearLayout&gt; 如果不配置该属性，默认情况下只有当内容大于 4 页时，ListView 才会显示索引器，我们可以在源码中得出这个结论。 ListView 的父类 AbsListView 的构造方法中有 android:fastScrollEnabled 这个属性的配置： public abstract class AbsListView extends AdapterView&lt;ListAdapter&gt; implements TextWatcher, ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener, ViewTreeObserver.OnTouchModeChangeListener, RemoteViewsAdapter.RemoteAdapterConnectionCallback { @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 123768941) private FastScroller mFastScroll; public AbsListView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { ... final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.AbsListView, defStyleAttr, defStyleRes); setFastScrollEnabled(a.getBoolean(R.styleable.AbsListView_fastScrollEnabled, false)); setFastScrollStyle(a.getResourceId(R.styleable.AbsListView_fastScrollStyle, 0)); setFastScrollAlwaysVisible(a.getBoolean(R.styleable.AbsListView_fastScrollAlwaysVisible, false)); ... } public void setFastScrollEnabled(final boolean enabled) { if (mFastScrollEnabled != enabled) { mFastScrollEnabled = enabled; if (isOwnerThread()) { setFastScrollerEnabledUiThread(enabled); } else { post(new Runnable() { @Override public void run() { setFastScrollerEnabledUiThread(enabled); } }); } } } private void setFastScrollerEnabledUiThread(boolean enabled) { if (mFastScroll != null) { mFastScroll.setEnabled(enabled); } else if (enabled) { mFastScroll = new FastScroller(this, mFastScrollStyle); mFastScroll.setEnabled(true); } resolvePadding(); if (mFastScroll != null) { mFastScroll.updateLayout(); } } } 可以看到 ListView 的快速滑动块是通过 FastScroller 类实现的，接下来看看 FastScroller 的创建流程： /** * Helper class for AbsListView to draw and control the Fast Scroll thumb */ class FastScroller { /** Minimum number of pages to justify showing a fast scroll thumb. */ private static final int MIN_PAGES = 4; /** * @return Whether the fast scroll thumb is enabled. */ public boolean isEnabled() { return mEnabled &amp;&amp; (mLongList || mAlwaysShow); } /** * Called when one of the variables affecting enabled state changes. * * @param peekIfEnabled whether the thumb should peek, if enabled */ private void onStateDependencyChanged(boolean peekIfEnabled) { if (isEnabled()) { if (isAlwaysShowEnabled()) { setState(STATE_VISIBLE); } else if (mState == STATE_VISIBLE) { postAutoHide(); } else if (peekIfEnabled) { setState(STATE_VISIBLE); postAutoHide(); } } else { stop(); } mList.resolvePadding(); } private void updateLongList(int childCount, int itemCount) { final boolean longList = childCount &gt; 0 &amp;&amp; itemCount / childCount &gt;= MIN_PAGES; if (mLongList != longList) { mLongList = longList; onStateDependencyChanged(false); } } ... } 不难理解，当开启 android:fastScrollEnabled 配置时，有两种条件可以显示快速滑动块，一是长列表，二是 android:fastScrollAlwaysVisible 也为 true，长列表的判断条件是数据量大于等于 MIN_PAGES，即 4 页。 以上就是 Android 字母索引的简单实现，关于自定义等其他用法就不展开介绍了，毕竟使用率不高，以后有机会再聊。 ","link":"https://LiarrDev.github.io/post/Android-FastScroller-AlphabetIndexer/"},{"title":"浅析 EPUB 结构","content":"什么是 EPUB EPUB（Electronic Publication）是一种电子图书标准，由国际数字出版论坛（IDPF）提出，属于一种可以“自动重新排版”的内容；也就是文字内容可以根据阅读设备的特性，以最适于阅读的方式显示。它的文件扩展名为 .epub。 EPUB 的组成 EPUB 文件内部使用了 XHTML 或 DTBook（一种由 DAISY Consortium 提出的 XML 标准）来展现文字，并以 ZIP 压缩格式来打包文件内容。因此我们可以通过解压缩的方式来了解 EPUB 的构成。 下面这个是我从某电子书网站下载的两个 EPUB 文件解压图： EPUB 的标准和规范一直在迭代，目录也有所差异，但文件组成是大同小异的，下面将逐一介绍各文件的作用。 MIMETYPE 它的文件名就是 mimetype，无文件扩展名，用于描述 EPUB 的 MIME，所以它的内容只有一行： application/epub+zip META-INF 用于存放特定文件，默认情况下里面只有一个 container.xml 文件，用于描述 OPF 的存放位置。由于 EPUB 的制作差异，META-INF 文件夹还可能包含数字签名和加密信息等文件，Java 开发者对这个目录应该不陌生。 container.xml 文件如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;container version=&quot;1.0&quot; xmlns=&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;&gt; &lt;rootfiles&gt; &lt;rootfile full-path=&quot;content.opf&quot; media-type=&quot;application/oebps-package+xml&quot;/&gt; &lt;/rootfiles&gt; &lt;/container&gt; 该文件是必定存在的，它相当于是 EPUB 系统的指路牌。 OPF OPF 文件是 EPUB 规范中最复杂的元数据，它用来定义 OPS 一系列内容组合到一起的机制。 常用的文件名是 content.opf，当然也可以是其他，但文件扩展名必须是 .opf，它内部其实是一个标准的 XML，下面是一个例子。 &lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;package xmlns=&quot;http://www.idpf.org/2007/opf&quot; version=&quot;2.0&quot; unique-identifier=&quot;uuid_id&quot;&gt; &lt;metadata xmlns:opf=&quot;http://www.idpf.org/2007/opf&quot; xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;&gt; &lt;dc:title&gt;不连续杀人事件&lt;/dc:title&gt; &lt;dc:creator&gt;坂口安吾&lt;/dc:creator&gt; &lt;dc:description&gt;不连续杀人事件&lt;/dc:description&gt; &lt;dc:language&gt;zh-cn&lt;/dc:language&gt; &lt;dc:date&gt;&lt;/dc:date&gt; &lt;dc:contributor&gt;COAY.COM [http://www.coay.com]&lt;/dc:contributor&gt; &lt;dc:publisher&gt;COAY.COM&lt;/dc:publisher&gt; &lt;dc:identifier id=&quot;uuid_id&quot; opf:scheme=&quot;uuid&quot;&gt;8337&lt;/dc:identifier&gt; &lt;dc:subject&gt;不连续杀人事件&lt;/dc:subject&gt; &lt;/metadata&gt; &lt;manifest&gt; &lt;item href=&quot;article_381876.html&quot; id=&quot;id381876&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;article_381877.html&quot; id=&quot;id381877&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;article_381878.html&quot; id=&quot;id381878&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;article_381879.html&quot; id=&quot;id381879&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;article_381880.html&quot; id=&quot;id381880&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;article_381881.html&quot; id=&quot;id381881&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;article_381882.html&quot; id=&quot;id381882&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;article_381883.html&quot; id=&quot;id381883&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;article_381884.html&quot; id=&quot;id381884&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;article_381885.html&quot; id=&quot;id381885&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;article_381886.html&quot; id=&quot;id381886&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;article_381887.html&quot; id=&quot;id381887&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;catalog.html&quot; id=&quot;catalog&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;cover.jpg&quot; id=&quot;cover&quot; media-type=&quot;image/jpeg&quot;/&gt; &lt;item href=&quot;coay.jpg&quot; id=&quot;ad&quot; media-type=&quot;image/jpeg&quot;/&gt; &lt;item href=&quot;stylesheet.css&quot; id=&quot;css&quot; media-type=&quot;text/css&quot;/&gt; &lt;item href=&quot;titlepage.xhtml&quot; id=&quot;titlepage&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;page.xhtml&quot; id=&quot;page&quot; media-type=&quot;application/xhtml+xml&quot;/&gt; &lt;item href=&quot;toc.ncx&quot; media-type=&quot;application/x-dtbncx+xml&quot; id=&quot;ncx&quot;/&gt; &lt;/manifest&gt; &lt;spine toc=&quot;ncx&quot;&gt; &lt;itemref idref=&quot;titlepage&quot;/&gt; &lt;itemref idref=&quot;page&quot;/&gt; &lt;itemref idref=&quot;catalog&quot;/&gt; &lt;itemref idref=&quot;id381876&quot;/&gt; &lt;itemref idref=&quot;id381877&quot;/&gt; &lt;itemref idref=&quot;id381878&quot;/&gt; &lt;itemref idref=&quot;id381879&quot;/&gt; &lt;itemref idref=&quot;id381880&quot;/&gt; &lt;itemref idref=&quot;id381881&quot;/&gt; &lt;itemref idref=&quot;id381882&quot;/&gt; &lt;itemref idref=&quot;id381883&quot;/&gt; &lt;itemref idref=&quot;id381884&quot;/&gt; &lt;itemref idref=&quot;id381885&quot;/&gt; &lt;itemref idref=&quot;id381886&quot;/&gt; &lt;itemref idref=&quot;id381887&quot;/&gt; &lt;itemref idref=&quot;page&quot;/&gt; &lt;/spine&gt; &lt;guide&gt; &lt;reference href=&quot;titlepage.xhtml&quot; type=&quot;cover&quot; title=&quot;封面&quot;/&gt; &lt;reference href=&quot;catalog.html&quot; type=&quot;toc&quot; title=&quot;目录&quot;/&gt; &lt;/guide&gt; &lt;/package&gt; 它由四个部分组成： &lt;metadata&gt;：元数据信息。包含书名、作者、出版社等信息，其中 &lt;dc:title&gt; 和 &lt;dc:identifier&gt; 这两个数据是必须的。按照 EPUB 规范，&lt;dc:identifier&gt; 由数字图书的创建者定义，必须唯一，对于图书出版商来说，这个字段一般包括 ISBN 或者 Library of Congress 编号。 &lt;manifest&gt;：文件列表。列出电子书中包含的资源文件（HTML、CSS、NCX、图片等），它的每一子项都包含了文件 ID、相对路径以及媒体类型。 &lt;spine&gt;：文档线性阅读顺序。其中 toc 属性指向 &lt;manifest&gt; 中 .ncx 文件的 id，子项的 idref 属性同样指向 &lt;manifest&gt; 中的文件 id。 &lt;guide&gt;：电子书指引页。比如封面、目录、序言等，通过 href 属性指向文件路径。 NCX NCX 定义了数字图书的目录表，复杂的图书中，目录表通常采用层次结构，包括嵌套的内容、章节等。 它的文件名通常是 toc.ncx，是一个逻辑目录，内部也是一个标准的 XML，下面是一个例子。 &lt;?xml version='1.0' encoding='utf-8'?&gt; &lt;ncx xmlns=&quot;http://www.daisy.org/z3986/2005/ncx/&quot; version=&quot;2005-1&quot;&gt; &lt;head&gt; &lt;meta name=&quot;dtb:uid&quot; content=&quot;coay_8337&quot;/&gt; &lt;meta name=&quot;dtb:depth&quot; content=&quot;2&quot;/&gt; &lt;meta name=&quot;dtb:generator&quot; content=&quot;COAY.COM [http://www.coay.com]&quot;/&gt; &lt;meta name=&quot;dtb:totalPageCount&quot; content=&quot;0&quot;/&gt; &lt;meta name=&quot;dtb:maxPageNumber&quot; content=&quot;0&quot;/&gt; &lt;/head&gt; &lt;docTitle&gt;&lt;text&gt;不连续杀人事件&lt;/text&gt;&lt;/docTitle&gt; &lt;docAuthor&gt;&lt;text&gt;坂口安吾&lt;/text&gt;&lt;/docAuthor&gt; &lt;navMap&gt; &lt;navPoint class=&quot;chapter&quot; id=&quot;article_381876&quot; playOrder=&quot;1&quot;&gt; &lt;navLabel&gt;&lt;text&gt;第一章 丑恶万分的人际关系（1）&lt;/text&gt;&lt;/navLabel&gt; &lt;content src=&quot;article_381876.html&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint class=&quot;chapter&quot; id=&quot;article_381877&quot; playOrder=&quot;2&quot;&gt; &lt;navLabel&gt;&lt;text&gt;第一章 丑恶万分的人际关系（2）&lt;/text&gt;&lt;/navLabel&gt; &lt;content src=&quot;article_381877.html&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint class=&quot;chapter&quot; id=&quot;article_381878&quot; playOrder=&quot;3&quot;&gt; &lt;navLabel&gt;&lt;text&gt;第二章 意外的访客&lt;/text&gt;&lt;/navLabel&gt; &lt;content src=&quot;article_381878.html&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint class=&quot;chapter&quot; id=&quot;article_381879&quot; playOrder=&quot;4&quot;&gt; &lt;navLabel&gt;&lt;text&gt;第三章 不速之客&lt;/text&gt;&lt;/navLabel&gt; &lt;content src=&quot;article_381879.html&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint class=&quot;chapter&quot; id=&quot;article_381880&quot; playOrder=&quot;5&quot;&gt; &lt;navLabel&gt;&lt;text&gt;第四章 第一位被害者&lt;/text&gt;&lt;/navLabel&gt; &lt;content src=&quot;article_381880.html&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint class=&quot;chapter&quot; id=&quot;article_381881&quot; playOrder=&quot;6&quot;&gt; &lt;navLabel&gt;&lt;text&gt;第五章 猫 铃（1）&lt;/text&gt;&lt;/navLabel&gt; &lt;content src=&quot;article_381881.html&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint class=&quot;chapter&quot; id=&quot;article_381882&quot; playOrder=&quot;7&quot;&gt; &lt;navLabel&gt;&lt;text&gt;第五章 猫 铃（2）&lt;/text&gt;&lt;/navLabel&gt; &lt;content src=&quot;article_381882.html&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint class=&quot;chapter&quot; id=&quot;article_381883&quot; playOrder=&quot;8&quot;&gt; &lt;navLabel&gt;&lt;text&gt;第六章 第二桩案件&lt;/text&gt;&lt;/navLabel&gt; &lt;content src=&quot;article_381883.html&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint class=&quot;chapter&quot; id=&quot;article_381884&quot; playOrder=&quot;9&quot;&gt; &lt;navLabel&gt;&lt;text&gt;第七章 身为侦探小说迷的老政客&lt;/text&gt;&lt;/navLabel&gt; &lt;content src=&quot;article_381884.html&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint class=&quot;chapter&quot; id=&quot;article_381885&quot; playOrder=&quot;10&quot;&gt; &lt;navLabel&gt;&lt;text&gt;第八章 唯一的不在场证明&lt;/text&gt;&lt;/navLabel&gt; &lt;content src=&quot;article_381885.html&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint class=&quot;chapter&quot; id=&quot;article_381886&quot; playOrder=&quot;11&quot;&gt; &lt;navLabel&gt;&lt;text&gt;第九章 火葬归途&lt;/text&gt;&lt;/navLabel&gt; &lt;content src=&quot;article_381886.html&quot;/&gt; &lt;/navPoint&gt; &lt;navPoint class=&quot;chapter&quot; id=&quot;article_381887&quot; playOrder=&quot;12&quot;&gt; &lt;navLabel&gt;&lt;text&gt;第十章 疯子大集合&lt;/text&gt;&lt;/navLabel&gt; &lt;content src=&quot;article_381887.html&quot;/&gt; &lt;/navPoint&gt; &lt;/navMap&gt; &lt;/ncx&gt; 它有如下几个部分组成： &lt;head&gt;：该标签内主要包含四个 &lt;meta&gt; 元素： dtb:uid：数字图书唯一 ID。一般和 OPF 中的 &lt;dc:identifier&gt; 对应。 dtb:depth：反映目录表中的层次深度。 dtb:totalPageCount：仅用于纸质图书，保留 0 即可。 dtb:maxPageNumber：仅用于纸质图书，保留 0 即可。 &lt;docTitle&gt;：图书标题。一般和 OPF 中的 &lt;dc:title&gt; 对应。 &lt;docAuthor&gt;：图书作者。一般和 OPF 中的 &lt;dc:creator&gt; 对应。 &lt;navMap&gt;：图书目录。包含多个 &lt;navPoint&gt;，内部又包含下列元素： playOrder：文档阅读顺序。和 OPF 中 &lt;spine&gt; 的子项顺序相同。 &lt;navLabel&gt;：章节标题。 &lt;content&gt;：指向文件路径。和 OPF 中 &lt;manifest&gt; 子项配置的路径一致。 资源文件 除了上面介绍的几个重要文件外，剩下的几乎都是资源文件。包括 HTML/XHTML、CSS、JPG、PNG、SVG 等等。HTML/XHTML 则是书籍的内容，里面会引用 CSS 和图片等。 这些文件没有明确的路径要求（事实上除了 mimetype 和 container.xml 两个文件有明确的要求外，其他文件都没有明确的路径要求），这也是为什么文章开头的两个 EPUB 目录会相差这么大。 OPF &lt;spine&gt; 和 NCX &lt;navMap&gt; 的区别 两个文件都描述了文档的顺序和内容，这很容易混淆。 OPF &lt;spine&gt; 描述了书中各个章节是如何实际连接起来的，比方说翻过第一章最后一页就到第二章第一页。 NCX &lt;navMap&gt; 在图书一开始描述目录。目录肯定会包含书中主要的章节，但是还可能包含没有单独分页的小节。 NCX 包含的 &lt;navPoint&gt; 元素通常比 OPF &lt;spine&gt; 中的 itemref 元素多。一般情况下，&lt;spine&gt; 中的所有项都会出现在 NCX 中，但 NCX 可能更详细。 开发 基于以上知识，你完全可以自行构建一本 EPUB 电子书了。所以在此我不打算介绍 EPUB 的制作流程。 简单说一下 EPUB 阅读器的制作。 由上面的介绍得知，EPUB 内容是依靠 HTML/XHTML 渲染的，以 Android 为例，我们就可以借助 WebView 加载。 首先需要解压 EPUB 文件，取出 META-INF 中的 container.xml 文件，解析获取 OPF 文件路径，再取出 OPF 文件进行解析，获取元数据、资源、阅读顺序等信息，最后将 HTML/XHTML 按顺序交给 WebView 加载。 因为上面介绍的配置文件基本都是 XML，你可以借助之前介绍的 Dom4J 完成解析。 如果需要交互功能，可以向 WebView 中注入 JavaScript 来完成。 ","link":"https://LiarrDev.github.io/post/EPUB-Structure/"},{"title":"ArkUI AlphabetIndexer 真香","content":"最近在为公司开发 HarmonyOS NEXT 的应用，对 HarmonyOS NEXT 有所了解的朋友应该知道，它与当前市面上所搭载的 HarmonyOS 系统的手机不同，现在市面上的 HarmonyOS 仍基于 Android 平台，应用也大多数是基于 Java/Kotlin 开发，而即将发布的 HarmonyOS NEXT 版本，将不再兼容原有的 Android 应用，而是使用一套基于 ArkTS 的开发框架 ArkUI。 在开发期间我也深深地感受到，与同为声明式 UI 框架的 Jetpack Compose 相比，ArkUI 仍旧十分难用，一部分是 ArkTS 这个语言与 Kotlin 的差距，一部分是 ArkUI 设计者在开发时考虑的场景欠缺，一部分是代码编辑器 DevEco Studio 功能不完善，当然还有一部分是我对 ArkUI/ArkTS 的不熟悉。 尽管每天开发时都在口吐莲花，但我不得不说，ArkUI 确实有一个组件我得吹爆它，就是 AlphabetIndexer，翻译过来叫字母索引器，夸它的原因也很简单，虽然 Android 中也有 AlphabetIndexer，可是它仅提供了一些基础接口，具体逻辑还需要自己实现，虽然扩展性高，不过对于相同的效果，我们往往会选择自己手搓或者使用三方库。 对于不知道 AlphabetIndexer 是什么的朋友，我先上个效果图： 右边的可以点击滑动的就是 AlphabetIndexer，当列表数据非常多时，它能够快速帮我们定位到需要寻找的数据附近，在通讯录中也很常见。 废话了这么久，开整。 首先定义好我们的数据类，数据有两种格式，一种是分类标题字母 RegionAlphabet，只需包含一个 string 类型的字段；一种是数据详情 RegionDetail，需要包含一个 string 类型的名称和一个 number 类型的区码。 export class RegionAlphabet { alphabet: string = &quot;&quot;; constructor(alphabet: string) { this.alphabet = alphabet } } export class RegionDetail { region: string = &quot;&quot;; code: number = 0; } export type BaseRegion = RegionAlphabet | RegionDetail 另外还定义了一个 BaseRegion 类型关联这两种数据类，方便我们后面的数据处理。 export class RegionViewModel { static alphabets: string[] = [ &quot;热&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot; ] static hotRegions: RegionDetail[] = [ { &quot;region&quot;: &quot;中国大陆&quot;, &quot;code&quot;: 86 }, { &quot;region&quot;: &quot;中国香港&quot;, &quot;code&quot;: 852 }, { &quot;region&quot;: &quot;中国澳门&quot;, &quot;code&quot;: 853 }, { &quot;region&quot;: &quot;中国台湾&quot;, &quot;code&quot;: 886 }, { &quot;region&quot;: &quot;美国&quot;, &quot;code&quot;: 1 }, { &quot;region&quot;: &quot;日本&quot;, &quot;code&quot;: 81 } ] private static regions: RegionDetail[] = [ { &quot;region&quot;: &quot;阿富汗&quot;, &quot;code&quot;: 93 }, { &quot;region&quot;: &quot;阿尔巴尼亚&quot;, &quot;code&quot;: 355 }, { &quot;region&quot;: &quot;阿尔及利亚&quot;, &quot;code&quot;: 213 }, { &quot;region&quot;: &quot;美属萨摩亚&quot;, &quot;code&quot;: 1684 }, { &quot;region&quot;: &quot;安道尔&quot;, &quot;code&quot;: 376 }, { &quot;region&quot;: &quot;安哥拉&quot;, &quot;code&quot;: 244 }, ... } 这里有 3 个数据源，首先是我们 AlphabetIndexer 用到的字母索引列表，除了常规的 26 个字母，我们还会在前面放置常用的标签，减少用户的操作步骤。第二个数据源就是常用的数据，第三个类型是总数据，这部分数据太多，我只截取小部分数据示例，读者知道是这种格式即可。 我们还需要将数据源统一成一个数组暴露出去，处理一下数据： export class RegionViewModel { ... static getRegions(): BaseRegion[] { let groupBy = RegionViewModel.regions.sort((a, b) =&gt; { let pinyinA: string = pinyin4js.convertToPinyinString(a.region, '', pinyin4js.WITHOUT_TONE) let pinyinB: string = pinyin4js.convertToPinyinString(b.region, '', pinyin4js.WITHOUT_TONE) if (pinyinA &lt; pinyinB) { return -1 } else if (pinyinA &gt; pinyinB) { return 1 } else { return 0 } }).reduce((acc, curr) =&gt; { let firstLetter: string = pinyin4js.convertToPinyinString(curr.region, '', pinyin4js.WITHOUT_TONE) .charAt(0) .toUpperCase(); (acc[firstLetter] ??= []).push(curr); return acc; }, {} as Record&lt;string, RegionDetail[]&gt;) let list: BaseRegion[] = [] list.push(new RegionAlphabet(&quot;热门&quot;)) list.push(...RegionViewModel.hotRegions) Object.keys(groupBy).forEach(key =&gt; { list.push(new RegionAlphabet(key)) list.push(...groupBy[key]) }) return list } } 这里使用了一个官方库 @ohos/pinyin4js，用来将汉字转为拼音，需要先提前安装： ➜ ohpm install @ohos/pinyin4js 上面的代码虽然有点长，但做的事情不多。首先是将数组内的 RegionDetail 元素按照 region 属性转为拼音的顺序进行排序，然后按照其拼音首字母进行分组，这样就可以与我们定义的拼音索引对应，最后再按组顺序插入到列表中，返回结果。 需要注意一个坑的地方，由于 ArkTS 的语言特性，RegionDetail 数据是通过对象转换而来的，而不是 new 出来的实例，所以实际插入到数组中是一个 Object，而不是 RegionDetail，在后面使用时需要留意。 数据准备完毕，开始写界面。 @Entry @Component struct RegionPage { @State private selectedIndex: number = 0 @State private regions: BaseRegion[] = RegionViewModel.getRegions() private scroller: Scroller = new Scroller() build() { Column() { Toolbar({ title: 'Region' }) Stack({ alignContent: Alignment.End }) { List({ scroller: this.scroller }) { ForEach(this.regions, (item: BaseRegion) =&gt; { ListItem() { if (item instanceof RegionAlphabet) { Text(item.alphabet).fontColor(Color.Gray).fontSize(12).height(32) } else { Row() { Text((item as RegionDetail).region).fontWeight(FontWeight.Bold).fontSize(16).layoutWeight(1) Text(`+${(item as RegionDetail).code}`).fontSize(16).fontColor(Color.Gray) } .height($r('sys.float.titlebar_default_height')) .alignItems(VerticalAlign.Center) .onClick(() =&gt; router.back({ url: Routers.LOGIN_PAGE, params: { regionCode: (item as RegionDetail).code } })) } }.padding({ left: 24, right: 44 }) }) }.onScrollIndex(index =&gt; { let item = this.regions[index] if (item instanceof RegionAlphabet) { this.selectedIndex = RegionViewModel.alphabets.indexOf(item.alphabet) } else { if (index &lt; RegionViewModel.hotRegions.length + 1) { this.selectedIndex = 0 return } let region = (item as RegionDetail).region let alphabet: string = pinyin4js.convertToPinyinString(region, '', pinyin4js.WITHOUT_TONE) .charAt(0) .toUpperCase() this.selectedIndex = RegionViewModel.alphabets.indexOf(alphabet) } }) AlphabetIndexer({ arrayValue: RegionViewModel.alphabets, selected: 0 }) .selected(this.selectedIndex) .height('100%') .onSelect(index =&gt; { if (index == 0) { this.scroller.scrollToIndex(0) return } let letter = RegionViewModel.alphabets[index] let position = this.regions.findIndex(value =&gt; (value as RegionAlphabet).alphabet == letter) if (position &gt; 0) { this.scroller.scrollToIndex(position) } }) } } .height('100%') .width('100%') } } 界面的布局就不展开介绍了，需要关注一点是列表数据项的判断，上文提到，RegionDetail 在数组内仅仅是一个 Object，所以不能像 RegionAlphabet 那样通过 instanceof 来判断，只能筛选完 RegionAlphabet 之后再通过 as 来强转，你也可以使用其他写法来规避这个问题。 重点看下关联逻辑。 List 中需要传入一个 Scroller，后续在 AlphabetIndexer 中可以用来控制滚动，同时 List 在滚动时也需要通知 AlphabetIndexer 刷新状态，所以需要一个变量 selectedIndex 来记录选中的索引。 当 List 滚动时会通过 onScrollIndex() 回调监听。如果当前可见的第一个列表项数据是 RegionAlphabet 时，AlphabetIndexer 选中的就是 RegionAlphabet 对应在索引数据源的下标；如果当前可见的第一个列表项数据不是 RegionAlphabet，判断该项在数组中的位置是否小于 hotRegions 的长度加 1（加 1 是因为需要加上第一个 RegionAlphabet），是的话直接将 AlphabetIndexer 选中的下标置 0，如果不是的话，将数据项强转为 RegionDetail，取出其 region 字段的拼音首字母，选中该字母在索引数据源的下标即可。 使用 AlphabetIndexer 选中时会通过 onSelect()回调监听。当选中下标为 0 的项时，直接将 List 滚到顶部；否则获取选中的字母，滚动到对应的 RegionAlphabet 所在的位置。 整个流程就是这么简单，虽然 AlphabetIndexer 在项目中的使用率不高，但这个组件的出现确实方便了我们开发，样式也符合我们的常见场景，Android 开发者实名羡慕。 ","link":"https://LiarrDev.github.io/post/Wonderful-ArkUI-AlphabetIndexer/"},{"title":"TabLayout & ViewPager2 快速打造选项卡切换效果","content":"大家使用一些常见的 App 时都能发现 Tab 卡片切换效果，比如『AppGallery』『Mi Home』等： 这种交互将下方卡片和顶部 Tab 进行联动，用户可以通过左右滑动卡片，或者点击 Tab 切换卡片，特别适合将同一模组不同内容的页面合并展示。 得益于 Android 官方的良好封装，我们要实现这种方式也非常简单。 先来看布局： &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.google.android.material.tabs.TabLayout android:id=&quot;@+id/tab_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;androidx.viewpager2.widget.ViewPager2 android:id=&quot;@+id/view_pager&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/LinearLayout&gt; 拆开两部分来看，顶部必然是使用 TabLayout 组件，下面则使用 ViewPager2 来实现。 既然有 ViewPager2，那之前肯定有 ViewPager，老版本的 ViewPager 是继承自 ViewGroup 自定义实现的，而 ViewPager2 虽然也继承自 ViewGroup，但却是基于 RecyclerView 封装的，解决了 ViewPager 的大部分痛点，大多数情况下我们优先选择 ViewPager2 来实现我们的需求。 TabLayout 和 ViewPager2 都有自己的切换逻辑，那么我们需要做的，就是将它们关联起来，实现联动的效果。 class MainActivity : AppCompatActivity() { private val binding by lazy { ActivityMainBinding.inflate(layoutInflater) } override fun onCreate(savedInstanceState: Bundle?) { ... binding.viewPager.adapter = object : FragmentStateAdapter(this) { override fun getItemCount() = 2 override fun createFragment(position: Int) = when (position) { 0 -&gt; Fragment0() else -&gt; Fragment1() } } TabLayoutMediator(binding.tabLayout, binding.viewPager) { tab, position -&gt; when (position) { 0 -&gt; tab.text = &quot;Tab 0&quot; else -&gt; tab.text = &quot;Tab 1&quot; } }.attach() } } 给 ViewPager2 设置一个 adapter，并实现 FragmentStateAdapter 接口，重写 getItemCount() 和 createFragment() 方法，分别返回 ViewPager2 的页面数量和对应位置的 Fragment。这部分属于 ViewPager2 的知识，这里不再赘述。 接下来，我们创建一个 TabLayoutMediator 对象，并调用它的 attach() 方法，将 TabLayout 和 ViewPager2 关联起来。同时还可以根据需要，对 TabLayout.Tab 做一些自定义的处理操作。 这样，我们就实现了 TabLayout 和 ViewPager2 联动。效果如下： ","link":"https://LiarrDev.github.io/post/Tab-Switching-Effects-by-TabLayout-and-ViewPager2/"},{"title":"Reqable","content":"之前介绍了如何使用『Fiddler Everywhere』在手机上进行抓包，它需要使手机与电脑连接同一个局域网完成抓包操作，我相信许多开发小伙伴都遇到过下班回家路上突然收到消息说出现 Bug 的情况，在地铁上的你是否焦头烂额又无能为力？ 要是有一款能直接在手机上进行抓包的工具那该多好！ 不慌！它来了！ 『Reqable』是一款先进的 API 生产力工具，支持全平台（Windows、macOS、Linux、Android、iOS）、免登录、轻量级、高性能、无广告，官方宣称它是 Fiddler + Charles + Postman 的结合。 它的作者是 Megatron King，他同时也是『HttpCanary』的作者，用过『HttpCanary』的朋友应该可以从应用图标看出，其正是『Reqable』的前身。 先来看看在手机上的抓包操作。 打开『Reqable』并点击右下角按钮启动调试，然后将其退到后台即可，『Reqable』会启动一个画中画窗口用于展示，设备上所有的网络请求都会在其中展示。 操作完成后，回到『Reqable』，列表会展示所有请求，可以通过搜索、筛选、排序等操作找到自己想要的请求。 点击查看完整的请求和响应。 是不是十分简单？如果希望在电脑上查看手机的请求，也不需要繁琐的 Wi-Fi 代理配置，直接扫一扫就可以连接。 连接成功后就可以在电脑上查看手机的请求。 点击查看请求和响应也是常规操作。 当然，如果你不想在手机上下载『Reqable』，仅仅希望通过传统的局域网 Wi-Fi 代理连接来抓包，也是完全没问题的，只需在电脑上安装『Reqable』即可，步骤和之前介绍的使用『Fiddler Everywhere』抓包方法大同小异，这里就不展开描述了。 上面介绍的抓包只是『Fiddler』和『Charles』具备的功能，那么『Postman』具备的功能在哪里呢？ 只需新建一个标签，即可进行 API 调试。 同时它还支持自定义重写和断点规则，或者编写 Python 脚本，拦截处理请求或者响应数据，修改或者模拟数据，满足各式各样的测试场景。 除此之外，『Reqable』还提供了大量的内置开发工具，在此就不一一介绍了。 总的来说，『Reqable』是一款比较全面的国产抓包工具，功能相对完善，比较适合国人的操作习惯，简单便捷，抓包性能也比较高，基于 Flutter 开发，支持 HTTP3/QUIC，全平台客户端，一系列的特点都是优秀的证明，值得一试。 ","link":"https://LiarrDev.github.io/post/Reqable/"},{"title":"解决 Tomcat 10 Servlet 无法访问的问题","content":"之前在 IntelliJ IDEA Community Edition 配置好了 Tomcat，接下来就要开始写接口了，Spring 的框架暂时还没用上，先简单写个 Servlet。 import javax.servlet.annotation.WebServlet import javax.servlet.http.HttpServlet import javax.servlet.http.HttpServletRequest import javax.servlet.http.HttpServletResponse @WebServlet(&quot;/hello&quot;) class HelloServlet: HttpServlet() { override fun doGet(req: HttpServletRequest?, resp: HttpServletResponse?) { println(&quot;HelloServlet doGet&quot;) resp?.writer?.write(&quot;Hello Servlet&quot;) } } 部署上去发现，根页面可以正常访问，但是却无法访问 Servlet。 其实这个问题的答案早已写在 Apache Tomcat 官网 Tomcat 10 的下载页，只不过大多数人在下载的时候都没有注意到： Users of Tomcat 10 onwards should be aware that, as a result of the move from Java EE to Jakarta EE as part of the transfer of Java EE to the Eclipse Foundation, the primary package for all implemented APIs has changed from javax.* to jakarta.*. This will almost certainly require code changes to enable applications to migrate from Tomcat 9 and earlier to Tomcat 10 and later. Tomcat 10 及以后版本的用户应注意，作为 Java EE 向 Eclipse 基金会转移的一部分，Java EE 已从 Java EE 迁移到 Jakarta EE，因此所有已实施 API 的主包已从 javax.* 变为 jakarta.*。这几乎肯定需要修改代码，以使应用程序能从 Tomcat 9 及更早版本迁移到 Tomcat 10 及更高版本。 Java Servlet API 是由 Sun Microsystems / Oracle 开发和维护的，其包名以 javax.servlet 开头。从 Java EE 8 开始，Servlet API 的维护权转交给了 Eclipse Foundation 的 Jakarta EE 社区，因此，在最新的 Jakarta EE 版本中，Servlet API 的包名已经更改为 jakarta.servlet。 也就是说 javax.servlet 是旧版本的包名，而 jakarta.servlet 是新版本的包名。这个变化是为了反映 Jakarta EE 作为一个独立的开源项目，并且将标准 Java 技术规范的发展移交给了 Jakarta EE 社区。 我们只需在项目中替换对应的依赖及包名即可： dependencies { // implementation(&quot;javax.servlet:javax.servlet-api:4.0.1&quot;) implementation(&quot;jakarta.servlet:jakarta.servlet-api:6.0.0&quot;) } // 修改包名 import jakarta.servlet.annotation.WebServlet import jakarta.servlet.http.HttpServlet import jakarta.servlet.http.HttpServletRequest import jakarta.servlet.http.HttpServletResponse @WebServlet(&quot;/hello&quot;) class HelloServlet: HttpServlet() { override fun doGet(req: HttpServletRequest?, resp: HttpServletResponse?) { println(&quot;HelloServlet doGet&quot;) resp?.writer?.write(&quot;Hello Servlet&quot;) } } 重新部署，访问成功： 写这篇文章的时候发现网上很多博主遇到该问题的时候都采用了降级到 Tomcat 9 的方式来避免该问题的发生，这实际上是一种惰性思维，因为他们并没有解决问题而是逃避问题。 我理解许多程序员因为开发任务繁重而不得不选择一种能尽快让项目运行起来的方法，但一定不要养成放弃思考的习惯。 ","link":"https://LiarrDev.github.io/post/Fix-Tomcat-10-Servlet-Inaccessibility-Problems/"},{"title":"macOS 平台 IntelliJ IDEA 社区版 Tomcat 配置笔记","content":"前言 以前读书的时候浅浅接触过 Java Web 开发，因为水土不服，所以后来走上了 Android 开发这条路。最近突然兴起，想再次了解了解后端开发，今天迈出第一步，搭建开发环境。 想起彼时，JetBrains 的开发套件在国内似乎还未流行起来，大多数人仍在使用 Eclipse 开发，环境的配置也比较繁琐。现在只需下载 IntelliJ IDEA Ultimate，几乎不需要什么配置，开箱即用。 但是众所周知，IntelliJ IDEA Ultimate 需要付费使用，我作为学习需要，还不值得花这笔钱，而网上各种破解都由于版本的迭代变得愈发不稳定，因此免费的 IntelliJ IDEA Community Edition 才是更加适合我的选择。 由此又产生了另一个问题，IntelliJ IDEA Community Edition 是不包含 Tomcat 的，所以还是需要我们手动配置。 配置 前往 Apache Tomcat 官网 下载，下载完成后解压至 ~/Library/ 目录，终端进入 Tomcat 下的 bin 目录执行命令： ➜ sudo chmod 755 *.sh 该命令用于授权读写和执行权限，接着尝试启动 Tomcat 服务： ➜ sudo sh ./startup.sh 不知道因为什么原因，即使已经配置过环境变量，Tomcat 无法正确读取我的 JDK 路径： 这并不是什么大问题，因为我们等会可以直接在 IntelliJ IDEA Community Edition 中启动它，你可以跳过这部分的内容。 不过为了能够在终端直接启动，我们可以手动配置一下。 先看看这个问题是在哪里触发的。上方的命令会先进入 startup.sh 文件，内部会调用 catalina.sh： PRGDIR=`dirname &quot;$PRG&quot;` EXECUTABLE=catalina.sh if $os400; then eval else if [ ! -x &quot;$PRGDIR&quot;/&quot;$EXECUTABLE&quot; ]; then echo &quot;Cannot find $PRGDIR/$EXECUTABLE&quot; echo &quot;The file is absent or does not have execute permission&quot; echo &quot;This file is needed to run this program&quot; exit 1 fi fi exec &quot;$PRGDIR&quot;/&quot;$EXECUTABLE&quot; start &quot;$@&quot; 而 catalina.sh 内部则会调用 setclasspath.sh： # Get standard Java environment variables if $os400; then . &quot;$CATALINA_HOME&quot;/bin/setclasspath.sh else if [ -r &quot;$CATALINA_HOME&quot;/bin/setclasspath.sh ]; then . &quot;$CATALINA_HOME&quot;/bin/setclasspath.sh else echo &quot;Cannot find $CATALINA_HOME/bin/setclasspath.sh&quot; echo &quot;This file is needed to run this program&quot; exit 1 fi fi setclasspath.sh 内部找不到 JAVA_HOME 和 JRE_HOME 就会报错： # Make sure prerequisite environment variables are set if [ -z &quot;$JAVA_HOME&quot; ] &amp;&amp; [ -z &quot;$JRE_HOME&quot; ]; then ... if [ -z &quot;$JAVA_HOME&quot; ] &amp;&amp; [ -z &quot;$JRE_HOME&quot; ]; then echo &quot;Neither the JAVA_HOME nor the JRE_HOME environment variable is defined&quot; echo &quot;At least one of these environment variable is needed to run this program&quot; exit 1 fi fi 那么我就可以在 setclasspath.sh 顶部强行写入路径： # 写入 Java 路径，以自己的安装路径为准 export JAVA_HOME=&quot;/Users/liarr/Applications/Android Studio.app/Contents/jbr/Contents/Home&quot; 保存后再次启动： 没有问题。打开浏览器，访问 http://localhost:8080，能正常访问。 关闭 Tomcat 服务： ➜ sudo sh ./shutdown.sh 接下来进入 IntelliJ IDEA Community Edition 进行配置。首先安装「Smart Tomcat」插件： 然后在「Tomcat Server」中添加我们上面安装的 Tomcat 路径： 配置完成后就可以创建项目，为了省去手动创建文件的步骤，这里我直接选择「Maven Archetype」，当然如果你熟悉项目结构的话也可以使用 Gradle 等其他构建方式。 进入后修改运行配置： 在这里添加「Smart Tomcat」： 然后直接运行，控制台会打印出访问地址： 点击即可在浏览器访问，它所渲染的是 ./src/main/webapp/index.jsp 的内容。 至此，基于 IntelliJ IDEA Community Edition 的 Tomcat 配置就已完成，可以愉快地进行下一步的学习了。 另外，这种方法适用于我们开发和调试阶段，如果需要部署到生产环境，需要打成 WAR 包，这属于后话。 ","link":"https://LiarrDev.github.io/post/IntelliJ-IDEA-CE-Tomcat-Configuration-for-macOS/"},{"title":"一次实战爱上 Dom4J","content":"项目工程中使用 XML 作为配置文件很常见，比如 Android 项目中的 AndroidManifest.xml 和 Maven 项目中的 pom.xml，我们在编写脚本工具时经常需要对这类 XML 文件进行读写操作。 XML 的解析有很多种方法，但总体来说都比 JSON 要复杂。今天来介绍一个我常用的 XML 解析库——Dom4J。 为了避免引起逻辑上的混乱，下面我会分几个例子介绍其用法。 添加依赖： dependencies { implementation(&quot;org.dom4j:dom4j:2.1.4&quot;) } 首先看如何读取 XML，一般情况下我们会读取 XML 文件： fun parseXml(file: File) { val document = SAXReader().read(file) // ... } SAXReader 从 SAX 解析事件创建 Dom4J 树，通过 read() 方法读取 XML 并生成一个 Document 对象。 read() 不仅支持 File 类型，其他的如 URL、InputStream、Reader 等也是可以的。 如果希望从字符串中解析，可以换一种方式： fun parseXml(xml: String) { val document = DocumentHelper.parseText(xml) // ... } 读取 XML 内容后，我们通过这个 Document 对象，就可以获取到里面的节点。 举个例子，我们解析如下 XML： &lt;school&gt; &lt;student&gt; &lt;name&gt;Tom&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/student&gt; &lt;/school&gt; 代码如下： fun parseDocument(document: Document) { val rootElement = document.rootElement val student = rootElement.element(&quot;student&quot;) val name = student.elementText(&quot;name&quot;) val age = student.element(&quot;age&quot;).text // ... } 通过 Document 的 getRootElement() 方法拿到根节点，每个节点都是一个 Element 对象，调用其 element() 方法可以获取子节点。最内层的节点，我们有两种方式获取它的值，一种是对该节点的父节点调用 elementText() 方法，可以直接根据子节点的名称获取到值；另一种是先获取到该子节点 Element 对象再调用 getText() 方法获取值。所获取到的值都是 String 类型，按需转换。 在 Android 中我们常见的配置往往是通过属性配置的，比如： &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;warp_content&quot; android:background=&quot;@color/white&quot; tools:background=&quot;@color/black&quot; /&gt; &lt;/FrameLayout&gt; 这是一个布局文件，解析其属性的方法如下： fun parseDocument(document: Document) { val rootElement = document.rootElement val textView = rootElement.element(&quot;TextView&quot;) val id = textView.attributeValue(&quot;id&quot;) // ... } 获取到对应元素的 Element 后，调用 attributeValue() 方法传入属性名获取对应的值，可以看到，虽然该 XML 中每个属性都指定了命名空间，也就是前面的 android:，但我们并不需要传入完整的 android:id 才能获取到该属性的值，恰恰相反，如果把命名空间也写上反而获取不到，这是因为命名空间需要额外配置。 相信你已经注意到，上方对于 background 属性，我在两个命名空间下都有定义，分别是 android:background 和 tools:background，如果直接调用 attributeValue(&quot;background&quot;)，你猜它会获取到哪个值？ 实际上，哪个定义排在前面，它就会获取哪个属性的值。 对于不同命名空间的属性，我们可以通过以下方法进行获取： fun parseDocument(document: Document) { val rootElement = document.rootElement val toolsNamespace = Namespace.get(&quot;tools&quot;, &quot;http://schemas.android.com/tools&quot;) val androidNamespace = Namespace.get(&quot;android&quot;, &quot;http://schemas.android.com/apk/res/android&quot;) val textView = rootElement.element(&quot;TextView&quot;) val toolsBackground = textView.attributeValue(QName.get(&quot;background&quot;, toolsNamespace)) val androidBackground = textView.attributeValue(QName.get(&quot;background&quot;, androidNamespace)) // ... } 先传入前缀和其 Uri 构建对应的命名空间 Namespace，获取属性值时，我们不再简单粗暴地传入属性名，而是通过 Namespace 构建 QName，QName 是 XML 元素或属性的限定名称值，它能够帮助我们根据命名空间解析正确的值。 对于一些相同标签的组，我们无法直接通过标签名直接获取到我们想要的值，可以一次性把这个组下所有的标签都获取到，再根据条件筛选。 比如 Android 中用到的： &lt;application xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot; /&gt; &lt;activity android:name=&quot;.SplashActivity&quot; /&gt; &lt;activity android:name=&quot;.AboutActivity&quot; /&gt; &lt;/application&gt; 通过 Element 的 elements() 可以获取其所有的子节点。 fun parseDocument(document: Document) { val rootElement = document.rootElement val activities = rootElement.elements() activities.forEach { if (it.attribute(&quot;name&quot;).text.contains(&quot;MainActivity&quot;)) { // ... } } } 获取所有属性也是一样的操作，调用 attributes() 即可，不再赘述。 另外还可以通过 elementIterator() 和 attributeIterator() 获取迭代器，使用迭代器遍历来完成操作。 以上就是使用 Dom4J 对 XML 的读操作，在这几个例子中我们可以发现，主要操作的几个对象无非就是 Document、Element 和 Attribute，接下来的写操作大同小异。 fun createDocument(): Document { val document = DocumentHelper.createDocument() val root = document.addElement(&quot;root&quot;) val author = root.addElement(&quot;author&quot;) .addAttribute(&quot;location&quot;, &quot;UK&quot;) .addText(&quot;James Strachan&quot;) return document } 节点、属性的添加与修改，都可以通过 addElement() 和 addAttribute() 来完成，需要注意的是，如果涉及到命名空间，依旧要借助 QName。 为了方便日志打印或其他操作，可以将 Document 转为 XML 字符串： fun convertToXml(document: Document) { val text = document.asXML() // ... } 作为脚本，最重要的当然是回写到文件： fun write(document: Document) { FileWriter(&quot;output.xml&quot;).use { val writer = XMLWriter(it) writer.write(document) writer.close() } } 根据路径创建 FileWriter，再创建出 XMLWriter 并调用 write() 将 Document 写入到路径所对应的文件中，最后不要忘了调用 close()。 除了写入到文件中外，还可以输出到控制台： fun log(document: Document) { val format = OutputFormat.createPrettyPrint() val writer = XMLWriter(System.out, format) writer.write(document) writer.close() } 这里同时还创建了一个格式美化的 OutputFormat，创建 XMLWriter 不再借助 FileWriter，而是传入 System.out，相信任何一个 Java 开发者对这个都不陌生。 以上就是 Dom4J 的常见用法，更详细的介绍可以查阅官方文档。 ","link":"https://LiarrDev.github.io/post/Enjoy-Dom4J-in-One-Shot/"},{"title":"使用 Fiddler Everywhere 在 Android 上抓包","content":"抓包是我们在开发中常用的调试手段，可以快速地帮助我们定位前后端的问题，虽然新版本的 Android Studio 已经配备了「Network Inspector」，但在某些场景或者特殊机型上仍不能很好胜任，所以往往需要借助一些第三方的工具进行抓包。 常见的抓包工具有『Wireshark』、『Charles』和『Fiddler』等等，本次介绍使用『Fiddler Everywhere』在 Android 设备上抓包。 『Fiddler Everywhere』是『Fiddler』的一个分支，支持 macOS、Windows 和 Linux。 下载完成并登录，开始配置。 在「Capture and Inspect Traffic」中选择「Remote Devices」，并选择 Android 设备： 进入配置界面，按照步骤来。 第一步，默认即可。 第二步，下载 CA 证书。 确保手机和电脑连接同一网络，手机扫描二维码或者打开上面的链接，点击下载。 第三步，安装 CA 证书。 该设置的位置往往隐藏得比较深，而且不同手机不同版本都略有差异，可以参考我以下的位置。 选择上一步下载的证书文件进行安装，可以给证书命名，方便我们辨认。 安装完成后，可以在「用户凭据」中查看刚刚安装的证书。 第四步，对 Wi-Fi 设置代理。 参考上面提供的主机名和端口号，在手机上设置。 第五步，测试连接。 手机扫描二维码或直接访问上面的链接，页面提示连接成功。 配置完成，下面可以开始抓包。 但需要注意的是，电脑上也需要信任证书才能对 HTTPS 进行抓包。 记得抓包调试结束后，关闭第四步中对 Wi-Fi 设置的代理。 ","link":"https://LiarrDev.github.io/post/Capture-Traffic-on-Android-with-Fiddler-Everywhere/"},{"title":"Android WebView 选择本地文件","content":"网页开发常常会遇到选择本地文件的需求，在浏览器环境下，页面可以很轻松地拉起资源管理器，而在 Hybrid 应用开发中，往往还需要做一些适配。 你也许觉得诧异，之前的『Android WebView 和 JavaScript 交互』所介绍的方法难道不足以完成交互吗？ 确实，之前介绍的文章已经足够我们完成上述需求，H5 页面响应点击事件后调用 Android 端的方法，Android 端完成文件选择操作，再调用 JavaScript 方法将数据返回。在选择文件这个需求上，似乎不够优雅。 我们看看浏览器上 H5 是如何选择文件的： &lt;html&gt; &lt;input type=&quot;file&quot; /&gt; &lt;/html&gt; 可以看到只需要 &lt;input/&gt; 标签指定文件属性即可实现。如果为了兼容移动平台而修改大量代码的话，大可不必。 那么应该如何做呢？ 我们先简单写一个 HTML 文件用于测试： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;input id=&quot;select_file&quot; type=&quot;file&quot; accept=&quot;image/*&quot; /&gt; &lt;img id=&quot;image&quot; src=&quot;&quot; style=&quot;width: 120px; height: auto; margin: 24px&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; var input = document.getElementById(&quot;select_file&quot;); var image = document.getElementById(&quot;image&quot;); input.onchange = function () { if (this.files.length &gt; 0) { var url = URL.createObjectURL(this.files[0]); image.src = url; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这里只使用了 &lt;input/&gt; 标签和 &lt;img/&gt;，交互就是选择图片并将其显示出来。我目前对于前端的技术并不太熟悉，做得有些丑陋请勿见怪。浏览器的效果如下： 其实 Android 端 WebView 也提供了对文件类型 &lt;input/&gt; 的处理方案： class MainActivity : AppCompatActivity() { private var fileUploadCallback: ValueCallback&lt;Array&lt;Uri&gt;&gt;? = null private val launcher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { if (it.resultCode == RESULT_OK) { it.data?.dataString?.apply { fileUploadCallback?.onReceiveValue(arrayOf(Uri.parse(this))) fileUploadCallback = null } } } override fun onCreate(savedInstanceState: Bundle?) { ... webView.webChromeClient = object : WebChromeClient() { override fun onShowFileChooser(webView: WebView?, filePathCallback: ValueCallback&lt;Array&lt;Uri&gt;&gt;?, fileChooserParams: FileChooserParams?): Boolean { val intent = fileChooserParams?.createIntent() ?: return super.onShowFileChooser(webView, filePathCallback, fileChooserParams) fileUploadCallback = filePathCallback launcher.launch(intent) return true } } } } WebChromeClient 提供了一个 onShowFileChooser() 方法通知客户端显示文件选择器，我们可以在这里处理选择文件的操作，其中 ValueCallback&lt;Uri[]&gt; 类型的参数是一个回调，以提供要上传的文件的路径列表，我们在文件选择完成后使用它；FileChooserParams 用于描述要打开的文件选择器的模式以及与其一起使用的选项，这么听起来和 Intent 有点像，它也确实可以通过 createIntent() 来创建；返回值是布尔类型，如果我们需要执行回调，则返回 true，默认处理则为 false。 效果如下： 某些场景下，我们可能需要上传多张图片，我们修改 HTML 文件： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;input id=&quot;select_file&quot; type=&quot;file&quot; accept=&quot;image/*&quot; multiple /&gt; &lt;img id=&quot;image_0&quot; src=&quot;&quot; style=&quot;width: 120px; height: auto; margin: 24px&quot; /&gt; &lt;img id=&quot;image_1&quot; src=&quot;&quot; style=&quot;width: 120px; height: auto; margin: 24px&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; var input = document.getElementById(&quot;select_file&quot;); var image0 = document.getElementById(&quot;image_0&quot;); var image1 = document.getElementById(&quot;image_1&quot;); input.onchange = function () { if (this.files.length &gt; 0) { var url0 = URL.createObjectURL(this.files[0]); image0.src = url0; } if (this.files.length &gt; 1) { var url1 = URL.createObjectURL(this.files[1]); image1.src = url1; } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 主要是 &lt;input/&gt; 标签增加了 multiple 属性，支持同时选择多个文件，然后 JavaScript 中增加了对第二张图片的处理。浏览器效果如下： Android 端也需要做相应的处理： class MainActivity : AppCompatActivity() { private var fileUploadCallback: ValueCallback&lt;Array&lt;Uri&gt;&gt;? = null private val launcher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { if (it.resultCode == RESULT_OK) { var results = emptyArray&lt;Uri&gt;() it.data?.clipData?.apply { val list = mutableListOf&lt;Uri&gt;() for (i in 0 until itemCount) { list.add(getItemAt(i).uri) } results = list.toTypedArray() } it.data?.dataString?.apply { results = arrayOf(Uri.parse(this)) } fileUploadCallback?.onReceiveValue(results) fileUploadCallback = null } } override fun onCreate(savedInstanceState: Bundle?) { ... webView.webChromeClient = object : WebChromeClient() { override fun onShowFileChooser(webView: WebView?, filePathCallback: ValueCallback&lt;Array&lt;Uri&gt;&gt;?, fileChooserParams: FileChooserParams?): Boolean { val intent = fileChooserParams?.createIntent() ?: return super.onShowFileChooser(webView, filePathCallback, fileChooserParams) if (fileChooserParams.mode == FileChooserParams.MODE_OPEN_MULTIPLE) { intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true) } fileUploadCallback = filePathCallback launcher.launch(intent) return true } } } } 需要注意，尽管 HTML 已经配置了 multiple 属性，但是 createIntent() 似乎并不会给 Intent 添加 Intent.EXTRA_ALLOW_MULTIPLE 标记。因此我们需要手动从 FileChooserParams 中调用 getModel() 方法判断并添加此标记。它有 4 个值： public class WebChromeClient { ... public static abstract class FileChooserParams { /** Open single file. Requires that the file exists before allowing the user to pick it. */ public static final int MODE_OPEN = 0; /** Like Open but allows multiple files to be selected. */ public static final int MODE_OPEN_MULTIPLE = 1; /** Like Open but allows a folder to be selected. The implementation should enumerate all files selected by this operation. This feature is not supported at the moment. @hide */ public static final int MODE_OPEN_FOLDER = 2; /** Allows picking a nonexistent file and saving it. */ public static final int MODE_SAVE = 3; ... } } 不过 MODE_OPEN_FOLDER 被标记为 @hide，所以我们只能用其他三个。 文件选择完成后，我们的处理也与上文选择单个文件有所不同，当选择多个文件时，Uri 会通过 ClipData 返回，这里需要注意的是，当选择单个文件时，ClipData 会为空，此时的处理方案与上文选择单个文件一致。 效果如下： 这样我们就实现了Android 端 WebView 与 Web 端 &lt;input/&gt; 选择文件的优雅交互。 其实 Activity Result API 还给我们提供了选择文件的 ActivityResultContracts，能够更加方便我们解析结果，不过就要写两个 ActivityResultLauncher 分别处理： class MainActivity : AppCompatActivity() { private var fileUploadCallback: ValueCallback&lt;Array&lt;Uri&gt;&gt;? = null private val documentLauncher = registerForActivityResult(ActivityResultContracts.OpenDocument()) { it?.run { fileUploadCallback?.onReceiveValue(arrayOf(this)) fileUploadCallback = null } } private val documentsLauncher = registerForActivityResult(ActivityResultContracts.OpenMultipleDocuments()) { fileUploadCallback?.onReceiveValue(it.toTypedArray()) fileUploadCallback = null } override fun onCreate(savedInstanceState: Bundle?) { ... webView.webChromeClient = object : WebChromeClient() { override fun onShowFileChooser(webView: WebView?, filePathCallback: ValueCallback&lt;Array&lt;Uri&gt;&gt;?, fileChooserParams: FileChooserParams?): Boolean { fileUploadCallback = filePathCallback return when (fileChooserParams?.mode) { FileChooserParams.MODE_OPEN -&gt; { documentLauncher.launch(fileChooserParams.acceptTypes) true } FileChooserParams.MODE_OPEN_MULTIPLE -&gt; { documentsLauncher.launch(fileChooserParams.acceptTypes) true } else -&gt; super.onShowFileChooser(webView, filePathCallback, fileChooserParams) } } } } } 这种方法不需要将 FileChooserParams 生成 Intent（但是要记得通过 getAcceptTypes() 取出并设置 MIME 类型），ActivityResultContracts 已经替我们做了相关的处理，文件选择的结果也不需要手动解析，直接就可以拿到 Uri 进行下一步操作，我个人是认为比上面的统一处理是要清晰一些。 大多数使用场景其实都是上传图片，可以配合之前的文章『浅尝 Android 13 Photo Picker 无惧权限烦恼』一起食用。 ","link":"https://LiarrDev.github.io/post/Select-Local-File-in-Android-Webview/"},{"title":"为 Android 应用构建 Widget","content":"背景 应用 Widget 是可以嵌入到其他应用（如主屏幕）并接收定期更新的微型应用视图，Google 官方的翻译叫做「微件」，在国内的叫法也有许多，比如「小组件」等。 从 Android 1.5（Cupcake，API 3）开始，Widget 就已存在，到后来 Android 4.0（Ice Cream Sandwich，API 14）则逐渐改版调整，直到 Android 6.0（Marshmallow，API 23）交互才稳定下来。 不过由于 Android 的自由度导致不同应用的 Widget 设计风格各异，官方也没有为开发者们提供设计规范以及素材，堆积的 Widget 反而会让桌面变得凌乱，既不美观也不实用，于是 Widget 在经历了短暂的繁荣之后便日渐被人遗忘。 没想到 2020 年 iOS 14 的发布则重新将手机系统上的桌面小组件功能拉回了人们的视野中（iOS 的小组件发展史本文按下不表，有兴趣的读者可自行查阅资料），Widget 又焕发了第二春，除了官方优化外，国内系统比如 OriginOS 也交出了高分答卷。 说了这么多，接下来就写个 Widget 实践一下。 实践 基本配置 得益于『Android Studio』提供的各种能力，我们可以一键生成 Widget 模版。 创建之前我们需要先简单配置一些信息，比如放置的位置、尺寸调整模式、最小宽高等。 虽然可以自动创建，但我们也要知道其创建了哪些东西才能够接着开发。 首先是 /res/xml/new_app_widget_info.xml，我们在上面配置的大部分信息会在这里生成： &lt;appwidget-provider xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:description=&quot;@string/app_widget_description&quot; android:initialKeyguardLayout=&quot;@layout/new_app_widget&quot; android:initialLayout=&quot;@layout/new_app_widget&quot; android:minWidth=&quot;40dp&quot; android:minHeight=&quot;40dp&quot; android:previewImage=&quot;@drawable/example_appwidget_preview&quot; android:previewLayout=&quot;@layout/new_app_widget&quot; android:resizeMode=&quot;horizontal|vertical&quot; android:targetCellWidth=&quot;1&quot; android:targetCellHeight=&quot;1&quot; android:updatePeriodMillis=&quot;86400000&quot; android:widgetCategory=&quot;home_screen&quot; /&gt; 它是一个 AppWidgetProviderInfo 对象，用来描述应用 Widget 的元数据，比如预览、布局、更新频率等。 这里有几个属性需要关注，android:previewImage 是预览图片，会在添加 Widget 前展示，而在 Android 12（S，API 31）之后，它支持配置 android:previewLayout 预览布局： android:updatePeriodMillis 用来控制定期更新的频率，但不能保证实际更新按此值正好准时发生，其不支持少于 30 分钟的值，官方建议尽可能降低更新频率，比如不超过每小时一次，以节省电池电量。 android:initialLayout 是 Widget 的布局，其基于 RemoteViews，所以它并不支持所有的 View 或 ViewGroup，尽管在 Android 12（S，API 31）之后扩展了支持。因此尽量使用基础的视图控件，或者在使用前查阅文档。 Widget 必须定义 android:minWidth 和 android:minHeight，表示默认情况下应占用的最小空间量。当用户向其主屏幕添加微件时，Widget 占用的宽度和高度通常会超过所指定的最小值。虽然单元格的宽度和高度以及应用到 Widget 的自动外边距量可能会因设备而异，但可以使用下表根据所需占用的网格单元格数大致估算 Widget 的最小尺寸： 单元格数量（列数或行数） 可用尺寸 (dp)（minWidth 或 minHeight） 1 40dp 2 110dp 3 180dp 4 250dp … … n 70 × n − 30 接下来看看 AndroidManifest.xml： &lt;manifest ...&gt; &lt;application ...&gt; ... &lt;receiver android:name=&quot;.widget.NewAppWidget&quot; android:exported=&quot;false&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.appwidget.action.APPWIDGET_UPDATE&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.appwidget.provider&quot; android:resource=&quot;@xml/new_app_widget_info&quot; /&gt; &lt;/receiver&gt; &lt;/application&gt; &lt;/manifest&gt; 生成模版自动为我们注册了广播接收器，并将前文中的 AppWidgetProviderInfo 元数据配置到此处。 根据我们已有的认知，不是只有四大组件才需要注册吗？ 没错，其实 Widget 本身也是一个 BroadcastReceiver，我们来看其实现类： class NewAppWidget : AppWidgetProvider() { ... } 可以看到，其继承 AppWidgetProvider，而 AppWidgetProvider 的父类正是 BroadcastReceiver： public class AppWidgetProvider extends BroadcastReceiver { ... } AppWidgetProvider 作为一个辅助类来处理 App Widget 的广播，仅接收与 Widget 有关的广播事件，例如当更新、删除、启用和停用 Widget 时发出的广播。因此我们需要着重了解其生命周期： public class AppWidgetProvider extends BroadcastReceiver { public void onReceive(Context context, Intent intent) {...} public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) {} public void onAppWidgetOptionsChanged(Context context, AppWidgetManager appWidgetManager, int appWidgetId, Bundle newOptions) {} public void onDeleted(Context context, int[] appWidgetIds) {} public void onEnabled(Context context) {} public void onDisabled(Context context) {} public void onRestored(Context context, int[] oldWidgetIds, int[] newWidgetIds) {} } onReceive() 不用过多解释，它就是实现了 BroadcastReceiver 的抽象方法，然后将各种事件分类处理重新分发到其他方法中。 onUpdate() 会在我们设定的更新频率中触发，所以更新 Widget 的相关逻辑应当在此处编写。 onAppWidgetOptionsChanged() 在首次放置 Widget 时以及每次调整 Widget 大小时都会调用，使用此回调可根据 Widget 的大小范围显示或隐藏内容。 每次从 Widget 托管应用中删除 Widget 时，onDeleted() 方法会被调用。 onEnabled() 在首次创建 Widget 实例时调用，如果用户添加多个 Widget 实例，则仅在首次添加时才会调用该方法。 同样，onDisabled() 会在宿主删除最后一个 Widget 实例时被调用。 不难看出，onUpdate() 是最重要的方法，『Android Studio』生成的模版中也仅实现了该方法： class NewAppWidget : AppWidgetProvider() { override fun onUpdate(context: Context, appWidgetManager: AppWidgetManager, appWidgetIds: IntArray) { for (appWidgetId in appWidgetIds) { updateAppWidget(context, appWidgetManager, appWidgetId) } } } internal fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) { val widgetText = context.getString(R.string.appwidget_text) val views = RemoteViews(context.packageName, R.layout.new_app_widget) views.setTextViewText(R.id.appwidget_text, widgetText) appWidgetManager.updateAppWidget(appWidgetId, views) } 示例代码为我们简单实现了更新逻辑，逻辑清晰，无需解释。 AppWidgetProvider 只是一个辅助类。如果希望直接接收 App Widget 广播，自行实现 BroadcastReceiver 同样可行，只需关注如下 Intent Action： ACTION_APPWIDGET_UPDATE ACTION_APPWIDGET_DELETED ACTION_APPWIDGET_ENABLED ACTION_APPWIDGET_DISABLED ACTION_APPWIDGET_OPTIONS_CHANGED 参照 AppWidgetProvider 的处理方式，当然还可以发送自定义的广播内容，这在处理一些过滤逻辑时很有用。 更新 Widget 值得一提的是，更新 Widget 内容可能会消耗大量的计算资源。所以官方也提供了三种更新方式： 完整更新：将新的 RemoteViews 替换之前的 RemoteViews，这是计算开销最大的更新。 internal fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) { ... val remoteViews = RemoteViews(context.getPackageName(), R.layout.widgetlayout).also { setTextViewText(R.id.textview_widget_layout1, &quot;Updated text1&quot;) setTextViewText(R.id.textview_widget_layout2, &quot;Updated text2&quot;) } appWidgetManager.updateAppWidget(appWidgetId, remoteViews) } 部分更新：将新的 RemoteViews 与之前提供的 RemoteViews 合并，以更新 Widget 的某些部分。如果 Widget 未收到至少一个完整更新，系统会忽略此方法。 internal fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) { ... val remoteViews = RemoteViews(context.getPackageName(), R.layout.widgetlayout).also { setTextViewText(R.id.textview_widget_layout, &quot;Updated text&quot;) } appWidgetManager.partiallyUpdateAppWidget(appWidgetId, remoteViews) } 集合数据刷新：使 Widget 中集合视图的数据失效，这会触发 RemoteViewsFactory.onDataSetChanged()。 internal fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) { ... appWidgetManager.notifyAppWidgetViewDataChanged(appWidgetId, R.id.widget_listview) } 除了在接收广播时更新 Widget，在应用内更新也同样可行，比如给 Widget 换肤等场景。只需获取到 AppWidgetManager 和 AppWidgetIds 即可： object MyAppWidgetManager { fun updateAppWidget(context: Context) { val appWidgetManager = AppWidgetManager.getInstance(context) val appWidgetIds = appWidgetManager.getAppWidgetIds(ComponentName(context, NewAppWidget::class.java)) for (appWidgetId in appWidgetIds) { updateAppWidget(context, appWidgetManager, appWidgetId) } } } 如果通过发送广播的方式，也可以这样写： object MyAppWidgetManager { fun updateAppWidget(context: Context) { val appWidgetManager = AppWidgetManager.getInstance(context) val appWidgetIds = appWidgetManager.getAppWidgetIds(ComponentName(context, NewAppWidget::class.java)) val intent = Intent().apply { ... // action, package, ect. putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, appWidgetIds) } context.sendBroadcast(intent) } } 还可以自定义 action 来过滤操作。 由于本质上就是 BroadcastReceiver 的特性，Widget 更新的时长和优先级尤为重要，系统通常会允许 BroadcastReceiver 最多运行 10 秒，然后会将其视为无响应并触发 ANR 错误。如果更新 Widget 需要更长的时间，使用 WorkManager 安排任务是个不错的选择。 但在 Widget 中使用 WorkManager 也会引发一些预期之外的事情，比如 WorkManager 可能会导致 Widget 频繁刷新，从而引发 Widget 闪烁，这是一个已知 Bug，Google 提供了一个另类的解决方法，是用 setInitialDelay() 方法给 WorkManager 配置一个 10 年的初始延迟。经过测试这个方法确实能够解决问题，但不优雅，Google 团队也表示未来将优化 WorkManager 在 Widget 中的表现。 RemoteViews 更新控件 上面提到，Widget 是通过 RemoteViews 来更新的，而 RemoteViews 并不是一个 View 或 ViewGroup： public class RemoteViews implements Parcelable, Filter { ... } 这意味着我们并不能像平时更新 View 那样对 Widget 内的控件进行设置，只能使用 RemoteViews 提供的方法，比如上面提到的： internal fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) { ... val views = RemoteViews(context.packageName, R.layout.new_app_widget) views.setTextViewText(R.id.appwidget_text, widgetText) views.setImageViewResource(R.id.appwidget_img, R.drawable.bg) ... } 虽然 RemoteViews 提供了常用的方法，但这种用法仍为我们带来不少麻烦，比如我想对 Widget 里面的某个 View 动态设置背景，似乎就找不到类似 RemoteViews.setBackground() 之类的方法。不过点进 RemoteViews 的源码后发现，其实上面的这些操作都是通过反射实现的，比如： public class RemoteViews implements Parcelable, Filter { ... public void setImageViewResource(@IdRes int viewId, @DrawableRes int srcId) { setInt(viewId, &quot;setImageResource&quot;, srcId); } public void setInt(@IdRes int viewId, String methodName, int value) { addAction(new ReflectionAction(viewId, methodName, BaseReflectionAction.INT, value)); } } 所以给 View 设置背景时，我们可以为 RemoteViews 写个扩展方法： fun RemoteViews.setBackgroundResource(@IdRes viewId: Int, @DrawableRes srcId: Int) { this.setInt(viewId, &quot;setBackgroundResource&quot;, srcId) } 这样就能实现想要的效果。 获取 Widget 尺寸 由于 RemoteViews 的限制，我们无法在 Widget 内使用自定义 View，这样类似简单常用的圆角 ImageView 都无法实现，这个时候可以考虑曲线救国，比如对图片的 Bitmap 进行裁剪处理，生成一个圆角的图片进行显示。 但是同一 Widget 在不同 ROM 下显示的尺寸都会有差异，所以使用 ImageView 作为圆角背景图展示时可能会遇到图片拉伸等问题，官方也没有提供对应的 API 供我们获取，我在 StackOverflow 上找到了一个并不完美的解决方案： /** * 获取 Widget 尺寸 * * @param context Do not pass Application context */ class WidgetSizeProvider(private val context: Context) { private val appWidgetManager = AppWidgetManager.getInstance(context) fun getWidgetsSize(widgetId: Int): Pair&lt;Int, Int&gt; { val isPortrait = context.resources.configuration.orientation == Configuration.ORIENTATION_PORTRAIT val width = getWidgetWidth(isPortrait, widgetId) val height = getWidgetHeight(isPortrait, widgetId) val widthInPx = context.dip(width) val heightInPx = context.dip(height) return widthInPx to heightInPx } private fun getWidgetWidth(isPortrait: Boolean, widgetId: Int) = if (isPortrait) { getWidgetSizeInDp(widgetId, AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH) } else { getWidgetSizeInDp(widgetId, AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH) } private fun getWidgetHeight(isPortrait: Boolean, widgetId: Int) = if (isPortrait) { getWidgetSizeInDp(widgetId, AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT) } else { getWidgetSizeInDp(widgetId, AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT) } private fun getWidgetSizeInDp(widgetId: Int, key: String) = appWidgetManager.getAppWidgetOptions(widgetId).getInt(key, 0) private fun Context.dip(value: Int): Int = (value * resources.displayMetrics.density).toInt() } 测试过程中发现，在平板上这种方法判断横竖屏不准确，Widget 中也无法监听屏幕旋转，于是加上宽高的判断： /** * 获取 Widget 尺寸 * * @param context Do not pass Application context */ class WidgetSizeProvider(private val context: Context) { ... fun getWidgetsSize(widgetId: Int): Pair&lt;Int, Int&gt; { val isPortrait = ScreenUtils.getScreenHeight(context) &gt; ScreenUtils.getScreenWidth(context) &amp;&amp; context.resources.configuration.orientation == Configuration.ORIENTATION_PORTRAIT ... } } 但是目前仍有一个问题无法解决，系统允许设置桌面图标网格列数，默认情况下，大多数手机桌面图标网格为 4 列。 绝大多数手机在 4 列的情况下获取到的宽高都没问题，或者说即使有误差但视觉上不易察觉出来，当切换到 5 列时，通过以上方法在很多厂商定制的系统（HarmonyOS、MagicOS、REDMAGIC OS 等）中出现了严重的误差，通过计算得知这些系统在返回宽度时是按照每列固定的宽度返回，而不是实际占据的宽度。 举个例子，比如在 4 列的情况下，图标所占用的宽度为 64dp，两个图标间隔为 16dp，这样一个横向铺满的 Widget 宽度为 304dp；当切到 5 列时，这些定制的系统返回的结果是 384dp。 问题就出在这里，一个横向铺满的 Widget，无论列数如何变更，它们的宽度差值应该不会超过一个间隔的宽度，这些厂商粗暴的计算导致返回的结果超过了小组件实际的宽度，甚至超过了屏幕的宽度。 而测试发现，在搭载原生 Android 系统的 Google Pixel 上却没有此问题！ 虽然这种获取尺寸的方法并非官方认证，但不同系统的割裂情况依然让我头疼。 我猜测，产生这个问题的原因可能是因为从 Android 12 开始官方才支持调整桌面图标网格，而大多数 ROM 在很早之前就使用自己的方式实现了，但并没有考虑到 Widget 尺寸的问题，同时即使 Android 12 官方已经实现该功能，这些厂商因为种种原因没有迁移反而将屎山代码流传下来所导致。 从 Widget 中启动应用 一般情况下点击 Widget 会启动应用，行为与在桌面点击应用图标一致，冷启动时进入启动页，热启动时进入到退到后台时所在的页面。但在 Android 12 上，该默认行为被取消了，也就是说不设置点击事件的情况下，点击 Widget 将不会自动启动应用，我们可以尝试给它构建一个无路径的 Intent 来解决该问题： internal fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) { val views = RemoteViews(context.packageName, R.layout.new_app_widget) if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) { val stackBuilder = TaskStackBuilder.create(context).addNextIntent(Intent()) val pendingIntent = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT) views.setOnClickPendingIntent(R.id.appwidget_root, pendingIntent) } appWidgetManager.updateAppWidget(appWidgetId, views) } 要是想修改该行为也是可以的： internal fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) { val views = RemoteViews(context.packageName, R.layout.new_app_widget) val stackBuilder = TaskStackBuilder.create(context).apply { addNextIntentWithParentStack(Intent(context, MainActivity::class.java)) addNextIntent(Intent(context, WidgetActivity::class.java)) } val pendingIntent = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT) views.setOnClickPendingIntent(R.id.appwidget_text, pendingIntent) appWidgetManager.updateAppWidget(appWidgetId, views) } 这里看到设置了两个 Activity，其中 WidgetActivity 是要跳转的页面，MainActivity 是首页，这是一个很常见的交互，即小组件跳转到具体页面后返回直接回到应用主页，而不是退出应用。通过 addNextIntentWithParentStack() 可以构建包含返回栈的 PendingIntent。 仍需要注意的是，一般应用会在闪屏页执行一些初始化操作，但如果像上面修改了 Widget 的启动页面后，应用不经闪屏页即进入 WidgetActivity，会导致某些功能出现异常，所以可以考虑做一个中间页跳转，在中间页做初始化操作，或者直接复用闪屏页功能，根据不同情况跳转。 当 Widget 内不同的 View 需要响应不同的 PendingIntent 时，我们习惯性会通过 putExtra() 方法给同一个键传递不同的值，但在这里你可能会发现，后一个设置的值总会覆盖前一个，比如： internal fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) { val views = RemoteViews(context.packageName, R.layout.new_app_widget) val stackBuilder1 = TaskStackBuilder.create(context).apply { ... addNextIntent(Intent(context, WidgetActivity::class.java).putExtra(&quot;arg&quot;, 1)) } val pendingIntent1 = stackBuilder1.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT) views.setOnClickPendingIntent(R.id.appwidget_text, pendingIntent2) val stackBuilder2 = TaskStackBuilder.create(context).apply { ... addNextIntent(Intent(context, WidgetActivity::class.java).putExtra(&quot;arg&quot;, 2)) } val pendingIntent2 = stackBuilder2.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT) views.setOnClickPendingIntent(R.id.appwidget_img, pendingIntent2) appWidgetManager.updateAppWidget(appWidgetId, views) } 无论点击哪一个 View，我们在 WidgetActivity 接收数据会发现都是 2，这显然是不合理的。究其原因，是系统把这两个 PendingIntent 都当成同一个去处理了，我们有两种方法可以避免这个问题。 一是为 Intent 添加不同的 action： internal fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) { val stackBuilder1 = TaskStackBuilder.create(context).apply { ... addNextIntent(Intent(context, WidgetActivity::class.java).putExtra(&quot;arg&quot;, 1).setAction(&quot;action_1&quot;)) } val stackBuilder2 = TaskStackBuilder.create(context).apply { ... addNextIntent(Intent(context, WidgetActivity::class.java).putExtra(&quot;arg&quot;, 2).setAction(&quot;action_2&quot;)) } ... appWidgetManager.updateAppWidget(appWidgetId, views) } 二是指定唯一的 requestCode： internal fun updateAppWidget(context: Context, appWidgetManager: AppWidgetManager, appWidgetId: Int) { val pendingIntent1 = stackBuilder1.getPendingIntent(1, PendingIntent.FLAG_UPDATE_CURRENT) val pendingIntent2 = stackBuilder2.getPendingIntent(2, PendingIntent.FLAG_UPDATE_CURRENT) ... appWidgetManager.updateAppWidget(appWidgetId, views) } 这两种方案都可以为每个 View 区分 PendingIntent 并传递不同的参数，确保它们能够按照我们期望的方式执行。 Widget 的名称和描述 Widget 的描述是从 Android 12（S，API 31）开始支持的，也就是上文模版中配置的： &lt;appwidget-provider ... android:description=&quot;@string/app_widget_description&quot; /&gt; 但是 Widget 名称并没有默认配置，这时系统会将应用名称作为其默认名称。当一个应用有多个 Widget 的情况下，未配置名称会让用户无法得知每一个 Widget 的作用，比如看『豆瓣』的几个 Widget 你能分辨出它们分别是什么吗： Widget 的名称实际上是通过配置 BroadcastReceiver 的 label 实现的： &lt;manifest ...&gt; &lt;application ...&gt; ... &lt;receiver android:name=&quot;.widget.NewAppWidget&quot; android:exported=&quot;false&quot; android:label=&quot;@string/widget_name&quot;&gt; ... &lt;/receiver&gt; &lt;/application&gt; &lt;/manifest&gt; 效果如下： 应用内向桌面添加 Widget 你在日常使用一些 App 时也许有留意到，系统允许在应用内直接向桌面添加 Widget： 这个功能实际上是从 Android 8（Oreo，API 26）开始提供的： fun addWidgetToHomeScreen(context: Context) { if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.O) { return } val appWidgetManager = AppWidgetManager.getInstance(context) val provider = ComponentName(context, NewAppWidget::class.java) if (appWidgetManager.isRequestPinAppWidgetSupported) { val intent = Intent(context, NewAppWidget::class.java) val successCallback = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT) appWidgetManager.requestPinAppWidget(provider, null, successCallback) } } 如果应用不需要收到系统是否成功将 Widget 固定到受支持的启动器上的通知，可以将 null 作为 requestPinAppWidget() 的第三个参数传入。 总结 以上就是构建 App Widget 的简单介绍，同时也涉及到 RemoteViews、 PendingIntent 和 WorkManager 的一些坑，事实上还有许多配置未提及，另一方面 Android 12（S，API 31）这个版本也为 Widget 扩展了许多能力，本文未能一一介绍，如需要更高级的定制功能，可自行查阅文档。 参考内容 应用 widget 概览 | Android Developers 构建应用微件 | Android 开发者 | Android Developers 应用微件设计指南 | Android 开发者 | Android Developers RemoteViews | Android Developers 从通知启动 Activity | Android 开发者 | Android Developers Disabling component leads to AppWidgetProvider.onUpdate call - Google Issue Tracker widgets are &quot;flickering&quot; during every update (even if there is no content change) - Google Issue Tracker Bug: WorkManager can trigger onUpdate of AppWidget - Google Issue Tracker android - Refresh AppWidget with network request using RemoteView button - Stack Overflow android - Get the size of my homescreen widget - Stack Overflow android - How to detect orientation change in home screen widget? - Stack Overflow ","link":"https://LiarrDev.github.io/post/Building-Widgets-for-Android-Apps/"},{"title":"浅尝 Android 13 Photo Picker 无惧权限烦恼","content":"背景 最近两年适配 Android 新版本的小伙伴应该都发现，Android 对于系统读写权限的管理又收窄了。 Android 13（Tiramisu, API 33）上，废弃了 READ_EXTERNAL_STORAGE 权限，新增 READ_MEDIA_IMAGES、READ_MEDIA_VIDEO 和 READ_MEDIA_AUDIO 三个权限分别用于控制图片、视频、音频的访问。 Android 14（UpsideDownCake, API 34）上则新增了 READ_MEDIA_VISUAL_USER_SELECTED 权限，用户可以选择性地让应用访问部分图片或视频。 由于系统选择器过于丑陋，相信大多数需要用到图片选择功能的 App，都会自行实现或者接入三方库来内置图片选择器功能，而这个行为在 Android 14 上则会遇到新的问题，当用户仅授权部分图片或视频时，整个操作路径会非常长，即用户首先需要选择授权哪些照片给应用，然后再从应用内置的图片选择器中选择照片。 另一方面，Play Store 对于权限的获取政策也在将来收紧： Timeline information We anticipate the following timeline for the rollout of the Photo and Video Permissions policy. Note that this is subject to change; updates will be posted in this article. October 2023: We announced the new Photos and Video Permissions policy. Mid 2024: Apps with one-time or infrequent use of photos requested to use a system photo picker and remove READ_MEDIA_IMAGES and READ_MEDIA_VIDEO permissions from their app manifest. Early 2025: Only apps with broad access core functionality can use READ_MEDIA_IMAGES and READ_MEDIA_VIDEO permissions. 时间表信息 我们预计将按照以下时间表发布“照片和视频权限”政策。请注意，此时间表可能会有变动；届时我们会在本文中发布更新。 2023 年 10 月： 我们公布了新的“照片和视频权限”政策。 2024 年年中： 如果应用只用一次照片，或者很少用到照片，则必须使用系统照片选择器，并从应用清单中移除 READ_MEDIA_IMAGES 和 READ_MEDIA_VIDEO 权限。 2025 年初： 只有核心功能需要获取广泛访问权限的应用才能使用 READ_MEDIA_IMAGES 和 READ_MEDIA_VIDEO 权限。 Photo Picker 好消息是，从 Android 13（Tiramisu, API 33）开始，官方提供了系统级图片选择器 Photo Picker，样式和体验都非常丝滑。最重要的是，无需申请权限，只需几行代码即可轻松接入。 androidx.activity 1.6.0+ 首先把 androidx.activity 升级到最新版本： dependencies { implementation(&quot;androidx.activity:activity:1.8.2&quot;) } 由于项目原因无法升级的，在下文会给出解决方案。 接下来只需使用 Activity Result API 调用即可： class MainActivity : AppCompatActivity() { ... private val pickMedia = registerForActivityResult(ActivityResultContracts.PickVisualMedia()) { if (it != null) { // 选择图片的 Uri } else { // 未选择图片 } } private fun pickImage() = pickMedia.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly)) private fun pickVideo() = pickMedia.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.VideoOnly)) private fun pickImageOrVideo() = pickMedia.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageAndVideo)) private fun pickByMime(mimeType: String) = pickMedia.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.SingleMimeType(mimeType))) } 通过向 PickVisualMediaRequest() 中传入不同的类型来构建不同的请求对象。是的，你没看错，我们调用的 PickVisualMediaRequest() 实际上是一个方法，它会在内部帮我们构建同名类的对象： fun PickVisualMediaRequest( mediaType: VisualMediaType = ImageAndVideo ) = PickVisualMediaRequest.Builder().setMediaType(mediaType).build() class PickVisualMediaRequest internal constructor() { ... class Builder { ... } } VisualMediaType 是一个密封接口，由上面我们示例的几种类型实现，分别对应仅选择图片、仅选择视频、选择图片或视频和仅选择特定的 MIME 类型。 效果如下： 如果想设置多选，Photo Picker 同样支持： class MainActivity : AppCompatActivity() { ... private val pickMultipleMedia = registerForActivityResult(ActivityResultContracts.PickMultipleVisualMedia(5)) { if (it.isNotEmpty()) { // 选择的图片 Uri 集合 } else { // 未选择图片 } } private fun pickImages() = pickMultipleMedia.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly)) private fun pickVideos() = pickMultipleMedia.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.VideoOnly)) private fun pickImageOrVideos() = pickMultipleMedia.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageAndVideo)) private fun pickByMimes(mimeType: String) = pickMultipleMedia.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.SingleMimeType(mimeType))) } 只需把 ActivityResultContract 更换为多选的 PickMultipleVisualMedia 即可，同时可以传入一个整型参数控制选择的文件数量上限。效果如下： 是不是非常简单？ 前文提到，Photo Picker 从 Android 13（Tiramisu, API 33）开始支持，这个说法其实并不准确，官方文档中提到，支持 Google Play Service 的设备也是可以更新使用的，在不支持 Photo Picker 的低版本机型中，该库会自动调用 ACTION_OPEN_DOCUMENT 打开系统资源管理器进行选择： 同时，如果你使用多选模式，资源管理器会忽略所设置的数量上限。 官方也提供了一个方法用于判断 Photo Picker 在给定设备上是否可用： class ActivityResultContracts private constructor() { ... @RequiresApi(19) open class PickVisualMedia : ActivityResultContract&lt;PickVisualMediaRequest, Uri?&gt;() { companion object { ... @SuppressLint(&quot;ClassVerificationFailure&quot;, &quot;NewApi&quot;) @JvmStatic fun isPhotoPickerAvailable(context: Context): Boolean { return isSystemPickerAvailable() || isSystemFallbackPickerAvailable(context) || isGmsPickerAvailable(context) } } ... } } androidx.activity 1.5.1- 接下来说说 androidx.activity 在低版本中如何处理，低版本中存在的问题主要是 PickVisualMedia 和 PickMultipleVisualMedia 两个 ActivityResultContract 的缺失，同时连带 isPhotoPickerAvailable() 这个判断方法也无法使用。 我们采用的策略就是当系统版本不低于 Android 13 时，使用 Photo Picker，否则使用系统资源管理器。 实现的方法有很多，我这里简单写两个 ActivityResultContracts 示例，你可以根据实际情况进行扩展： object PicResultContract { class PickImage : ActivityResultContract&lt;Void?, Uri?&gt;() { override fun createIntent(context: Context, input: Void?): Intent { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) { return Intent(MediaStore.ACTION_PICK_IMAGES).setType(&quot;image/*&quot;) } return Intent(Intent.ACTION_OPEN_DOCUMENT).setType(&quot;image/*&quot;) } override fun parseResult(resultCode: Int, intent: Intent?): Uri? { return intent.takeIf { resultCode == Activity.RESULT_OK }?.data } } class PickImages : ActivityResultContract&lt;Int, List&lt;Uri&gt;&gt;() { override fun createIntent(context: Context, input: Int): Intent { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) { return Intent(MediaStore.ACTION_PICK_IMAGES) .putExtra(MediaStore.EXTRA_PICK_IMAGES_MAX, input) .setType(&quot;image/*&quot;) } return Intent(Intent.ACTION_OPEN_DOCUMENT) .putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true) .setType(&quot;image/*&quot;) } override fun parseResult(resultCode: Int, intent: Intent?): List&lt;Uri&gt; { val i = intent.takeIf { resultCode == Activity.RESULT_OK } val data = i?.data if (data != null) { return listOf(data) } val clipData = i?.clipData if (clipData != null &amp;&amp; clipData.itemCount &gt; 0) { return (0 until clipData.itemCount).map { clipData.getItemAt(it).uri } } return emptyList() } } } 示例中的多选仍然参考了高版本中的策略，当使用资源管理器时，所设置的文件数量上线也会被忽略。 使用方法与原来类似（仅做示例使用所以没有完全参照原来的写法复刻，自行改造即可）： class MainActivity : AppCompatActivity() { ... private val pickImage = registerForActivityResult(PicResultContract.PickImage()) { if (it != null) { // 选择图片的 Uri } else { // 未选择图片 } } private val pickImages = registerForActivityResult(PicResultContract.PickImages()) { if (it.isNotEmpty()) { // 选择的图片 Uri 集合 } else { // 未选择图片 } } private fun pickImage() = pickImage.launch(null) private fun pickImages() = pickImages.launch(5) } 后记 前阵子 @郭霖 发了一篇文章『Android 14新特性，选择性照片和视频访问授权』，我也在评论区探讨了交互的策略，在支持的设备（或 Android 13+）中使用 Photo Picker，否则使用应用内实现的图片选择器，或许是当下最好的方案。 参考内容 Photo picker | Android Developers ","link":"https://LiarrDev.github.io/post/Try-Photo-Picker-on-Android-13-without-Permission-Hassles/"},{"title":"Android Bitmap 灰度处理","content":"前言 平时在使用『Photoshop』做图时，我们常会对图片做去色处理，以实现各种丰富的细节。灰度处理还有如下作用： 降低数据维度：彩色图像通常包含了大量的冗余信息，而灰度图像只保留了图像的亮度信息。通过灰度处理，可以将图像的数据维度从三维（RGB 通道）降低为二维（灰度值）。 简化图像处理：在许多图像处理任务中，只需要关注图像的亮度信息而不需要颜色信息。通过将图像转换为灰度图像，可以简化后续的图像处理操作，减少计算量和复杂度。 提高图像分析效果：在某些情况下，灰度图像可以更好地突出图像中的细节和特征。例如，在边缘检测、形状识别、人脸识别等任务中，使用灰度图像可以更容易地提取和分析图像的特征。 那么在 Android 开发中我们能否对图片做类似的灰度处理呢？ 原理 色饱和度（Saturation）是指是播放的光的彩色深浅度或鲜艳度。色饱和度表示播放的光的彩色鲜艳度，取决于彩色中的灰度，灰度越高，色彩饱和度即越低，反之亦然。 图像的灰度处理中有很多种方法，其中比较有名的算法是通过对彩色图像的 RGB 通道进行加权平均来计算灰度值。通常使用以下公式计算每个像素的灰度值， 其中，R、G、B 分别表示红色、绿色和蓝色通道的像素值。 Gray=0.299×R+0.587×G+0.114×BGray = 0.299 \\times R + 0.587 \\times G + 0.114 \\times B Gray=0.299×R+0.587×G+0.114×B 由于人眼对绿色的敏感度最高，对蓝色的敏感度最低，该方法基于人眼对不同颜色通道的敏感度不同，对 RGB 三分量进行加权平均能相对合理地将彩色信息转换为灰度信息。 浮点运算效率不高，因此该公式也有很多变种，本文暂不讨论。 实现 我们可以通过遍历图片中的每个像素，使用上述公式计算出其灰度值，再生成图像： fun Bitmap.toGray(): Bitmap { val ret = Bitmap.createBitmap(width, height, config) for (i in 0 until width) { for (j in 0 until height) { val pixel = getPixel(i, j) val gray = Color.red(pixel) * 0.299 + Color.green(pixel) * 0.587 + Color.blue(pixel) * 0.114 val color = Color.rgb(gray.toInt(), gray.toInt(), gray.toInt()) ret.setPixel(i, j, color) } } return ret } setPixel() 内部是调用 Native 方法实现的，在主线程中循环调用很容易造成 ANR，因此应当放在子线程中处理。 当然，我们可以先把总的灰度值算出来，再一次性对 Bitmap 设置： fun Bitmap.toGray(): Bitmap { val ret = Bitmap.createBitmap(width, height, config) val pixels = IntArray(width * height) this.getPixels(pixels, 0, width, 0, 0, width, height) val alpha = 0xFF shl 24 for (i in 0 until height) { for (j in 0 until width) { val pixel = pixels[width * i + j] val gray = (Color.red(pixel) * 0.299 + Color.green(pixel) * 0.587 + Color.blue(pixel) * 0.114).toInt() val color = alpha or (gray shl 16) or (gray shl 8) or gray pixels[width * i + j] = color } } ret.setPixels(pixels, 0, width, 0, 0, width, height) return ret } 这里使用一个数组来存储每个像素的计算结果，最后再通过 setPixels() 方法一次性设置到 Bitmap 中。 其实 Android 本身就提供了对饱和度的处理方法，我们可以直接调用实现，无需手动计算： fun Bitmap.toGray(): Bitmap { val ret = Bitmap.createBitmap(this.width, this.height, this.config) val canvas = Canvas(ret) val cm = ColorMatrix().apply { setSaturation(0f) } val paint = Paint().apply { colorFilter = ColorMatrixColorFilter(cm) } canvas.drawBitmap(this, 0f, 0f, paint) return ret } 如果项目有使用 OpenCV，那么也可以： fun Bitmap.toGray(): Bitmap { val src = Mat() val dst = Mat() Utils.bitmapToMat(this, src) Imgproc.cvtColor(src, dst, Imgproc.COLOR_BGR2GRAY) Utils.matToBitmap(dst, this) src.release() dst.release() return this } ","link":"https://LiarrDev.github.io/post/Android-Bitmap-Grayscale/"},{"title":"Android OpenCV 项目配置笔记","content":"之前我们搭建了 NDK 的项目环境，NDK 为我们打开了另一个世界，OpenCV 便是这新世界的领域之一，OpenCV 相关的资料介绍你可以在网上搜索到，这里就不赘述了，今天来讲讲 OpenCV 的环境配置。 OpenCV 的 Android SDK 以 Module 形式提供，但其目录结构与我们常见的 Android Module 略有差异，所以也给我们的配置带来一定门槛。我个人感觉是历史遗留问题，因此本文的配置教程在后续版本中不一定适用。 本文所用到的工具版本： Android Studio Hedgehog | 2023.1.1 OpenCV 4.8.1 Java 17 OpenCV Android SDK 可以从官网或者其项目 Github Release 下载，NDK 环境虽然在 OpenCV 的后续开发中有着至关重要的作用，但与本文暂不关联，可自行决定是否配置。 下载到的 OpenCV Android SDK 目录如下： OpenCV-android-sdk ├── LICENSE ├── README.android ├── samples └── sdk ├── build.gradle ├── etc ├── java ├── libcxx_helper └── native 我们将 /sdk 目录导入为 Module 即可： Gradle 会自动同步，如无意外，同步失败。 打开 /opencv/build.gradle 我们可以看到维护者为我们写了一大堆注释介绍如何导入，但并不完整，不然我也不需要特意写个笔记来记录。 我们将该 Module 的 targetSdkVersion 与主项目一致，并添加 namespace，同时取消 kotlin-android 这个 Plugin 的引入，相关修改如下： apply plugin: 'com.android.library' // apply plugin: 'kotlin-android' // 修改 ①：取消引入 android { namespace &quot;org.opencv&quot; // 修改 ②：添加 namespace compileSdkVersion 34 // 修改 ③：修改为和主项目一致 defaultConfig { minSdkVersion 21 targetSdkVersion 34 // 修改 ④：修改为和主项目一致 ... } ... } 项目初始化时我选择了 Kotlin DSL 作为构建配置语言，所以它会初始化一个 /settings.gradle.kts 文件，但是 OpenCV Android SDK 仍旧采用老的 Groovy DSL，所以导入时 Android Studio 又会另外增加一个 /settings.gradle 文件，其实这是没有必要的，我们将 /settings.gradle 文件删除，并在 /settings.gradle.kts 文件末尾将该 Module 引入即可： pluginManagement { ... } dependencyResolutionManagement { ... } rootProject.name = &quot;OpenCV&quot; include(&quot;:app&quot;) include(&quot;:opencv&quot;) // 添加导入的 OpenCV Module 这样导入 OpenCV Module 的操作就完成了，可以正常编译运行。 接下来将其添加到宿主依赖，在 /app/build.gradle.kts 中添加： dependencies { ... implementation(project(&quot;:opencv&quot;)) } 接下来会发现 OpenCVEngineInterface 这个接口被其他类导入时报错为不存在，因为它实际上是一个 AIDL 接口，所以我们需要为其创建专门的 AIDL Folder： 然后将 OpenCVEngineInterface 文件拷贝到刚刚创建的 AIDL Folder 下，并创建为相同路径名称： 同时也需要在 /opencv/build.gradle 中开启 AIDL 配置： android { ... buildFeatures { aidl true } } 在 /gradle.properties 中配置： android.defaults.buildfeatures.buildconfig=true 再次运行，OpenCVEngineInterface 能够被正常识别。 Android OpenCV 基本配置已完成。 ","link":"https://LiarrDev.github.io/post/Android-OpenCV-Project-Configuration/"},{"title":"Android NDK CMake 项目搭建笔记","content":"前言 Android 开发在接入一些第三方库时，你可能会发现它们会带有 SO 库，这些 SO 库是通过 C/C++、Rust 等语言编写生成的。 使用这种方式开发，有以下几个优点： 性能快。C/C++ 编译过程是可执行文件到机器码，而 Java 则是字节码到 JVM 再到机器码。虽然 C/C++ 代码高效，但 Java 和 C/C++ 互相调用时却增大了开销。 安全性高。APK 中的 Java 代码很容易被反编译，而 C/C++ 库逆向难度较高。 便于平台间的移植。通过 C/C++ 实现的动态库可以很方便地在其他平台上使用。 可调用系统底层功能。这在硬件交互上很常见，比如驱动开发、音视频处理、人脸识别等等。 当接触到这种开发方式时，有几个名词会不断出现： NDK：即 Native Development Kit。它是原生开发工具包，这套工具允许 Android 使用 C/C++ 代码，帮助开发者快速开发 C/C++ 的动态库。 JNI：即 Java Native Interface。它是 Java 平台的一部分，也就是 Java 与 C/C++ 相互通信的接口。 Makefile：将 C/C++ 代码编译成原生库的编译工具。在 Android 中，Makefile 依靠 ndk-build 脚本编译工具来完成配置编译，通常需要编写 Android.mk 和 Application.mk 两个 Makefile 文件，这种构建方式在『Eclipse』中比较常见。Makefile 依赖于编译平台，在不同的平台上有不同的编译工具，遵循的规则也不相同，所以在不同的平台上编译时，需要重新配置 Makefile，工作量较大也容易出错。 CMake：同样也是将 C/C++ 代码编译成原生库的编译工具，但它是一个跨平台的编译工具，很好地解决了 Makefile 的缺陷，只需要配置一个平台无关的 CMakeList.txt 文件来定制整个流程。同时它也是『Android Studio』中常用的编译工具。 了解这些基础含义，我们就可以开始项目的搭建工作。 搭建 了解 NDK 项目的搭建方式，最方便的莫过于直接利用『Android Studio』创建的模版来观察它与普通项目的异同。 它会自动帮我们下载及创建所需的文件，这样我们如果在现有项目中接入就可以参考对比。 SDK Tools 首先是需要 NDK 和 CMake 工具，在「SDK Tools」中下载即可： CMake 在 Module 的 build.gradle.kts 文件中指定 CMake 的目录和版本： android { ... externalNativeBuild { cmake { path = file(&quot;src/main/cpp/CMakeLists.txt&quot;) version = &quot;3.22.1&quot; } } } 接着在这个指定的目录下创建文件 src/main/cpp/CMakeLists.txt： 大致内容如下： # 设置此项目所需的最低 CMake 版本 cmake_minimum_required(VERSION 3.22.1) # 声明项目名称 project(&quot;hellondk&quot;) # 创建并命名库，将其设置为 STATIC 或 SHARED，并提供其源代码的相对路径 add_library(${CMAKE_PROJECT_NAME} SHARED native-lib.cpp) # 声明 CMake 需要链接的库 target_link_libraries(${CMAKE_PROJECT_NAME} library android log) 在 add_library() 这一步，我们创建了一个以 ${CMAKE_PROJECT_NAME} 命名的库，实际上它就是 project() 中指定的项目名称。最终生成的 SO 文件将会以 lib${CMAKE_PROJECT_NAME}.so 命名，在这里就是 libhellondk.so。 同时还看到上面指定了一个 C++ 文件，那么继续创建它： 至此，开发环境已搭建完成，同步下 Gradle，即可开始编码。 开发 首先需要加载对应的库： class MainActivity : AppCompatActivity() { ... companion object{ init { System.loadLibrary(&quot;hellondk&quot;) } } } 这里 Kotlin 的写法有点繁琐，这是因为 Kotlin 中没有 static 关键字，只能依靠伴生对象来实现，Java 中的写法则更加明了： public class MainActivity extends AppCompatActivity { ... static { System.loadLibrary(&quot;hellondk&quot;); } } 这里需要跟上一节中配置的名字相同，这样我们就可以在类中加载这个库了。 Java/Kotlin 调用 C/C++ 代码 首先定义一个 Native 方法： class MainActivity : AppCompatActivity() { ... private external fun sumByJNI(a: Int, b: Int): Int } 这时候『Android Studio』会给出提示说找不到 JNI 方法： 直接使用快捷键修复，『Android Studio』会自动在 src/main/cpp/native-lib.cpp 中创建对应的方法： #include &lt;jni.h&gt; #include &lt;string&gt; extern &quot;C&quot; JNIEXPORT jint JNICALL Java_com_example_hellondk_MainActivity_sumByJNI(JNIEnv *env, jobject thiz, jint a, jint b) { // TODO: implement sumByJNI() } 我们观察该方法，其中 JNIEXPORT 后面跟的是返回值，jint 表示的就是 Java 的整型，JNICALL 后面的方法名格式为 Java_$package_$class_$method()，参数的话可以看到我们本来是定义了 2 个，但这里生成了 4 个，前面两个 JNIEnv 和 jobject 是每个方法都会有的，后面的才是我们定义的参数。 实现上面的方法并回到 Java/Kotlin 中调用即可： class MainActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { ... val i: Int = sumByJNI(1, 2) } } C/C++ 调用 Java/Kotlin 代码 C/C++ 调用 Java/Kotlin 方法是通过反射来实现的，这也是其为什么会带来性能损耗。 这里我直接在上一小节的例子中扩展，上一小节中我们将两数相加的操作交给了 C/C++，这里我们从 C/C++ 中将其再交给 Java/Kotlin，相当于绕了一圈，实际开发并不会这样操作，作为示例理解即可。 在 Java/Kotlin 中定义方法： class MainActivity : AppCompatActivity() { ... private external fun sumByJNI(a: Int, b: Int): Int private fun sum(a: Int, b: Int) = a + b } 修改 C/C++ 中的实现： extern &quot;C&quot; JNIEXPORT jint JNICALL Java_com_example_hellondk_MainActivity_sumByJNI(JNIEnv *env, jobject thiz, jint a, jint b) { const char *className = &quot;com/example/hellondk/MainActivity&quot;; const char *methodName = &quot;sum&quot;; jclass jc = env-&gt;FindClass(className); jobject jo = env-&gt;AllocObject(jc); jmethodID methodId = env-&gt;GetMethodID(jc, methodName, &quot;(II)I&quot;); jint value = env-&gt;CallIntMethod(jo, methodId, a, b); return value; } 这里解释一下 GetMethodID() 方法的最后一个参数，它指要调用的 Java/Kotlin 方法的方法签名，即描述了该方法的参数和返回值，使用的是 CLASS 文件的字段描述符，即使你不熟悉但做应该也有见过，你可以在网上很轻松地查到相关的介绍，我们也可以直接使用命令对 CLASS 文件查看： ➜ javap -s MainActivity 反射的步骤其实与 Java/Kotlin 中差别不大，注意所有类都是以 j 开头，即代表 Java 对象。 后记 『Android Studio』推荐我们使用 CMake 配置 NDK 项目，整个流程走下来还是比较简单的，最难的地方也许是掌握 C/C++。 很多老项目还在使用 Makefile 来配置，如果后面有时间，再写写相关的笔记。 ","link":"https://LiarrDev.github.io/post/Build-up-Android-NDK-CMake-Project/"},{"title":"LeetCode 165. Compare Version Numbers","content":"题目 Compare Version Numbers 比较版本号 给你两个版本号 version1 和 version2，请你比较它们。 版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由多位数字组成，可能包含前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &lt; 1 。 返回规则如下： 如果 version1 &gt; version2 返回 1， 如果 version1 &lt; version2 返回 -1， 除此之外返回 0。 示例 1： 输入： version1 = &quot;1.01&quot;, version2 = &quot;1.001&quot; 输出： 0 解释： 忽略前导零，&quot;01&quot; 和 &quot;001&quot; 都表示相同的整数 &quot;1&quot; 示例 2： 输入： version1 = &quot;1.0&quot;, version2 = &quot;1.0.0&quot; 输出： 0 解释： version1 没有指定下标为 2 的修订号，即视为 &quot;0&quot; 示例 3： 输入： version1 = &quot;0.1&quot;, version2 = &quot;1.1&quot; 输出： -1 解释： version1 中下标为 0 的修订号是 &quot;0&quot;，version2 中下标为 0 的修订号是 &quot;1&quot; 。0 &lt; 1，所以 version1 &lt; version2 提示： 1 &lt;= version1.length, version2.length &lt;= 500 version1 和 version2 仅包含数字和 '.' version1 和 version2 都是有效版本号 version1 和 version2 的所有修订号都可以存储在 32 位整数中 题解 字符串分割 该方法非常简单，就是利用了 split() 方法，以 '.' 分割成数组，逐一比较两个数组位于同一下标中的整数值，如果当前下标超过数组的长度（即另一数组的长度已超过当前数组），则自动补 0，如此反复，直至得出结果或循环结束。 class Solution { fun compareVersion(version1: String, version2: String): Int { val arr1 = version1.split(&quot;\\\\.&quot;.toRegex()).toTypedArray() val arr2 = version2.split(&quot;\\\\.&quot;.toRegex()).toTypedArray() for (n in 0 until max(arr1.size, arr2.size)) { val i = if (n &lt; arr1.size) arr1[n].toInt() else 0 val j = if (n &lt; arr2.size) arr2[n].toInt() else 0 if (i &lt; j) { return -1 } else if (i &gt; j) { return 1 } } return 0 } } 时间复杂度：O(n+m)（或 O(max⁡(n,m))，这是等价的），其中 n 是字符串 version1 的长度，m 是字符串 version2 的长度。 空间复杂度：O(n+m)，我们需要 O(n+m) 的空间存储分割后的修订号列表。 双指针 字符串分割方法需要存储分割后的修订号，为了优化空间复杂度，我们可以在分割版本号的同时解析出修订号进行比较。 class Solution { fun compareVersion(version1: String, version2: String): Int { var index1 = 0 var index2 = 0 while (index1 &lt; version1.length || index2 &lt; version2.length) { var curr1 = 0 while (index1 &lt; version1.length &amp;&amp; version1[index1] != '.') { curr1 = curr1 * 10 + (version1[index1++] - '0') } index1++ var curr2 = 0 while (index2 &lt; version2.length &amp;&amp; version2[index2] != '.') { curr2 = curr2 * 10 + (version2[index2++] - '0') } index2++ if (curr1 != curr2) { return if (curr1 &lt; curr2) -1 else 1 } } return 0 } } 该方法相比字符串分割的方法看起来相对繁琐一点，但性能会更优。我们不再使用 split() 方法分割数组，而是遍历字符串中每一个字符来计算。 index1 和 index2 为当前处理的字符位于字符串 version1 和 version2 中的下标，遍历两个字符串，curr1 和 curr2 用来记录 '.' 分割的每一段的版本号，因为循环是从左往右读取，所以当超过 1 位数字的情况下对前一个结果乘 10 再相加，以此计算出该段的结果。 这里用了 version[index++] - '0' 这个写法可能不太好理解，实际上就是取当前字符的 ASCII 值进行运算，这算是一个取巧的设计，因为在 ASCII 中，0 到 9 也是连续的，所以只要当前字符与 '0' 相减，就可以得出该值的整型结果，而无需做 Char.digitToInt() 的转换。另外需要注意 index 是在该运算结束之后才执行自增操作。 当该小循环结束，也就意味着以 '.' 分割的该小段计算结束，index 再执行一次自增以跳过 '.' 字符等待下个大循环的计算。两个字符串都以此方式计算每一小段的结果，直至能够比较出结果为止。 时间复杂度：O(n+m)，其中 n 是字符串 version1 的长度，m 是字符串 version2 的长度。 空间复杂度：O(1)，我们只需要常数的空间保存若干变量。 ","link":"https://LiarrDev.github.io/post/Leetcode-165-Compare-Version-Numbers/"},{"title":"Java 使用 Media Type 校验文件类型","content":"前言 之前『利用 Magic Number 校验文件类型』一文讲解了校验文件类型的原理，并在文末给出了示例代码。但是每次去查询 Magic Number 对照表有点麻烦，于是我找了一些能够判断文件类型的三方库，可以省不少事儿。 作为开发者你应该知道，在 HTTP 协议消息头中，使用 Content-Type 来表示请求和响应中的媒体类型信息。这个字段在不同场景下有几种叫法，Content Type、Media Type、MIME Type，严格来说这几个名称并不完全对等，但在这里我们暂不做区分，大家明白意思就行。 它用来告诉服务端如何处理请求的数据，以及告诉客户端如何解析响应的数据。 因此我们可以通过这个值来判断文件类型。 URLConnection URLConnection 是 JDK 自带的类，它相当于 URL 资源与应用程序之间的桥梁。它是一个抽象类，我们熟知的 HttpURLConnection 就是它的子类。 public class FileMatcher { private static final String MIME_TYPE_PNG = &quot;image/png&quot;; public static boolean isPng(File file) { FileInputStream fis = null; try { fis = new FileInputStream(file); String mime = URLConnection.guessContentTypeFromStream(fis); return MIME_TYPE_PNG.equals(mime); } catch (IOException e) { return false; } finally { try { if (fis != null) { fis.close(); } } catch (IOException e) { e.printStackTrace(); } } } } 通过 guessContentTypeFromStream() 方法获取流的 Content Type，再与对应的 Media Type 比较即可。 另外 URLConnection 还有一个 guessContentTypeFromName() 方法，是根据文件名来判断，也就是之前说的通过文件扩展名，这种方法并不可靠，但是速度会快一些。 jMimeMagic jMimeMagic 是一个用于确定文件或数据流的 MIME Type 的 Java 库。 添加依赖： dependencies { implementation 'net.sf.jmimemagic:jmimemagic:0.1.5' } 逻辑代码： public class FileMatcher { private static final String MIME_TYPE_PNG = &quot;image/png&quot;; public static boolean isPng(File file) { try { MagicMatch match = Magic.getMagicMatch(file, false); String mime = match.getMimeType(); return MIME_TYPE_PNG.equals(mime); } catch (MagicParseException | MagicMatchNotFoundException | MagicException e) { return false; } } } 可惜的是该库的上一次更新还停留在 2017 年。 Apache Tika Core Apache Tika 工具包可检测和提取上千种不同文件类型中的元数据和文本。 依赖核心库即可： dependencies { implementation 'org.apache.tika:tika-core:2.8.0' } 逻辑代码： public class FileMatcher { private static final String MIME_TYPE_PNG = &quot;image/png&quot;; public static boolean isPng(File file) { Tika tika = new Tika(); try { String mime = tika.detect(file); return MIME_TYPE_PNG.equals(mime); } catch (IOException e) { return false; } } } 有 Apache 做背书，只能说稳得一匹。 后记 可以看到，这几种方法都是通过读取数据流的方式来校验文件类型，和之前『利用 Magic Number 校验文件类型』介绍的原理是一致的，同时由于这几种方法都能够处理数据流，所以并非只能传入 File，在网络传输数据流时也能够很方便地进行校验。 ","link":"https://LiarrDev.github.io/post/Verify-File-Types-with-Media-Type-in-Java/"},{"title":"利用 Magic Number 校验文件类型","content":"前言 将线上打包系统开放给业务部门后，常常能收到打包失败的邮件，排查后发现大多数是因为业务部门人员在上传应用图标时都上传了 JPG 格式的图片，而 Android 中要求应用图标必须为 PNG 格式。 出现这种情况大概率是业务人员和设计部门直接通过微信发送文件，导致文件格式在传输过程中发生了变更。 与业务部门说明后发现效果仍无改善，遂与 Web 端同事沟通，限制应用图标的上传格式为 PNG。重新部署后，打包失败率下降了，但偶尔还是会有相同的原因导致打包失败，于是再次排查原因。 排查后发现，业务人员确实是上传的 .png 为后缀的文件，但实际上这个文件却仍旧是 JPG 格式。询问 Web 端同事收到的答复是仅在上传时限制了文件后缀。 这种方法肯定是不合理的，今天就来讲讲文件格式的判断。 Filename Extension 我们最初接触计算机时，就习惯把文件后缀叫做文件类型，文件后缀正确的叫法应该是文件扩展名（Filename Extension），它是早期操作系统用来标志文件格式的一种机制，更重要的作用是让系统决定运行该文件的应用。 也就是说，这是开发者和操作系统之间的一种约定，与文件的实际类型并没有绝对关系。 文件头 那么操作系统根据什么来判断文件类型呢？ 答案是文件头。 文件头是位于文件开头的一段承担一定任务的数据，一般都在开头的部分。 许多文本编辑器都可以查看文件的十六进制数据，你也可以使用『WinHex』或者『Hex Fiend』等工具查看： 位于开头的部分数据就是文件头。 当然有的文件没有文件头，比如 TXT。 文件头包含的信息可以很丰富，比如图片类型的文件就可以将图像的尺寸等信息放在文件头，那么图像浏览软件就可以识别出具体参数。 Magic Number 文件头可以判断文件类型，但这也说得太笼统，因为文件头可以包含一些其他的信息。而真正用来判断文件类型的，是 Magic Number。 Magic Number 可以翻译为幻数，它是一些文件格式规范所要求的特殊标签值，表示文件符合这种规范。 Magic Number 的取值往往很随意，这也是为什么它叫 Magic Number 🤣。但也有一些 Magic Number 在选择时添加了一些风趣的元素。比如 Java 中的 CLASS 文件头十六进制幻数为 CA FE BA BE，着实把咖啡 ☕ 玩明白了；MS-DOS 的可执行文件（比如 EXE）的幻数为 4D 5A，对应 ASCII 结果为 MZ，是 MS-DOS 架构师 Mark Zbikowski 的名字缩写；同样使用名字缩写的还有 ZIP 文件，幻数为 50 4B 03 04，前两位对应 ASCII 结果为 PK，是 PKZIP 算法发明者 Phil Katz 的名字缩写。 常见 Magic Number 对照表 List of file signatures GCK'S FILE SIGNATURES TABLE 匹配校验 有了以上的了解，就可以很轻松地写出校验代码。以 Java 为例： public class FileMatcher { private static final String MAGIC_NUMBER_PNG = &quot;89504E470D0A1A0A&quot;; public static boolean isPngFile(File file) { byte[] bytes = fileToBytes(file); if (bytes == null) { return false; } String hex = bytesToHex(bytes); if (hex == null) { return false; } return hex.startsWith(MAGIC_NUMBER_PNG); } private static byte[] fileToBytes(File file) { FileInputStream fis = null; ByteArrayOutputStream bos = null; try { fis = new FileInputStream(file); bos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = fis.read(buffer)) != -1) { bos.write(buffer, 0, bytesRead); } return bos.toByteArray(); } catch (IOException e) { e.printStackTrace(); return null; } finally { try { if (fis != null) { fis.close(); } if (bos != null) { bos.close(); } } catch (IOException e) { e.printStackTrace(); } } } private static String bytesToHex(byte[] src) { StringBuilder sb = new StringBuilder(); if (src == null || src.length == 0) { return null; } String hex; for (byte b : src) { hex = Integer.toHexString(b &amp; 0xFF).toUpperCase(); if (hex.length() &lt; 2) { sb.append(0); } sb.append(hex); } return sb.toString(); } } 逻辑很简单，分三步走： 获取文件的字节数组。 把字节数组转为十六进制字符串。 将十六进制字符串前面一定位数与 Magic Number 做比较。 转换的代码相信大家的项目里基本都有封装，所以实际写的代码就几行罢了。 后记 通过 Magic Number 校验文件类型在大多数情况下是可行的，但许多工具同时也提供了篡改文件头的功能，比如『WinHex』。 还需要注意的是不同文件扩展名的 Magic Number 有可能相同，比如 APK 和 ZIP，因为 APK 本身就是以 ZIP 格式压缩的，所以根据实际应用场景可以结合多种方案判断。 ","link":"https://LiarrDev.github.io/post/Verify-File-Types-with-Magic-Number/"},{"title":"Android 沉浸式效果","content":"市面上很多 App 启动的时候都有一个几秒钟启动页，可以用来放一些广告，或者做一些宣传自家品牌的内容，而且是沉浸式效果，看起来十分舒服。 那么今天就来聊聊沉浸式的实现。 什么是沉浸式 估计问十个人会有十个回答，很多人都说不上到底什么才是沉浸式，原因是国内许多博客都张冠李戴说什么沉浸式状态栏或者沉浸式效果之类的名词，让人摸不着头脑。 Android 官方从来没有给出过沉浸式状态栏这样的命名，只有沉浸式模式（Immersive Mode）这种说法，不过倒是有部分国内的 ROM 给出了「沉浸式状态栏」这种设置。 所以实际上「沉浸式状态栏」可以理解为透明状态栏，而真正的「沉浸式模式」则是如游戏或视频状态下的全屏效果。 整个屏幕显示都是游戏的内容，没有状态栏也没有导航栏，用户玩游戏的时候就可以完全沉浸在游戏当中，而不会被一些系统的界面元素所打扰，这就是沉浸式模式。 界面元素 要实现沉浸式，首先要了解界面上有哪些元素是需要隐藏的，来看看这张图： 可以看到，有状态栏、ActionBar、导航栏等。而打造沉浸式模式的用户体验，就是要将这些系统元素全部隐藏，只留下主体内容部分。 实践 布局 启动页很多情况下是一张图片，我从『网易云音乐』中偷了一张图，布局很简单： &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.activity.SplashActivity&quot;&gt; &lt;androidx.appcompat.widget.AppCompatImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@drawable/splash_bg&quot; /&gt; &lt;/FrameLayout&gt; 初始效果如下： 隐藏 ActionBar 隐藏 ActionBar 是项目中常用的场景，我们可以在指定其 android:theme 为 NoActionBar 类型的主题，也可以在逻辑代码中动态隐藏： class SplashActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { ... supportActionBar?.hide() } } 效果如下： 隐藏状态栏 接下来是隐藏状态栏，我通过重写 onWindowFocusChanged() 方法来实现： class SplashActivity : AppCompatActivity() { ... override fun onWindowFocusChanged(hasFocus: Boolean) { ... window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_FULLSCREEN } } 这里先获取到了当前界面的 DecorView，然后调用它的 setSystemUiVisibility() 方法来设置系统 UI 元素的可见性。其中，SYSTEM_UI_FLAG_FULLSCREEN 表示全屏的意思，也就是会将状态栏隐藏。效果如下： 另外，根据 Android 的设计建议，ActionBar 是不应该独立于状态栏而单独显示的，因此状态栏如果隐藏了，则要确保 ActionBar 也进行了隐藏。 透明状态栏 那如果想实现所谓的「沉浸式状态栏」呢？ 上面提到，所谓的「沉浸式状态栏」实际上是透明状态栏，我们可以借助另外一种 UI FLAG 来实现： class SplashActivity : AppCompatActivity() { ... override fun onWindowFocusChanged(hasFocus: Boolean) { ... window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN or View.SYSTEM_UI_FLAG_LAYOUT_STABLE window.statusBarColor = Color.TRANSPARENT } } 要实现这种效果，修改为 SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN，表示会让应用的主体内容占用系统状态栏的空间，网上有文章提到需要结合 SYSTEM_UI_FLAG_LAYOUT_STABLE 一起使用，但我测试发现似乎不需要也能实现该效果，不知道是不是版本问题。 主体内容占用状态栏的空间还不够，因为此时状态栏依然有着色，我们再将其置为透明即可。 透明导航栏 其实导航栏在不同手机上是不一定存在的，比如小米早期的手机，底部的三大金刚键是不在屏幕范围内的，而华为早期的一些手机则是在屏幕内，近几年手势全面屏的普及，又可以由用户自己决定是否显示三大金刚键，所以只有在屏幕内的才叫导航栏。 透明导航栏和透明状态栏的实现方式相似： class SplashActivity : AppCompatActivity() { ... override fun onWindowFocusChanged(hasFocus: Boolean) { ... window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION window.navigationBarColor = Color.TRANSPARENT } } 使用 SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION 使应用主体内容占用导航栏位置，并将导航栏设置为透明色。 隐藏导航栏 隐藏导航栏的实现方式和上面相似，也是使用不同的 UI FLAG： class SplashActivity : AppCompatActivity() { ... override fun onWindowFocusChanged(hasFocus: Boolean) { ... window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION or View.SYSTEM_UI_FLAG_FULLSCREEN } } 同时使用 SYSTEM_UI_FLAG_FULLSCREEN 和 SYSTEM_UI_FLAG_HIDE_NAVIGATION 可以实现将状态栏和导航栏一起隐藏。这种方式虽然看上去好像是全屏化了，但会有个问题，我们触摸屏幕的任意位置或边缘划动会退出全屏，使状态栏和导航栏显示出来，并且无法再次隐藏： 这显然不是我们想要的效果，因此这种模式的使用场景比较有限。 沉浸式 如何才能实现真正的沉浸式效果呢？ 同样，还是继续组合 UI FLAG： class SplashActivity : AppCompatActivity() { ... override fun onWindowFocusChanged(hasFocus: Boolean) { ... window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION or View.SYSTEM_UI_FLAG_FULLSCREEN or View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY } } 触摸屏幕并不会退出全屏，且仅在屏幕边缘向中央划动的时候才会呼出状态栏和导航栏，如无操作则在几秒后折叠，重新回到全屏，很符合我们平时玩游戏或看视频时的操作。 不过，网上的博客在介绍这种方式的时候通常会用到 6 种 UI FLAG： class SplashActivity : AppCompatActivity() { ... override fun onWindowFocusChanged(hasFocus: Boolean) { ... window.decorView.systemUiVisibility = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION or View.SYSTEM_UI_FLAG_FULLSCREEN or View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION or View.SYSTEM_UI_FLAG_LAYOUT_STABLE or View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN } } 为何只需 3 个 UI FLAG 组合就能实现的效果，大家都选用将这 6 个同时写入呢？ 经过各种我想到的情况进行测试，终于找到了区别，当我们长按 POWER 键的时候，会有如下不同： 长按 POWER 键会弹出一个菜单遮挡在最顶部，同时该界面会短暂退出沉浸式，仅使用三种 UI FLAG 的时候状态栏和导航栏将显示为默认状态，而使用六种 UI FLAG 的时候状态栏和导航栏将会显示为透明状态，不用我说你也知道，透明状态交互会更加友好。 ","link":"https://LiarrDev.github.io/post/Android-Immersive-Effects/"},{"title":"Android 剪贴板的简单使用","content":"很多 App 现在都会用到一键复制或者一键粘贴的功能，比如『淘宝』，支持一键复制物流单号，也支持直接从剪贴板中读取所复制的淘口令。 一键复制和一键粘贴的操作如何实现呢？ Android 为我们提供了剪贴板框架，允许复制和粘贴不同类型的数据，比如文本、图像、二进制流数据或者其他复杂的数据类型，另外，它还支持复制多条记录，很多输入法都实现了多条记录的剪贴板，功能很强大。 当然，最常用的还是对文本进行操作啦，那就介绍一下复制和粘贴文本的实现方法。 复制实现如下： fun copyText(text: CharSequence) { val cm = context.getSystemService(CLIPBOARD_SERVICE) as ClipboardManager cm.setPrimaryClip(ClipData.newPlainText(context.packageName, text)) } 无论是复制还是粘贴，都离不开 ClipboardManager 这个剪贴板管理服务，通过 newPlainText() 静态方法创建 ClipData 对象，再通过 setPrimaryClip() 方法传给 ClipboardManager 即可，newPlainText() 方法接收两个参数，分别是 label 和 text，通常情况下我们只需要设置 text 即可，它是我们需要复制的文本，而 label 一般不会与用户打交道，更多是用于开发者的标记。 粘贴实现如下： fun getText(): CharSequence { val cm = context.getSystemService(CLIPBOARD_SERVICE) as ClipboardManager cm.primaryClip?.let { if (it.itemCount &gt; 0) { return it.getItemAt(0).coerceToText(context) } } return &quot;&quot; } 既然复制是将文字封装成 ClipData 传给 ClipboardManager，那么粘贴则是反过来，也就是从 ClipboardManager 中取出 ClipData 并解析出文字，这里需要注意判空，避免空指针异常或者数组越界，一般情况下我们只会用到剪贴板第一条数据，获取之后调用 coerceToText() 转换成文字，因为剪贴板除了文字外还支持 URI 等类型，这个方法可以帮我们一并处理。 像『淘宝』就是每次 App 回到前台时就获取一次剪贴板，如果是淘口令则执行对应的操作。 这篇文章本来到这里就该结束了，但我突然发现了一个新功能： 其实 ClipboardManager 提供了监听剪贴板的方法： fun addClipChangedListener() { val cm = context.getSystemService(CLIPBOARD_SERVICE) as ClipboardManager cm.addPrimaryClipChangedListener { val text = getText() ... } } 但是回调中并没有返回最新的内容，仍需自行获取。 ","link":"https://LiarrDev.github.io/post/Simple-Use-of-the-Android-Clipboard/"},{"title":"Android 解决 TEST_ONLY 应用无法安装的问题","content":"最近拿了同事的 OPPO A5 过来测试，发现直接用『Android Studio』的「Run 'app'」不能够把应用安装到手机上，系统的应用包安装程序会显示「安装失败」： 『Android Studio』底部的「Run」选项卡会提示以下信息： Installation did not succeed. The application could not be installed: INSTALL_FAILED_TEST_ONLY Installation failed due to: 'null' 翻阅官方文档后发现如下信息： android:testOnly Indicates whether this application is only for testing purposes. For example, it may expose functionality or data outside of itself that would cause a security hole, but is useful for testing. This kind of APK can be installed only through adb — you cannot publish it to Google Play. Android Studio automatically adds this attribute when you click Run. 指示此应用是否仅用于测试目的。例如，它可能会在自身之外公开功能或数据，这样会导致安全漏洞，但对测试很有用。此类 APK 只能通过 adb 安装，您不能将其发布到 Google Play。 当您点击 Run 图标 时，Android Studio 会自动添加此属性。 可以看到，当 Run 程序后，『Android Studio』会自动在 Debug APK 的 AndroidManifest 中添加 android:testOnly=&quot;true&quot; 属性，部分手机检测到该属性后会拒绝安装。 但是通过「Build」→「Build Bundles(s) / APK(s)」→「Build APK(s)」生成的 Debug APK 却不会有这种情况。 据网上大量文章讲述，这是『Android Studio』3.0 后的版本会出现的情况，关于这点我在官方文档没有找到具体说明，无从考证。 既然如此，那我强制把这个属性写成 false 不就可以了吗： &lt;application ... android:testOnly=&quot;false&quot;&gt; ... &lt;/application&gt; 结果却发现，依然无法正常安装。 网上提到，可以使用 ADB 命令来安装： ➜ adb install -t app-debug.apk 很多博主都说这个方法可以，但我测试发现不行，不知是否为个例。 最终方法，在「gradle.properties」文件中加入如下代码： android.injected.testOnly=false 问题得以解决。 后来我换过不同的电脑和项目后发现，有时候该设置未必会生效，反编译 APK 文件看到 android:testOnly 属性仍未被移除，于是顺手写了个脚本来实现该操作并重新打包，流程可以参考之前的『Android 反编译入门指南』。 在调试应用这一块，以我目前测试过的手机来说，OPPO 和 vivo 可以称之为重灾区，vivo 的情况甚至比 OPPO 更加严重，据说还有联系客服开通调试权限等等的骚操作，实属无语。 ","link":"https://LiarrDev.github.io/post/Android-App-Install-Failed-Test-Only/"},{"title":"macOS iTerm2 美化配置笔记","content":"一直听闻『iTerm2』号称是 macOS 平台下的第一终端，今日浅尝一下。 本文仅仅是我个人的配置笔记，而不是关于『iTerm2』的推荐，所以如果你问我为什么要用『iTerm2』而不是其他终端工具，那么你大概率并不真正的需要它，因为我也是。 不过你倒是可以前往官网看看它有哪些功能，也许就会有答案。 接下来开始配置。 iTerm2 如果你习惯使用『Homebrew』，那么最简单的方法是： ➜ brew install iTerm2 不过我还是喜欢下载安装，官网也提供了安装包。 Oh My Zsh 现在 macOS 默认的 Shell 已经是 zsh 了，但是默认的 zsh 配置起来比较麻烦，而开源的『Oh My Zsh』提供了大量的插件和主题，帮你轻松解决。 通过 curl 安装： ➜ sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 也可以通过 wget 安装： ➜ sh -c &quot;$(wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot; Powerline fonts 『Oh My Zsh』的一些主题使用了特殊字体，如果没有安装字体的话就会乱码，我们通过安装 Powerline 字体解决。 你可以直接去 Github 上手动下载安装，但命令的方式更加便捷。 下载： ➜ git clone https://github.com/powerline/fonts.git --depth=1 安装： ➜ cd fonts ➜ ./install.sh 清理一下： ➜ cd .. ➜ rm -rf fonts 如果你哪天不想用了，也可以用命令快速卸载： ➜ cd fonts ➜ ./uninstall.sh 安装完成后，在『iTerm2』中设置为对应的字体。 Color Schemes 『iTerm2』内置了几套配色，可以直接设置。 如你所见，它支持自定义配色。 不过你要是懒人伸手党，可以下载现成的配色方案。 iTerm2 Color Schemes 这是一套适用于大多数终端的颜色主题，内置了有将近 300 款配色。你可以在网站上挑选喜欢的配色单独下载，也可以打包下来慢慢挑选。 iTerm2 One Dark Theme 因为我的『Android Studio』配色是使用 One Dark，所以特意也导入了相同的配色到『iTerm2』中。 导入 下载的配色导入也很方便，在「Import」中选择对应的 .itermcolors 文件即可。 主题 『Oh My Zsh』内置了大量主题，我们可以通过以下命令查看： ➜ ls ~/.oh-my-zsh/themes 但你肯定一脸懵逼，这么多主题，每个主题都长什么样？ 可以进入『Oh My Zsh』项目 Wiki 查看。 选到喜欢的主题后，记住名字，再到 .zshrc 文件进行修改。如果你习惯使用命令可以直接 vim，否则直接打开文件修改或许是一个不容易出错的方式。 找到 ZSH_THEME，修改为你喜欢的主题，比如： ZSH_THEME=&quot;agnoster&quot; 如果你喜欢几个主题，那么可以修改 ZSH_THEME_RANDOM_CANDIDATES 让它随机切换： ZSH_THEME_RANDOM_CANDIDATES=( &quot;robbyrussell&quot; &quot;agnoster&quot; ) 如果你对所有主题都很喜欢，那就让它随机吧： ZSH_THEME=&quot;random&quot; 如果内置的主题不合你心意，官方也收录了一些第三方的主题，同样可以在项目 Wiki 中找到，根据喜好安装即可。 插件 zsh-syntax-highlighting 默认的终端纯色文字太影响阅读，这个插件能为我们提供语法高亮。它可以在 zsh 的提示符下将命令高亮显示在交互式终端中。这有助于在运行命令前对其进行审查，特别是在捕捉语法错误方面。 通过『Homebrew』安装： ➜ brew install zsh-syntax-highlighting 安装完成后，终端会显示安装路径，将其复制并追加到 .zshrc 文件末尾： source /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh zsh-autosuggestions 我们平时写代码习惯了代码提示，那么终端为什么不能有一个？这个插件能在你打字时根据历史记录和完成情况建议命令。 同样使用『Homebrew』安装： ➜ brew install zsh-autosuggestions 将路径追加到 .zshrc 文件末尾： source /opt/homebrew/share/zsh-autosuggestions/zsh-autosuggestions.zsh 与平时我们在 IDEA 使用 Tab 或者 Enter 键接受代码提示不同，该插件使用方向键 → 或者 End 来接受命令建议。 Status Bar 我习惯在运行任务时关注系统的资源占用情况，『iTerm2』允许配置 Status Bar。 根据自己的需要配置即可。 最终效果 其实可以配置的项目很多，我只是把我习惯使用的记录下来，其他的就留给你们自行发挥吧。 注意事项 配置完之后你可能会发现之前的环境变量失效了，因为 .zshrc 已被『Oh My Zsh』更改，需要重新配置。 具体配置方法之前在『macOS 环境变量配置』一文已经讲过。 如果你已经忘记之前配置过什么环境变量也不要慌，『Oh My Zsh』贴心地给我们生成了一个 .zshrc.pre-oh-my-zsh 文件，里面保存着之前配置过的内容，复制到 .zshrc 即可。 另外，相关的配置也会影响到系统自带的『Terminal』，比如字体等，所以如果仍需使用『Terminal』，则需要参照上文『iTerm2』的配置在『Terminal』中也修改一下。 ","link":"https://LiarrDev.github.io/post/macOS-iTerm2-Beautifying-Configuration/"},{"title":"macOS 环境变量配置","content":"各位程序员小伙伴都知道，环境变量的配置在开发中极为重要，尽管现在许多构建工具已经帮我们解放了我们手动配置的操作，但如果我们想要提高效率，环境变量仍然十分重要。 Windows 平台的环境变量配置在之前的文章中已多次提及，而很多刚从 Windows 平台切换到 macOS 的开发者们因为找不到一个可操作的入口，顿时觉得无所适从。 因为 macOS 配置环境变量是没有像 Windows 一样的 GUI 窗口，而是基于命令操作的。 很多人听到命令操作就头皮发麻，没关系，今天教你用最少的命令，用可视化的操作来配置。 目前你在网上搜到的大多数教程其实是过时的，因为在 macOS Mojave 及之前的版本中，系统默认的 Shell 是 bash，而之后的版本默认的 Shell 已经改为 zsh，我发现甚至到了 2022 年 macOS Ventura 发布后，许多教程依然基于 bash 来讲解，多少有些落后。 首先我们确认一下当前系统使用的是哪个 Shell，打开『Terminal』窗口，即可在顶部查看： 当然你也可以使用命令来查看： ➜ echo $SHELL 假如你当前的 Shell 并不是 zsh，我建议你也切换到 zsh。 可以通过以下命令查看当前支持的 Shell： ➜ cat /etc/shells 将 Shell 环境切换至 zsh： ➜ chsh -s /bin/zsh 接下来键入： ➜ vim ~/.zshrc 『Terminal』会进入编辑模式，你可以使用命令继续操作，但为了简单，可以直接输入 :wq 退出编辑。 以上这条命令会操作 Home 目录下的「.zshrc」文件，假如本地没有这个文件，也会自动帮你生成，由于该文件属于隐藏文件，所以你应当显示隐藏文件才能看到它。 而退出编辑模式后，我们直接使用文本编辑器打开「.zshrc」文件，将我们的环境变量配置到该文件即可，格式如下： # Java export JAVA_HOME=&quot;/Applications/Android Studio.app/Contents/jre/Contents/Home&quot; PATH=&quot;$PATH:$JAVA_HOME/bin&quot; # Android export ANDROID_PLATFORM_TOOLS=&quot;/Users/liarr/Library/Android/sdk/platform-tools&quot; PATH=&quot;$PATH:$ANDROID_PLATFORM_TOOLS&quot; 其中 # 开头的行为注释，export 后面声明变量，而 PATH 指定的的就是环境变量对应的路径。 编辑完成后保存该文件，回到『Terminal』，执行： ➜ source ~/.zshrc 环境变量即可生效。 我们可以通过以下命令查看已经配置的环境变量： ➜ echo $PATH 以上就是 macOS 环境变量配置的操作，把命令相关步骤忽略后，无非就是文本的编辑操作，而命令也不过是辅助我们配置的工具罢了。 ","link":"https://LiarrDev.github.io/post/How-to-Set-Environment-Variables-in-macOS/"},{"title":"通过 ADB 查询 SQLite 数据库","content":"之前在『一次实战爱上「LitePal」』的文末介绍了如何通过『Android Studio』导出数据库文件到本地查看的方法，但是在对接硬件设备的时候我发现，有些厂家的板子在『Android Studio』上无法正常展示文件目录： 网上的很多方案都提及使用『SuperSU』来解决，我尝试后无果，为了不浪费宝贵的开发时间，于是转用 ADB 来查看数据库，特此记录。 ADB 的环境配置之前已经讲过，不再赘述。 首先进入 Shell 环境： ➜ adb shell 然后进入到对应的数据库目录： ➜ adb shell ➜ cd /data/data/&lt;package_name&gt;/databases 这个目录相信做 Android 开发都不陌生了，数据库都存放在该应用的相应目录下。 可以先看看目录下有哪些数据库： ➜ adb shell ➜ cd /data/data/&lt;package_name&gt;/databases ➜ ls 接下来打开要查看的数据库： ➜ adb shell ➜ cd /data/data/&lt;package_name&gt;/databases ➜ sqlite3 &lt;db_name&gt; 通过 sqlite3 命令打开数据库，即可执行相关的数据库操作，比如查看当前数据库内所有的表： ➜ adb shell ➜ cd /data/data/&lt;package_name&gt;/databases ➜ sqlite3 &lt;db_name&gt; ➜ .table 查看数据库建表语句： ➜ adb shell ➜ cd /data/data/&lt;package_name&gt;/databases ➜ sqlite3 &lt;db_name&gt; ➜ .schema 或者执行 SQL 语句： ➜ adb shell ➜ cd /data/data/&lt;package_name&gt;/databases ➜ sqlite3 &lt;db_name&gt; ➜ SELECT * FROM &lt;table_name&gt;; 这里要注意，SQL 语句的最后记得不要把 ; 符号落下。 执行完之后可以通过 .exit 命令退出数据库： ➜ adb shell ➜ cd /data/data/&lt;package_name&gt;/databases ➜ sqlite3 &lt;db_name&gt; ➜ .exit 也可以用 .quit： ➜ adb shell ➜ cd /data/data/&lt;package_name&gt;/databases ➜ sqlite3 &lt;db_name&gt; ➜ .quit 此时依然处于 Shell 环境中。 如果想要退出 Shell 环境，再执行 exit 命令即可： ➜ adb shell ➜ cd /data/data/&lt;package_name&gt;/databases ➜ sqlite3 &lt;db_name&gt; ➜ .quit ➜ exit 注意此命令与上面退出数据库的命令是不一样的，退出 Shell 不需要加 . 符号。 ","link":"https://LiarrDev.github.io/post/Query-the-SQLite-Database-with-ADB/"},{"title":"你的 Log 被截断了吗？","content":"为了方便调试，许多开发者都会习惯用 Log 打印网络请求响应的内容，而不是使用其他工具。 但是在打印日志时，你可能会遇到日志显示不完整的情况，比如响应的 JSON 数据在中间被截断了。 有人可能会认为是字符串超长的问题，不过回想『Java String 长度限制』就可以判断出这个问题并不是由于 String 的长度限制导致的，那就只能是 Android 的 Log 限制。 从 Android 内核源码来看，有以下宏定义： #define LOGGER_ENTRY_MAX_LEN (4*1024) #define LOGGER_ENTRY_MAX_PAYLOAD (LOGGER_ENTRY_MAX_LEN - sizeof(struct logger_entry)) Android 系统对日志长度有限制，最大长度为 4K，超过这个范围的自动截断，所以就会出现打印不全的情况。 既然一次只能打印 4K 长度的信息，那很容易想到将待打印的信息拆分成一个个信息段，然后分别打印即可。 实际测试发现，日志的最大长度其实略小于 4*1024。为了保险起见，可以设置每一段日志长度为 3*1024。如果待打印的字符串信息长度小于等于 3*1024，则直接打印即可，否则将日志信息截断为一段一段分别打印。 public class LogUtil { private static final int LOGGER_MAX_LENGTH = 3 * 1024; public static void i(@NonNull String tag, @NonNull String msg) { if (msg.length() &gt; LOGGER_MAX_LENGTH) { while (msg.length() &gt; LOGGER_MAX_LENGTH) { Log.i(tag, msg.substring(0, LOGGER_MAX_LENGTH)); msg = msg.substring(LOGGER_MAX_LENGTH); } } Log.i(tag, msg); } } 一般情况下会对日志工具类做了封装，可参考之前『定制 Android 日志工具』一文做组合使用。 ","link":"https://LiarrDev.github.io/post/Has-Your-Log-been-Truncated/"},{"title":"去除字符串首尾的双引号","content":"之前『WebView 获取 JavaScript 不同类型返回值的注意事项』一文中提到了当返回类型为字符串时，系统会自动给字符串首尾加上双引号 &quot;，那我们使用的时候当然就要把这个多余的双引号给去掉。 今天就来讲讲去除字符串首尾双引号的几种方法。 直接替换 最简单的方式，就是直接利用 String 类的 replace() 方法直接替换双引号： fun String.trimQuotes() = this.replace(&quot;\\&quot;&quot;, &quot;&quot;) 但是此方法十分不推荐，因为它有重大缺陷，当这个字符串内本身就有双引号时（比如 JSON 字符串），也会被替换掉。 所以使用时你需确保字符串内除最外层的多余双引号外任何位置都不包含双引号。 Kotlin 扩展函数 我们知道 Java 中有一个常用的方法 trim()，可以去除字符串首尾的空白字符。Kotlin 给 String 添加了一个带参数的扩展函数： /** * Returns a string having leading and trailing characters from the [chars] array removed. */ public fun String.trim(vararg chars: Char): String = trim { it in chars } 那我们就可以利用这个扩展函数实现： fun String.trimQuotes() = this.trim('\\&quot;') 该方法虽然方便，但我同样不推荐。 回想 Java 中的 trim() 方法，它会清除掉前后的所有空白字符，Kotlin 的该扩展函数也是一样，它会清除掉字符串首尾的所有给定字符，即如果你的字符串本身除了本应去除的双引号外，首尾仍有双引号的话，也会被清除掉。 所以使用时你需确保字符串内头尾除最外层的多余双引号外都不包含双引号。 Guava Kotlin 虽然香，但很多 Java 项目因为各种原因不能轻松接入。不怕，我们还有 Guava，它是来自 Google 的核心 Java 库，是对 Java API 的补充。 private String trimQuotes(String s) { return CharMatcher.is('\\&quot;').trimFrom(s); } 看到该方法的名字就知道，它与上方的 Kotlin 扩展函数一样，师出同源，所以也同样需要确保字符串内头尾除最外层的多余双引号外都不包含双引号。 正则 难道就没有仅仅裁剪最外层双引号的方法了吗？ 别慌，我们还有正则！ fun String.trimQuotes() = this.replace(&quot;^\\&quot;|\\&quot;$&quot;.toRegex(), &quot;&quot;) 同样是利用 String 类的 replace() 方法，只需要加上正则表达式去匹配首尾的双引号，就能避免上面的问题。 总结 本文介绍了 4 种去除字符串首尾的双引号的方法，由简入繁，前面的方法虽然简单，但需要考虑实际使用场景，正则能够完美实现需求，但是对于许多开发者来说仍有一定门槛。 开发过程中可以合理选择对应的方法，只要能确保使用时不会触发到上方的注意事项，那用最简单的方法同样能够提高效率。 ","link":"https://LiarrDev.github.io/post/Trim-Quotes-from-Head-and-Tail-of-a-String/"},{"title":"WebView 处理 JavaScript 不同类型返回值的注意事项","content":"之前在『Android WebView 和 JavaScript 交互』一文中留了一个坑没填，就是当 Android 调用 JavaScript 获取返回值时，返回值是字符串与否也会有不同的情况。 有人可能就有疑惑了，因为文章也同样提到，返回值本身就被限定为 String 类型。 没错，evaluateJavascript() 方法中的 ValueCallback 本身就做了泛型的限定： @Widget public class WebView extends AbsoluteLayout implements ViewTreeObserver.OnGlobalFocusChangeListener, ViewGroup.OnHierarchyChangeListener, ViewDebug.HierarchyHandler { ... public void evaluateJavascript(@NonNull String script, @Nullable ValueCallback&lt;String&gt; resultCallback) { checkThread(); mProvider.evaluateJavaScript(script, resultCallback); } } 那么，假如返回值不为字符串时，会返回什么呢？我们可以动手尝试一下。 比如同样是『Android WebView 和 JavaScript 交互』一文中的例子： &lt;html&gt; &lt;script type=&quot;text/javascript&quot;&gt; function sum(m, n) { return m + n } &lt;/script&gt; ... &lt;/html&gt; class WebActivity : AppCompatActivity() { ... private fun checkInt() { webView.evaluateJavascript(&quot;sum(3, 2)&quot;) { result -&gt; Log.d(TAG, result) // Log: 5 } } } 我们用 Log 打印出来是 5，记住它不是数字 5，而是一个字符串，即 result = &quot;5&quot;。 再来看看布尔类型： &lt;html&gt; &lt;script type=&quot;text/javascript&quot;&gt; function checkBoolean() { return true } &lt;/script&gt; ... &lt;/html&gt; class WebActivity : AppCompatActivity() { ... private fun checkBoolean() { webView.evaluateJavascript(&quot;checkBoolean()&quot;) { result -&gt; Log.e(TAG, result) // Log: true } } } 我们用 Log 打印出来是 true，记住它不是布尔值 true，而是一个字符串，即 result = &quot;true&quot;。 接下来看看对象，用之前在『Android 获取 WebView 选区位置』也有类似的例子： &lt;html&gt; &lt;script type=&quot;text/javascript&quot;&gt; function checkObj() { var json = {}; json.name = &quot;json&quot;; return json } &lt;/script&gt; ... &lt;/html&gt; class WebActivity : AppCompatActivity() { ... private fun checkObj() { webView.evaluateJavascript(&quot;checkObj()&quot;) { result -&gt; Log.e(TAG, result) // Log: {&quot;name&quot;:&quot;json&quot;} } } } 我们用 Log 打印出来是 {&quot;name&quot;:&quot;json&quot;}，记住它不是 JSON 对象，而是一个字符串，即 result = &quot;{\\&quot;name\\&quot;:\\&quot;json\\&quot;}&quot;。 最后，我们看看字符串类型： &lt;html&gt; &lt;script type=&quot;text/javascript&quot;&gt; function sayHi() { return &quot;Hi&quot; } &lt;/script&gt; ... &lt;/html&gt; class WebActivity : AppCompatActivity() { ... private fun checkObj() { webView.evaluateJavascript(&quot;sayHi()&quot;) { result -&gt; Log.e(TAG, result) // Log: &quot;Hi&quot; } } } 我们用 Log 打印出来是 &quot;Hi&quot;，而不是 Hi，即 result = &quot;\\&quot;Hi\\&quot;&quot;。 发现没有，当 JavaScript 返回值为字符串时，Android 端会在该字符串前后带上双引号 &quot;，而当返回值为非字符串时，则会直接转为正常的字符串返回。 这样设计的用意也许是 ValueCallback 的泛型指定为 String 后能够更好的区分返回值的类型，但无疑会给使用者造成使用上的麻烦，所以使用时应多加注意。 ","link":"https://LiarrDev.github.io/post/Handle-Different-Types-of-JavaScript-Return-Values-in-WebView/"},{"title":"Android 获取 WebView 选区位置","content":"之前我们介绍了如何获取 WebView 选中的文本，今天讲讲如何获取选区的位置。 与获取选中文本类似，WebView 也没有提供相应的方法，所以同样需要通过 JS 辅助。 为了方便，可以直接在『Android 获取 WebView 选中文本』一文中的例子上直接改造。 首先是 JS 函数： object JsFunction { private val GET_SELECTION = &quot;&quot;&quot; javascript:(function getSelectedText() { var txt; var top = 0, bottom = 0, left = 0, right = 0; if (window.getSelection) { var sel = window.getSelection(); txt = sel.toString(); var range = sel.getRangeAt(0); var rect = range.getBoundingClientRect(); top = rect.top; bottom = rect.bottom; left = rect.left; right = rect.right; } else if (window.document.getSelection) { var sel = window.document.getSelection(); txt = sel.toString(); var range = sel.getRangeAt(0); var rect = range.getBoundingClientRect(); top = rect.top; bottom = rect.bottom; left = rect.left; right = rect.right; } else if (window.document.selection) { var range = window.document.selection.createRange(); txt = range.text; var rect = range.getBoundingClientRect(); top = rect.top; bottom = rect.bottom; left = rect.left; right = rect.right; } var json = {}; json.selection = txt; json.left = left; json.top = top; json.right = right; json.bottom = bottom; json.windowWidth = window.innerWidth; json.windowHeight = window.innerHeight return json; })() &quot;&quot;&quot;.trimIndent() } 在之前的函数上，我们增加了选区上下左右四个方向的边距，用于计算选区的位置，大概思路就是获取到选区的 Rect，然后再获取其坐标，思路与 Android 是类似的。 需要注意的是，JS 只能获取到其相对于网页窗口的坐标，与 Android 端的坐标并不是一个概念，所以同样还要返回窗口的大小用于换算。 返回的内容比较多，我们将其封装成 JSON 返回。 然后定义一个数据类用于解析返回的数据： object JsFunction { ... data class WebViewSelection( val selection: String, val left: Double, val top: Double, val right: Double, val bottom: Double, val windowWidth: Double, val windowHeight: Double ) } 解析数据可以用 Gson 或其他工具封装一下： object JsFunction { ... fun getSelection(webView: WebView, callback: (WebViewSelection?) -&gt; Unit) { webView.evaluateJavascript(GET_SELECTION) { callback.invoke(Gson().fromJson(it, WebViewSelection::class.java)) } } } WebView 这边执行： class MyWebView(context: Context, attrs: AttributeSet? = null) : WebView(context, attrs) { ... private fun getWebSelection() { JsFunction.getSelection(this) { if (it == null) return@getSelection val left = (it.left / it.windowWidth * width).toInt() val right = (it.right / it.windowWidth * width).toInt() val top = (it.top / it.windowHeight * height).toInt() val bottom = (it.bottom / it.windowHeight * height).toInt() ... } } } 因为坐标不一致，所以要重新计算坐标，简单的比例乘除问题，不用过多解释。 接下来就可以按照自己的需求做相应的逻辑了。 ","link":"https://LiarrDev.github.io/post/Get-Selection-Position-in-Android-WebView/"},{"title":"Android 获取 WebView 选中文本","content":"WebView 是用来展示网页内容的控件，我们也常常会对网页的文本进行选中复制分享等等的操作。 那么在开发中，我们如何获取用户选中的文本呢？ 实际上，WebView 并没有给我们提供相应的 API，所以我们不得不另辟蹊径。 换个思路，既然 Android 端无法直接获取到选中的内容，那就从 Web 端获取。这时候可能会有一个问题，WebView 加载的网页未必都是我们自己或者团队内部开发的，所以不一定能让第三方的网站也为我们适配这种功能，不过不用担心，假如我们通过客户端注入 JS 的方式，这个问题也就迎刃而解了。 首先是 JS 函数： object JsFunction { fun getSelection() = &quot;&quot;&quot; javascript:(function getSelectedText() { var txt; if (window.getSelection) { txt = window.getSelection().toString(); } else if (window.document.getSelection) { txt = window.document.getSelection().toString(); } else if (window.document.selection) { txt = window.document.selection.createRange().text; } return txt; })() &quot;&quot;&quot;.trimIndent() } 因为 Java 的字符串拼接方式不太直观，所以我这里用 Kotlin 来写，这个 JS 函数相信也足够简单易懂，通过获取选区，然后再获取选区内的文字并返回。 然后就是利用之前『Android WebView 和 JavaScript 交互』讲过的方法执行： class MyWebView(context: Context, attrs: AttributeSet? = null) : WebView(context, attrs) { ... private fun getSelection() { evaluateJavascript(JsFunction.getSelection()) { selectedText -&gt; // do what you want } } } 接下来就可以拿到选中的文字执行自己的逻辑了。 ","link":"https://LiarrDev.github.io/post/Get-Selection-Text-in-Android-WebView/"},{"title":"Java String 长度限制","content":"在学习和开发过程中，我们经常会讨论 short、int 和 long 这些基本数据类型的取值范围，但是对于 String 类型我们好像很少注意它的“取值范围”。 那么，对于 String 类型，它到底有没有长度限制？ 其实 String 类型的对象，他们是有长度限制的，String 对象并不能存储无限长度的字符串。关于 String 的长度限制要从编译时限制和运行时限制两方面考虑。 编译期限制 有 JVM 虚拟机相关知识的同学肯定知道，定义的字符串常量会被放入方法区的常量池中。 String 长度之所以会受限制，是因 JVM 规范对常量池有所限制。常量池中的每一种数据项都有自己的类型，CONSTANT_String_info 用于表示 String 类型的常量对象，结构如下： CONSTANT_String_info { u1 tag; u2 string_index; } 其中，string_index 项的值必须是对常量池的有效索引，常量池在该索引处的项必须是 CONSTANT_Utf8_info 结构，表示一组 Unicode 码点序列，这组 Unicode 码点序列最终会被初始化一个 String 对象。 即 Java 中的 UTF-8 编码的 Unicode 字符串在常量池中以 CONSTANT_Utf8_info 类型表示，结构如下： CONSTANT_Utf8_info { u1 tag; u2 length; u1 bytes[length]; } 长度为 length 的那个 bytes 数组就是真正存储常量数据的地方，而 length 就是数组可以存储的最大字节数。length 的类型是 u2，u2 表示两个字节的无符号数，即无符号的 16 位整数，因此理论上允许的的最大长度是 2^16-1，所以上面 byte 数组的最大长度可以是 65535。 但是当你企图生成一个长度为 65535 的字符串时，编译依然会失败，而生成一个长度为 65534 的字符串却编译成功，这似乎与上面的结论不符。 其实，这是 Javac 编译器的额外限制。在 Javac 的源代码中可以找到以下方法： public class Gen extends JCTree.Visitor { ... /** Check a constant value and report if it is a string that is too large. */ private void checkStringConstant(DiagnosticPosition pos, Object constValue) { if (nerrs != 0 || // only complain about a long string once constValue == null || !(constValue instanceof String) || ((String)constValue).length() &lt; PoolWriter.MAX_STRING_LENGTH) return; log.error(pos, Errors.LimitString); nerrs++; } } 还有一个最重要的常量： public class PoolWriter { /** Max number of char in a string constant. */ public static final int MAX_STRING_LENGTH = 0xFFFF; ... } 0xFFFF 就是十进制的 65535。 代码中可以看出，当参数类型为 String，并且长度大于等于 65535 的时候，就会导致编译失败。 这里需要重点强调下的是，String 的限制并不是对字符串长度的限制，而是对字符串底层存储的限制，也就是字节长度的限制。 举个例子，Java 中的字符常量都是使用 UTF-8 编码的，UTF-8 编码使用 1~4 个字节来表示具体的 Unicode 字符。所以有的字符占用一个字节，而我们平时所用的大部分中文都需要 3 个字节来存储，另外还有的汉字需要 4 个字节存储。 // 65534 个字母“d”，编译通过 String s1 = &quot;dd..d&quot;; // 21845 个中文“自”，编译通过 String s2 = &quot;自自...自&quot;; // 1 个英文字母“d”加上 21845 个中文“自”，编译失败 String s3 = &quot;d自自...自&quot;; 对于 s1，1 个字母 d 的 UTF-8 编码占用 1 个字节，65534 个字母占用 65534 个字节，长度是 65534，也没超过 Javac 的限制，所以可以编译通过。 对于 s2，1 个中文占用 3 个字节，21845 个正好占用 65535 个字节，而且字符串长度是 21845，并没有超过 Javac 对长度的限制，所以可以编译通过。 对于 s3，1 个英文字母 d 加上 21845 个中文占用 65536 个字节，超过了限制，编译失败。 回到一开始，u2 类型能表达的最大值是 65535，长度 65535 的字符串在 Javac 下报错了是受到了 Javac 编译器的限制，如果你先将长度为 65534 的字符串用 Javac 编译，再在生成的 CLASS 文件中手动添加一个字符，是可以得到长度为 65535 的结果。 另外，使用『Eclipse』编译超过 65534 长度的字符串不报错，是因为『Eclipse』有自己的 Java 编译器，『Eclipse』使用自己的编译器，主要原因是 JDT 核心具有渐进式编译的能力，这意味着它会逐步编译代码中的更改，这也是『Eclipse』不需要编译按钮的原因，因为它会在检测到更改时自动编译。但 Oracle 的 JDK 不支持增量编译。 运行时限制 String 运行时的限制主要体现在 String 的构造函数上： public final class String implements Serializable, Comparable&lt;String&gt;, CharSequence { /** * Allocates a new {@code String} that contains characters from a subarray * of the character array argument. The {@code offset} argument is the * index of the first character of the subarray and the {@code count} * argument specifies the length of the subarray. The contents of the * subarray are copied; subsequent modification of the character array does * not affect the newly created string. * * @param value Array that is the source of characters * @param offset The initial offset * @param count The length * @throws IndexOutOfBoundsException If the {@code offset} and {@code count} arguments index characters outside the bounds of the {@code value} array */ public String(char value[], int offset, int count) { if (offset &lt; 0) { throw new StringIndexOutOfBoundsException(offset); } if (count &lt;= 0) { if (count &lt; 0) { throw new StringIndexOutOfBoundsException(count); } if (offset &lt;= value.length) { this.value = &quot;&quot;.value; return; } } // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; value.length - count) { throw new StringIndexOutOfBoundsException(offset + count); } this.value = Arrays.copyOfRange(value, offset, offset + count); } } count 值就是字符串的最大长度，在 Java 中 int 的最大长度是 2^31-1。所以在运行时，String 的最大长度是 2^31-1。 但是这个也是理论上的长度，实际的长度还要跟 JVM 的内存相关，最大的字符串会占用 (2^31-1)*2*16/8/1024/1024/1024 的内存（char 在 Java 中占 2 个字节，16 指 16-bit Unicodecharacter 即 u2，8 指 Bit 转 Byte，1024 指 KB、MB 和 GB 的单位转换）。 所以在最坏的情况下，一个最大的字符串要占用 4GB 的内存，如果虚拟机不能分配这么多内存的话，会直接报错的。 以上源码是基于 Java 8 的，Java 9 以后对 String 的存储进行了优化。底层不再使用 char[] 数组存储字符串，而是使用 byte[] 数组，对于 LATIN1 字符的字符串可以节省一倍的内存空间： public final class String implements Serializable, Comparable&lt;String&gt;, CharSequence { ... public String(char[] value, int offset, int count) { this(value, offset, count, rangeCheck(value, offset, count)); } String(char[] value, int off, int len, Void sig) { if (len == 0) { this.value = &quot;&quot;.value; this.coder = &quot;&quot;.coder; } else { if (COMPACT_STRINGS) { byte[] val = StringUTF16.compress(value, off, len); if (val != null) { this.value = val; this.coder = 0; return; } } this.coder = 1; this.value = StringUTF16.toBytes(value, off, len); } } } 简单总结 String 的长度是有限制的。 编译期的限制：字符串的 UTF-8 编码值的字节数不能超过 65535，字符串的长度不能超过 65534； 运行时限制：字符串的长度不能超过 2^31-1，占用的内存数不能超过虚拟机能够提供的最大值。 ","link":"https://LiarrDev.github.io/post/Length-Limitation-on-Java-String/"},{"title":"Let's party like it's 1995!","content":"最近在看 LayoutInflater 源码的时候发现了一个有意思的注释： @SystemService(Context.LAYOUT_INFLATER_SERVICE) public abstract class LayoutInflater { ... private static final String TAG_1995 = &quot;blink&quot;; /** * Tries to create a view from a tag name using the supplied attribute set. * * @hide for use by precompiled layouts. * * @param parent the parent view, used to inflate layout params * @param name the name of the XML tag used to define the view * @param context the inflation context for the view, typically the {@code parent} or base layout inflater context * @param attrs the attribute set for the XML tag used to define the view */ @UnsupportedAppUsage(trackingBug = 122360734) @Nullable public final View tryCreateView(@Nullable View parent, @NonNull String name, @NonNull Context context, @NonNull AttributeSet attrs) { if (name.equals(TAG_1995)) { // Let's party like it's 1995! return new BlinkLayout(context, attrs); } ... } } 可以看到第二个参数是指定义 View 的布局 TAG 名称，当它为 TAG_1995 时，直接返回一个 BlinkLayout，而重点在这句的注释上：“Let's party like it's 1995!” 这句话中文翻译过来就是：“让我们像 1995 年那样狂欢吧！” TAG_1995 的值可以看到是 blink，中文是闪烁的意思，我们写个 Demo 来看看效果： &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;blink android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:text=&quot;Let's Party&quot; android:textSize=&quot;64sp&quot; /&gt; &lt;/blink&gt; &lt;/RelativeLayout&gt; 效果如下： 接下来看看它是如何实现的。 BlinkLayout 是 LayoutInflater 的内部类，继承自 FrameLayout，实现并不复杂，完整代码如下： @SystemService(Context.LAYOUT_INFLATER_SERVICE) public abstract class LayoutInflater { ... private static class BlinkLayout extends FrameLayout { private static final int MESSAGE_BLINK = 0x42; private static final int BLINK_DELAY = 500; private boolean mBlink; private boolean mBlinkState; private final Handler mHandler; public BlinkLayout(Context context, AttributeSet attrs) { super(context, attrs); mHandler = new Handler(new Handler.Callback() { @Override public boolean handleMessage(Message msg) { if (msg.what == MESSAGE_BLINK) { if (mBlink) { mBlinkState = !mBlinkState; makeBlink(); } invalidate(); return true; } return false; } }); } private void makeBlink() { Message message = mHandler.obtainMessage(MESSAGE_BLINK); mHandler.sendMessageDelayed(message, BLINK_DELAY); } @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); mBlink = true; mBlinkState = true; makeBlink(); } @Override protected void onDetachedFromWindow() { super.onDetachedFromWindow(); mBlink = false; mBlinkState = true; mHandler.removeMessages(MESSAGE_BLINK); } @Override protected void dispatchDraw(Canvas canvas) { if (mBlinkState) { super.dispatchDraw(canvas); } } } } 当 BlinkLayout 回调 onAttachedToWindow() 时，调用 makeBlink() 方法，makeBlink() 方法内部用 Handler 发送一个延迟 500ms 的消息。从构造函数中又可以看到，在接受到 Handler 消息后，又接着调用 makeBlink()，循环发送消息，然后刷新页面。 当 BlinkLayout 回调 onDetachedFromWindow() 时，移除这个这个消息队列中的所有消息，结束循环。 接下来再看这个 Message 的处理，在 handleMessage() 中，会对 mBlinkState 这个布尔变量取反，然后在 dispatchDraw() 回调时，则判断这个状态变量来决定是否需要绘制界面，由于是每隔 500ms 发送一次消息，所以 mBlinkState 的值也会每隔 500ms 反转一次，View 相应的也会 500ms 绘制一次，500ms 消失一次，就形成了闪烁。 实际上你在写布局文件时会发现，&lt;blink&gt; 标签在『Android Studio』中会报「Cannot resolve class blink」，所以我们一般开发中也不会使用，尽管它能够通过编译，因此也算得上是 Android 官方埋下的一枚彩蛋吧。 关于 1995 年发生了什么，我想了一下与 Android 相关的事件，只想到 Sun 公司在 1995 年发布了 Java，不过随着 Sun 被 Oracle 收购，Google 和 Oracle 的官司也成为了 Android 程序员津津乐道的消息。 后来查了一下，发现 1995 年还是 Google 两位联合创始人 Lawrence Edward Page 和 Sergey Mikhaylovich Brin 在 Stanford 相遇的时间。 2002 年 Andy Rubin 在 Stanford 给硅谷工程师讲课，恰好 Google 两位大佬也是听众。 2003 年 Andy Rubin 创立 Android，随后 2005 年 Google 便收购了这个仅成立了 22 个月的公司，并在 2007 年正式向外部公布 Android 操作系统，随后 Android 生态壮大发展，越居移动操作系统市场占有率榜首。 ","link":"https://LiarrDev.github.io/post/Lets-Party-Like-its-1995/"},{"title":"Windows Battery Report","content":"我们一般使用移动电子设备时，往往会比较关注电池的寿命，我发现在使用 iPhone 的人群中对电池寿命的关注度更高。 而常使用笔记本电脑移动办公的我们，也需要关注一下笔记本的电池健康。 从 Windows 10 开始系统设置已经支持查看电池信息了： 但是说实话，这个页面显示的电池信息实在有限，也就能看看每个小时电池的电量，屏幕开关时间，以及应用耗电情况等。 如果想了解电池的寿命等信息，许多人可能会考虑下载『鲁大师』等第三方应用来查看。 其实完全没有必要，因为 Windows 是可以直接生成电池报告的，只需一条命令即可。 打开『终端』，键入以下命令并回车： ➜ powercfg /BatteryReport 系统会在当前目录下生成一个名为 battery-report.html 文件，如果你不知道当前终端所在目录，执行完命令后文件目录也会展示在终端中。 这个文件就是系统为我们生成的电池报告，双击打开，默认情况下会跳转到浏览器中加载。我随手拿了一台笔记本，生成的报告大概是这样子的： 报告为全英文，你可能看得有点懵逼，我来带你一一解读。 开头是笔记本的一些基本信息，包括笔记本型号、BIOS、系统版本等。 接下来是电池规格，包括厂商、材质、容量等。 这里主要关注四个参数，一个是 CHEMISTRY，即电池电介质，Lilo 表示锂离子电池，DESIGN CAPACITY 是指该电池在设计时的标定容量，FULL CHARGE CAPACITY 指满电状态下的实际容量，CYCLE COUNT 指循环次数。 可以看到我这里的实际容量比标定容量还高，不要太惊讶，一般情况下有 5% 左右的误差也是正常的。 下面是过去 3 天的电源使用状态。 左侧的时间一目了然，第二列是状态，Active 表示系统在活动状态，Connected Standby 表示待机，Suspended 表示挂起，Report generated 表示报告生成，一般为最后一条。 第三列是使用何种供电方式，AC 就是交流电，可以直接理解为电源供电，Battery 就是电池供电。 最后两列分别就是电池电量百分比和具体值了，mWh 中文名称为毫瓦时，与 mAh（毫安时）一样，同是电池容量的单位。 看上面的数据你可以发现一个非常有意思的事情，这台电脑在我充满电之后关机，下次启动的时候电量都被耗光了，可以得出结论，这台电脑的电池有问题。 然后就是电池的使用情况，该项目中会以折线图显示最近三天的电量消耗情况。 一般情况下只有当你使用电池时才会有明显的折线，该项主要关注其电池消耗速度与实际工况是否吻合。 往下就是电源和电池的使用历史。 再然后就是电池容量历史，该部分会显示电池容量随时间的减少情况，数据含义与开头说的一致。 最后则是电池预估可用时间，主要关注最后一条。 根据自操作系统安装以来观察到的所有耗损情况，对电池可用时长的估计。 以上就是对电池报告的解读流程。 另外，似乎有网友提到自己的笔记本电池报告中部分数据不会随着时间损耗，怀疑被厂商写死了；也有部分网友出现跟我上面测的这台机器一样，电池损耗与实际严重不符，可以怀疑是被人动过手脚。 总之，该报告尽管并不详尽，但我们从中提炼出来的信息，也有一定的参考意义。 ","link":"https://LiarrDev.github.io/post/Windows-Battery-Report/"},{"title":"对 JSONObject 的遍历","content":"之前介绍了如何对 Map 进行遍历，里面提到了一个场景，就是将缓存到 Map 的数据存储到 JSONObject 中，我们知道，JSON 是一种与 Map 十分相似的数据交换格式，它同样采用了键值对的存储方式，那么现在就假设一个相反的场景，当我们需要将 JSON 中的数据缓存到本地时，也许遍历也不失为一种优雅的做法。 与 Map 的遍历相似，这个场景归根结底在于对 JSON 中 key 的遍历，因为只要拿到 key，也就可以轻易拿到 value。 JSONObject 的遍历也有多种实现方式： Iterator.hasNext() public static void jsonTraversal(JSONObject json) { Iterator&lt;String&gt; it = json.keys(); while (it.hasNext()) { String key = it.next(); Object value = json.opt(key); // Do something... } } JSONObject 的 keys() 方法会返回其所有 key 的 Set 集合的 Iterator 对象，因此我们可以直接对其迭代。 Iterator.forEachRemaining() public static void jsonTraversal(JSONObject json) { json.keys().forEachRemaining(key -&gt; { Object value = json.opt(key); // Do something... } Java 8 之后 Iterator 也增加了 forEachRemaining() 方法，Lambda 的写法更加简洁。 JSONObject.names() public static void jsonTraversal(JSONObject json) { JSONArray array = json.names(); if (array != null) { for (int i = 0; i &lt; array.length(); i++) { String key = array.optString(i); Object value = json.opt(key); // Do something... } } } JSONObject 中有个 names() 方法很有意思，它把 key 集合通过 JSONArray 也就是数组的形式返回，只需遍历这个数组将 key 值取出即可。 不过当 JSONObject 中不存在数据时，该方法会返回 null，所以记得判空。 JSONObject.keySet() public static void jsonTraversal(JSONObject json) { for (String key : json.keySet()) { Object value = json.opt(key); // Do something... } } 我们知道 Map 中有 keySet() 方法，JSONObject 也有，返回的是一个包含所有 key 的 Set 集合，对其进行遍历即可。 同样，Java 8 上也可以用上 forEach()： public static void jsonTraversal(JSONObject json) { json.keySet().forEach(key -&gt; { Object value = json.opt(key); // Do something... }); } 但是当在 Android 中使用 keySet() 时你会发现找不到该方法，查看源码可以看到其被限制了外部访问： public class JSONObject { /** * Returns the set of {@code String} names in this object. The returned set * is a view of the keys in this object. {@link Set#remove(Object)} will remove * the corresponding mapping from this object and set iterator behaviour * is undefined if this object is modified after it is returned. * * See {@link #keys()}. * * @hide. */ @UnsupportedAppUsage @libcore.api.CorePlatformApi public Set&lt;String&gt; keySet() { return nameValuePairs.keySet(); } } 而在普通的 Java 项目中引入最新的 org.json 库，是支持外部调用的，估计是 Android 官方出于某些原因考虑而将其限制了，又或者是 Android 源码中引入的是低版本 org.json 库的原因，因为我在最新的版本中看到的 entrySet() 方法，Android 源码中也没有： public class JSONObject { /** * Get a set of entries of the JSONObject. These are raw values and may not * match what is returned by the JSONObject get* and opt* functions. Modifying * the returned EntrySet or the Entry objects contained therein will modify the * backing JSONObject. This does not return a clone or a read-only view. * * Use with caution. * * @see Map#entrySet() * * @return An Entry Set */ protected Set&lt;Entry&lt;String, Object&gt;&gt; entrySet() { return this.map.entrySet(); } } 尽管这个方法是 protected 的。 ","link":"https://LiarrDev.github.io/post/JSONObject-Traversal/"},{"title":"解决 Adobe CS6 全家桶界面比例异常的问题","content":"最近入手了一台 Windows 笔记本，屏幕分辨率是 2560 × 1440 的，厂商宣称为 2.5k 屏，尽管在我的 MacBook Pro 面前依然是个弟弟，但回想我上一台 Windows 笔记本还是 1366 × 768 的分辨率，这也是一次飞跃了。 但到了安装 Adobe 软件的时候，却发现了一个问题，CS6 版本的 Adobe 软件并没有适配高分屏，所以界面效果大概是这样的： 如果外接一个大屏显示器的话能勉强凑合用，但在 14 英寸的笔记本屏幕上，看得眼睛都快瞎了，对比底部任务栏你也能够感受到显示比例的区别。 而我打开软件的菜单设置也没找到相关选项，无奈只能通过修改配置来实现。 首先打开『运行』，输入 regedit： 点击「确定」后可跳转到『注册表编辑器』，依次展开目录 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SideBySide，右键菜单新建 DWORD： 将数值名称命名为 PreferExternalManifest，并对其执行「修改」： 将数值数据修改为 1，基数修改为「十进制」。 然后新建一个文本文档，将如下代码复制到该文件中： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt; &lt;assembly xmlns=&quot;urn:schemas-microsoft-com:asm.v1&quot; manifestVersion=&quot;1.0&quot; xmlns:asmv3=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt; &lt;dependency&gt; &lt;dependentAssembly&gt; &lt;assemblyIdentity type=&quot;win32&quot; name=&quot;Microsoft.Windows.Common-Controls&quot; version=&quot;6.0.0.0&quot; processorArchitecture=&quot;*&quot; publicKeyToken=&quot;6595b64144ccf1df&quot; language=&quot;*&quot;&gt; &lt;/assemblyIdentity&gt; &lt;/dependentAssembly&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;dependentAssembly&gt; &lt;assemblyIdentity type=&quot;win32&quot; name=&quot;Microsoft.VC90.CRT&quot; version=&quot;9.0.21022.8&quot; processorArchitecture=&quot;amd64&quot; publicKeyToken=&quot;1fc8b3b9a1e18e3b&quot;&gt; &lt;/assemblyIdentity&gt; &lt;/dependentAssembly&gt; &lt;/dependency&gt; &lt;trustInfo xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt; &lt;security&gt; &lt;requestedPrivileges&gt; &lt;requestedExecutionLevel level=&quot;asInvoker&quot; uiAccess=&quot;false&quot;/&gt; &lt;/requestedPrivileges&gt; &lt;/security&gt; &lt;/trustInfo&gt; &lt;asmv3:application&gt; &lt;asmv3:windowsSettings xmlns=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&gt; &lt;ms_windowsSettings:dpiAware xmlns:ms_windowsSettings=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&gt;false&lt;/ms_windowsSettings:dpiAware&gt; &lt;/asmv3:windowsSettings&gt; &lt;/asmv3:application&gt; &lt;/assembly&gt; 保存后进入你所安装的 Adobe 应用程序所在文件夹，找到该应用程序对应的文件名称，比如我这里安装的是『Adobe Photoshop CS6』，可以看到其对应的文件名是 Photoshop.exe。 将刚刚的文本文件复制到该文件夹下并重命名为 应用程序文件名.manifest，比如我这里就是 photoshop.exe.manifest，如果你安装的是『Adobe Illustrator CS6』，则命名为 Illustrator.exe.manifest，其他同理。 然后重新打开应用，可以发现显示比例变大了。 不用再戴老花镜看电脑啦。 ","link":"https://LiarrDev.github.io/post/Solve-the-Problem-of-Abnormal-Scale-of-Adobe-CS6 /"},{"title":"Java 对 Map 进行遍历","content":"Map 是我们在开发中常用的数据结构，它采用了键值对的数据存储方式，很适合用来缓存数据。 假设这么一个场景：我需要对缓存到 Map 中的数据做网络传输，或者本地持久化操作，应该怎么操作？ 最粗暴的方法就是逐个读写，比如： public void postData(Map&lt;String, Object&gt; map) { Object value1 = map.get(&quot;key_1&quot;); Object value2 = map.get(&quot;key_2&quot;); ... JSONObject json = new JSONObject(); json.put(&quot;key_1&quot;, value1); json.put(&quot;key_2&quot;, value2); ... } 当 Map 中的数据非常多时，逐个读写的方式会显得格外臃肿。 在这种场景下，我们大概率不关心各个键值对的数据内容，其实可以直接采用遍历的方法。 Map 的遍历有多种实现方式： Map.keySet() public static void mapTraversal(Map&lt;Object, Object&gt; map) { for (Object key : map.keySet()) { Object value = map.get(key); // Do something... } } 利用 foreach 循环，通过 Map 的 keySet() 遍历得出所有的 key，再利用 key 取得 value。 Map 的 keySet() 方法返回的是一个包含该 Map 中所有 key 的 Set 集合，因为 Set 具备迭代器，所以能够遍历取出对应的值。 Map.entrySet() public void mapTraversal(Map&lt;Object, Object&gt; map) { for (Map.Entry&lt;Object, Object&gt; entry : map.entrySet()) { Object key = entry.getKey(); Object value = entry.getValue(); // Do something... } } Map 中采用 Entry 内部类来表示一个映射项，映射项包含了 key 和 value，而 Map 的 entrySet() 方法返回的就是一个包含此映射项的 Set 集合，所以我们可以直接对其遍历。 Iterator public static void mapTraversal(Map&lt;Object, Object&gt; map) { Iterator&lt;Map.Entry&lt;Object, Object&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry&lt;Object, Object&gt; entry = it.next(); Object key = entry.getKey(); Object value = entry.getValue(); // Do something... } } Iterator 对 Map 的遍历依然是使用 Map 的 entrySet() 方法取映射，套上 Iterator 似乎有点多此一举，但当你需要从 Map 中移除元素时，foreach 便无能为力了，而 Iterator 的 remove() 方法则能够帮你轻松实现。 Java 8 forEach() Lambda public static void mapTraversal(Map&lt;Object, Object&gt; map) { map.forEach((key, value) -&gt; { // Do something... }); } Java 8 提供了 Lambda 表达式支持，而 Map 也在 Java 8 加入了 forEach() 方法，语法看起来更简洁，可以同时拿到 key 和 value。 同时，由于 Collection 本身就继承自 Iterable，因此 keySet() 和 entrySet() 所获取到的 Set 集合便支持 Iterable 的 forEach() 方法。 ","link":"https://LiarrDev.github.io/post/Java-Map-Traversal/"},{"title":"为什么 Html.fromHtml() 不能解析 RGB 色值","content":"游戏 SDK 需要接入一个类似公告板的需求，大概样子长这样： 可以看到，中间的内容字体是有不同样式的，之前『Android 改变 TextView 内局部样式』也介绍过如何实现类似的功能。这里由于内容本身也是从服务端获取的，所以服务端生成 HTML 格式文本，客户端再使用 Html.fromHtml() 来解析会比较合适。 不过不知道是服务端富文本插件原因还是其他什么原因，生成过来的富文本格式是这样的： 点击&lt;span style=&quot;color: rgb(0, 255, 0)&quot;&gt;【大厅】&lt;/span&gt;-左下角... 但是实际上这个 RGB 颜色属性是不生效的，除非指定为具体的颜色名称： 点击&lt;span style=&quot;color: green&quot;&gt;【大厅】&lt;/span&gt;-左下角... 或者使用十六进制格式： 点击&lt;span style=&quot;color: #00FF00&quot;&gt;【大厅】&lt;/span&gt;-左下角... 这里主要是用到 &lt;span&gt; 标签，所以进到对应的解析源码查看： class HtmlToSpannedConverter implements ContentHandler { ... private void handleStartTag(String tag, Attributes attributes) { if (...) { ... } else if (tag.equalsIgnoreCase(&quot;span&quot;)) { startCssStyle(mSpannableStringBuilder, attributes); } else if (...) { ... } } private void startCssStyle(Editable text, Attributes attributes) { String style = attributes.getValue(&quot;&quot;, &quot;style&quot;); if (style != null) { Matcher m = getForegroundColorPattern().matcher(style); if (m.find()) { int c = getHtmlColor(m.group(1)); if (c != -1) { start(text, new Foreground(c | 0xFF000000)); } } ... } } } HtmlToSpannedConverter 不是 Html 的内部类，但却写在了 Html.java 文件中，它在 Html.fromHtml() 方法内部被创建。 HTML 的解析对大家来说都没什么难度，跟普通的 XML 解析相似，无非就是先后解析出节点的标签、属性和值，所以我们从标签的解析着手。 首先进入 &lt;span&gt; 标签的分支，判断是否有 style 属性，有的话执行下面的解析。 getForegroundColorPattern() 就是匹配的颜色： class HtmlToSpannedConverter implements ContentHandler { ... private static Pattern getForegroundColorPattern() { if (sForegroundColorPattern == null) { sForegroundColorPattern = Pattern.compile(&quot;(?:\\\\s+|\\\\A)color\\\\s*:\\\\s*(\\\\S*)\\\\b&quot;); } return sForegroundColorPattern; } } 如果匹配上了，就进入 getHtmlColor() 方法： class HtmlToSpannedConverter implements ContentHandler { ... private int getHtmlColor(String color) { ... // If |color| is the name of a color, pass it to Color to convert it. Otherwise, // it may start with &quot;#&quot;, &quot;0&quot;, &quot;0x&quot;, &quot;+&quot;, or a digit. All of these cases are // handled below by XmlUtils. (Note that parseColor accepts colors starting // with &quot;#&quot;, but it treats them differently from XmlUtils.) if (Character.isLetter(color.charAt(0))) { try { return Color.parseColor(color); } catch (IllegalArgumentException e) { return -1; } } try { return XmlUtils.convertValueToInt(color, -1); } catch (NumberFormatException nfe) { return -1; } } } 这里的注释十分清晰，如果传进来的参数是一个颜色名称，那么它将交给 Color 类进行转换；否则，它大概率会以 #、0、0x、+ 或数字开头，交给 XmlUtils 处理。 它的判断条件十分简单粗暴，传进来的参数是一个字符串，假如其第一个字符是字母的话，它就将其作为颜色名称来转换，比如 green 就符合条件。 也正是因为这个原因，我们返回的 RGB 色值是 rgb(0, 255, 0)，第一个字符也是字母，被扯进这个判断中去了。 再到 Color 类看看接下去的步骤： public class Color { ... @ColorInt public static int parseColor(@Size(min=1) String colorString) { if (colorString.charAt(0) == '#') { ... } else { Integer color = sColorNameMap.get(colorString.toLowerCase(Locale.ROOT)); if (color != null) { return color; } } throw new IllegalArgumentException(&quot;Unknown color&quot;); } } 先判断传入字符串的首个字符是否为 #，由于上一步已经做了过滤，所以这一步必然是 false，走下面的 else 分支。也就是从 sColorNameMap 这个 Map 里面根据颜色名称查找对应的色值，接下来看看系统默认定义了哪些色值： public class Color { ... private static final HashMap&lt;String, Integer&gt; sColorNameMap; static { sColorNameMap = new HashMap&lt;&gt;(); sColorNameMap.put(&quot;black&quot;, BLACK); sColorNameMap.put(&quot;darkgray&quot;, DKGRAY); sColorNameMap.put(&quot;gray&quot;, GRAY); sColorNameMap.put(&quot;lightgray&quot;, LTGRAY); sColorNameMap.put(&quot;white&quot;, WHITE); sColorNameMap.put(&quot;red&quot;, RED); sColorNameMap.put(&quot;green&quot;, GREEN); sColorNameMap.put(&quot;blue&quot;, BLUE); sColorNameMap.put(&quot;yellow&quot;, YELLOW); sColorNameMap.put(&quot;cyan&quot;, CYAN); sColorNameMap.put(&quot;magenta&quot;, MAGENTA); sColorNameMap.put(&quot;aqua&quot;, 0xFF00FFFF); sColorNameMap.put(&quot;fuchsia&quot;, 0xFFFF00FF); sColorNameMap.put(&quot;darkgrey&quot;, DKGRAY); sColorNameMap.put(&quot;grey&quot;, GRAY); sColorNameMap.put(&quot;lightgrey&quot;, LTGRAY); sColorNameMap.put(&quot;lime&quot;, 0xFF00FF00); sColorNameMap.put(&quot;maroon&quot;, 0xFF800000); sColorNameMap.put(&quot;navy&quot;, 0xFF000080); sColorNameMap.put(&quot;olive&quot;, 0xFF808000); sColorNameMap.put(&quot;purple&quot;, 0xFF800080); sColorNameMap.put(&quot;silver&quot;, 0xFFC0C0C0); sColorNameMap.put(&quot;teal&quot;, 0xFF008080); } } 很明显，不会有我们传进来的 rgb(0, 255, 0)，所以会返回 null，同时抛出异常。 这就是为什么 Html.fromHtml() 不能解析 RBG 格式颜色的原因。 ","link":"https://LiarrDev.github.io/post/Why-FromHtml-Method-cannot-Parse-RGB-Color/"},{"title":"MVN Repository","content":"开发中常常需要用到一些开源库，Java 系（包括 Android）的许多开源库一般都部署在远程的 Meven 仓库中，用户只需要做简单的配置，就能依赖该库，避免了传统使用本地文件导入方式的低效繁琐。 我们依赖这些远程库的时候，一般需要三个字段，以 Android 中常用的 Gradle 配置为例，写法为： implementation 'com.squareup.okhttp3:okhttp:4.9.3' 三个字段分别用冒号 : 分隔开，Gradle 这种写法的好处是能够减少了冗余配置，但也向我们隐藏了这三个字段所代表的实际意义。我们改为 Maven 的写法再看看： &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;4.9.3&lt;/version&gt; &lt;/dependency&gt; Maven 写法采用了 XML 语法，我们很容易得知这三个字段分别是 GroupId、ArtifactId 和 Version。其中 GroupId 对应的是项目组织标识，一般为 域名.项目名 的格式；ArtifactId 对应的是项目名称，它的作用可以区分这个项目下的一些子库或插件，比如 OkHttp 就包含了一个 ArtifactId 为 mockwebserver 的子库；Version 就很好理解了，就是版本号。 这么长的一段内容，你们平时是怎么记住的？我相信没人会去记这么一串东西。那么问题来了，那你们需要用到的时候是如何去找的？ 我列举三个方法，看看是不是你们常用的。 第一，官网是最权威的，打开搜索引擎（Baidu / Google），输入库名称，点击搜索，在搜索结果中找到符合的选项，进入官网，翻阅到依赖相关的内容处，选中，复制，再到项目中去粘贴。 第二，Github 是程序员的好朋友，打开 Github，输入库名称，搜索，在搜索结果中找到符合的选项，进入项目仓库中，滚动到 README，翻阅到依赖相关的内容处，选中，复制，再到项目中去粘贴。 第三，直接利用 IDE 的工具搜索，选择对应的库和版本，一键导入： 我简单说下这三种方法的缺点。 第一种方法只适用于项目有官网的库，如果恰好这个项目没有官网，或者说没有被搜索引擎收录，使用这种方法就犹如无头苍蝇。 第二种方法的两个缺点我认为有三个，一是 Github 本身在国内的访问就不是特别稳定，二是有些库发布版本没有生成 Release 日志，这会导致我们有时候只想查询版本号时一定要去翻阅 README，三是有些库甚至为了懒得改 README 直接引入了版本图片徽标，在依赖示例处直接用占位符代替，而恰好图片徽标又依赖于其他网站，当其他网站不稳定时，这个图片徽标显示不出来，导致无法得知版本号。 第三种方法一键导入看似非常方便，但是这个搜索引擎真的太废了，当你想搜索一个库时，直接搜索 ArtifactId 是不行的，必须要输入 GroupId 它才能搜索到你想要的内容，而问题就在于我们平常无论是交流还是使用，都只会记住 ArtifactId，所以只能说这个功能略显鸡肋。 说了这么多，就该推荐一个我常用的工具了。 『MVN Repository』是一个 Maven 库的查询工具，你只需要输入库的名称，它就能够找到对应库的历史版本信息，并自动为你生成依赖配置。 举个例子，比如我想依赖 Android 中 Lifecycle 相关的库，做过 Android 开发的话你应该知道， Lifecycle 相关的依赖可不少，我希望可以根据自己的需要选择，那么打开『MVN Repository』进行搜索： 可以看到，模糊搜索能力相比 IDE 内置的工具真是好太多了。 点进去我想要使用的库，会列出各个历史版本，除了正式的稳定版本之外，Alpha、Beta、RC 等版本都有收录。 选择对应的版本进入详情页，这里罗列了如 License、主页、更新日期等详细信息，下面还直接提供了各构建工具下的配置语法，含括了 Maven、Gradle、SBT、Ivy、Grape、Leiningen、Buildr 等多种构建工具。 更贴心的是，你毋需再手动选中复制，只需点击该编辑框，内容会自动复制到剪切板，直接去 IDE 里面粘贴就行。 另外，对于不希望使用远程依赖的用户，页面上还提供了库的文件下载地址，该地址指向了其对应的 Maven 远程仓库，用户可以直接下载。 网站还提供了库的分类和排名功能，能够方便按需查找。 总的来说，『MVN Repository』功能不多，但都恰到好处，简单易用，可以称得上是提高开发效率的小工具，尤其是在项目搭建之初，它能够节省很多来回找库的时间。 ","link":"https://LiarrDev.github.io/post/MVN-Repository/"},{"title":"Android 实现短信发送","content":"之前『Android 实时监听短信』一文中给内部团队做了一个短信拦截功能，而最近团队内部又来了一个自动发送短信的需求，同样通过测试机，请求服务端，当返回有需要发送的短信时，则自动通过本机的 SIM 卡服务发送。 发送短信需要用到 SEND_SMS 权限： &lt;manifest ...&gt; &lt;uses-permission android:name=&quot;android.permission.SEND_SMS&quot; /&gt; ... &lt;/manifest&gt; 不要忘了在代码中动态申请。 发送短信的思路很简单，只需要提供收件人号码、短信内容，就可以发送。 但是有一个需要注意的点，我们平时接发短信时应该都能发现，一些很长的短信，是不能够像我们常用的社交软件（比如微信和 QQ）一样以一条消息发送的，它会被分割成多条短信进行发送，一般每单位短信最多是 140 个英文字符或者是 70 个汉字符，并且按条收费。 不过不用担心自己处理起来会复杂，Android 系统提供了 API，我们直接调用就好。 /** * 发送短信 * * @param tel 收件人号码 * @param text 短信内容 */ private void sendSms(String tel, String text) { if (TextUtils.isEmpty(tel)) { return; } if (TextUtils.isEmpty(text)) { return; } SmsManager manager = SmsManager.getDefault(); ArrayList&lt;String&gt; messages = manager.divideMessage(text); for (String message : messages) { manager.sendTextMessage(tel, null, message, null, null); } } 首先是对电话号码和短信内容进行判空，然后获取 SmsManager 实例，并且调用它的 divideMessage() 对短信进行分割，分割后会返回给我们一个存放了短信片段的 ArrayList 对象，我们遍历这个 ArrayList，对每个短信片段都执行 sendTextMessage() 发送。 我尝试过不调用 divideMessage() 对短信进行分割，直接传入长内容到 sendTextMessage() 方法，发现系统会自动帮我们做内容切割。 sendTextMessage() 有两个重载方法，内部都是调用 sendTextMessageInternal() 去处理： public final class SmsManager { public void sendTextMessage(String destinationAddress, String scAddress, String text, PendingIntent sentIntent, PendingIntent deliveryIntent) { sendTextMessageInternal( destinationAddress, scAddress, text, sentIntent, deliveryIntent, true, getOpPackageName(), getAttributionTag(), 0L ); } public void sendTextMessage(@NonNull String destinationAddress, @Nullable String scAddress, @NonNull String text, @Nullable PendingIntent sentIntent, @Nullable PendingIntent deliveryIntent, long messageId) { sendTextMessageInternal( destinationAddress, scAddress, text, sentIntent, deliveryIntent, true, getOpPackageName(), getAttributionTag(), messageId ); } } 简单说下这几个参数的作用。destinationAddress 就是收件人号码；scAddress 指短信服务中心号码，如果为 null 就会使用当前默认的短信服务中心，text 就是要发送的内容；sentIntent 是一个 PendingIntent 对象，用于监听短信发送是否成功，如果不为 null，在短信发送成功或失败时系统会广播此 PendingIntent；deliveryIntent 也是个 PendingIntent 对象，用于监听短信接收是否成功，如果不为 null，在将消息传递给收件人时系统会广播此 PendingIntent；messageId 是唯一标识请求发送的消息 ID，用于记录和诊断，默认为 0。 上方示例代码中，我对两个 PendingIntent 的参数都传入了 null，即不监听短信发送和接收结果，但上线过程中的确有遇到发送失败的情况，所以为了更好的排查问题，建议实际开发还是要把这两个监听加上，写个 BroadcastReceiver 判断结果处理即可，并不复杂，这里就不演示了。 短信分割的形式，实际上是 2G 时代的产物，当时大家基本上用的都是小灵通诺基亚，屏幕尺寸也就 3 英寸左右（第一代 Android 手机 HTC G1 为 3.17 英寸），显示的区域小无可厚非，但放到现在的 5G 时代来看，可以说是完全没必要的，现在市面上基本都是 5 英寸以上的大屏手机，短信分割交互非常不友好。 于是我查阅文档，发现系统在 Android 4.4（KitKat，API 19）提供了新的方法，允许我们将长信息以一条的样式发送，所以我们上面的方法可以改为： /** * 发送短信 * * @param tel 收件人号码 * @param text 短信内容 */ private void sendSms(String tel, String text) { if (TextUtils.isEmpty(tel)) { return; } if (TextUtils.isEmpty(text)) { return; } SmsManager manager = SmsManager.getDefault(); ArrayList&lt;String&gt; messages = manager.divideMessage(text); manager.sendMultipartTextMessage(tel, null, messages, null, null); } 主要是改用了 sendMultipartTextMessage() 方法来发送短信，参数及逻辑与 sendTextMessage() 比较类似，同样是需要对短信进行分割，分割后得到的 ArrayList 对象不需要我们手动遍历发送，直接交给 sendMultipartTextMessage() 方法处理。 这里注意，我上面的描述是以一条的「样式」发送，实际上，运营商的计费规则没有变化，当内容过长时，它依然会对内容进行分割，按分割的条数计费。只不过在短信 App 显示时，它会以一条的样式进行展示。 ","link":"https://LiarrDev.github.io/post/How-to-Send-SMS-Message-in-Android/"},{"title":"Design Pattern: Singleton Pattern","content":"在有些系统中，为了节省内存资源、保证数据内容的一致性，对某些类要求只能创建一个实例，这就是所谓的 Singleton Pattern，也就单例模式。 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例，这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个 Printer Spooler，以避免两个打印作业同时输出到打印机中；每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。 在 Android 开发中，我们常用的网络请求框架『OkHttp』，官方就建议 OkHttpClient 实例仅新建一次，所以我们也可以做成单例模式。 总之，选择单例模式就是为了避免不一致状态，避免政出多头。 特点 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 优缺点 优点 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 避免对资源的多重占用（比如写文件操作）。 可以在系统设置全局的访问点，优化和共享资源访问（比如可以设计一个单例类负责所有数据表的映射处理）。 缺点 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。 实现 通常，普通类的构造函数是公有的，外部类可以通过 new 构造函数来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。 结构如下： 单例模式有多种创建的方式，各有利弊，最常用的有懒汉式和饿汉式，下面一一讲解。 Lazy：懒汉式 懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急，一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。 public class Singleton { private static Singleton instance; private Singleton () {} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作，是线程不安全的创建方式。 我们可以改进一下： public class Singleton { private static Singleton instance; private Singleton () {} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效，因为在任何时候只能有一个线程调用 getInstance() 方法，而同步操作只在第一次调用时才被需要，即第一次创建单例实例对象时，所以会造成不必要的同步开销。 这就引出了双重检验锁。 Double-Checked Locking：双重检验锁 双重检验锁模式（Double-Checked Locking Pattern）是一种使用同步块加锁的方法，程序员称其为双重检查锁，因为会有两次检查实例是否为 null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。 public class Singleton { private static Singleton instance; private Singleton () {} public static Singleton getSingleton() { if (instance == null) { // Single Checked synchronized (Singleton.class) { if (instance == null) { // Double Checked instance = new Singleton(); } } } return instance; } } 这段代码看起来很完美，很可惜，它是有问题。主要在于 instance = new Singleton() 这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情: 给 instance 分配内存； 调用 Singleton 的构造函数来初始化成员变量； 将 instance 对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。 但是，在 JVM 的即时编译器中存在指令重排序的优化，也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1→2→3，也可能是 1→3→2。如果是后者，则在 3 执行完毕且 2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。 其实只需要将 instance 变量声明成 volatile 就可以了。 public class Singleton { private volatile static Singleton instance; // 声明成 volatile private Singleton () {} public static Singleton getSingleton() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。 但其实是不对的，使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1→2→3 之后或者 1→3→2 之后，不存在执行到 1→3 然后取到值的情况。 从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。 特别注意，在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM（Java Memory Model，Java 内存模型）是存在缺陷的，即使将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。 相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。 Hungry：饿汉式 饿汉式其实是一种比较形象的称谓。既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。 这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。 public class Singleton { private static final Singleton instance = new Singleton(); // 类加载时就初始化 private Singleton() {} public static Singleton getInstance() { return instance; } } 缺点是它不是一种懒加载模式（Lazy Initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance() 方法。 饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。 Static Nested Class：静态内部类 这种方法也是《Effective Java》上所推荐的。 public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton () {} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 这种写法仍然使用 JVM 本身机制保证了线程安全问题。由于静态单例对象没有作为 Singleton 的成员变量直接实例化，因此类加载时不会实例化 Singleton，第一次调用 getInstance() 时将加载内部类 SingletonHolder，在该内部类中定义了一个 static 类型的变量 INSTANCE，此时会首先初始化这个成员变量，由 Java 虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于 getInstance() 方法没有任何线程锁定，因此其性能不会造成任何影响。 由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。 Enum：枚举 用枚举写单例实在太简单了！这也是它最大的优点。 public enum Singleton { INSTANCE; } 我们可以通过 Singleton.INSTANCE 来访问实例，这比调用 getInstance() 方法简单多了。创建枚举默认就是线程安全的，所以不需要担心 Double Checked Locking，而且还能防止反序列化导致重新创建新的对象。 这种实现方式实际上还没有被广泛采用，但这是实现单例模式的最佳方法，同时也是《Effective Java》作者 Josh Bloch 提倡的方式。不过，由于 Java 5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 总结 一般情况下，单例模式有上述五种实现方法，也都给出了线程安全的实现。 大多数情况下直接使用饿汉式即可；如果明确要求要懒加载（Lazy Initialization）倾向于使用静态内部类，不建议直接使用懒汉式；如果涉及到反序列化创建对象时会试着使用枚举的方式来实现；如果有其他特殊的需求，可以考虑使用双检锁方式。 ","link":"https://LiarrDev.github.io/post/Design-Pattern-Singleton/"},{"title":"Windows 平台 Flutter 开发环境搭建笔记","content":"最近闲来无事，想看看 Flutter。 Flutter 的背景就不过多介绍了，它最直接对标的跨平台移动应用程序框架就是 Facebook 旗下的 React Native。今天介绍的是 Flutter 在 Windows 中的开发环境搭建，如果想了解 React Native 的环境搭建，可以参考之前的『Windows 平台 React Native 开发环境搭建笔记』。 下面进入正题。 注：撰文时 Flutter 的版本为 2.10.4。 准备 Flutter SDK 前往官网下载即可。 官方提供了 Windows、macOS、Linux 和 Chrome OS 四个平台的开发套件。 同时还考虑到中国开发者的特殊情况，贴心地标注了「Using Flutter in China」。 将下载好的压缩包解压到你想要安装的路径。注意：路径不能包含特殊字符，且不要安装到如 C:/Program Files/ 等高权限路径。 接下来，将 ./flutter/bin 目录添加到环境变量： 因为一些 Flutter 命令需要联网获取数据，由于众所周知的原因，在国内直接访问很可能不会成功，不过没关系，Google 为国内开发者搭建了临时镜像。你可以将如下环境变量加入到用户环境变量中： ➜ export PUB_HOSTED_URL=https://pub.flutter-io.cn ➜ export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 官方文档到这里就会让你执行 Flutter 命令，但我不建议这么做，我们可以先把开发的 IDE 也装上。 Android Studio 官方支持使用『Android Studio』、『IntelliJ IDEA』和『Visual Studio Code』等 IDE 来开发，由于我本身就是 Android 开发者，所以还是继续用『Android Studio』就好。 建议使用最新版。 『Android Studio』可以很方便地帮我们下载所需的 Android SDK，减少手动配置的麻烦。 同时，你还需要在『Android Studio』中安装 Flutter 插件： 在插件市场中搜索安装即可，安装 Flutter 插件的同时，它会帮你自动安装 Dart 插件。 初始化环境 在『CMD』或者『Powershell』中运行以下命令： ➜ flutter doctor 注意，目前 Flutter 不支持像『Git Bash』这样的第三方 Shell。 上述命令会检查你的现有环境，并将检测结果以报告形式呈现出来。仔细阅读它显示的内容，检查是否有尚未安装的软件或是有其他的步骤需要完成（通常会以粗体呈现）。 比如我执行完，会得到如下结果： 可以看到，目前 Flutter SDK、『Android Studio』和『IntelliJ IDEA』我是安装完成的，同时也连接了设备。 然后看未配置的项。 「Android toolchain」一项提示 cmdline-tools component is missing，同时它还提供了一个安装命令给我们。我们不需要参考它的命令，直接打开『Android Studio』的「SDK Manager」，安装「Android SDK Command-line Tools」即可。 「Android toolchain」一项同时还提示 Android license status unknown。出现该提示的原因是，在使用 Flutter 前，你必须同意 Android SDK 平台的协议，执行以下命令进行协议确认： ➜ flutter doctor --android-licenses 接下来看到提示『Chrome』和『Visual Studio』未安装，因为 Flutter 不仅支持移动端（Android 和 iOS）的跨平台开发，同时也支持桌面平台（Windows、macOS、Linux）和 Web 平台的开发，所以会报出该错误，不过由于我目前仅需要开发 Android 和 iOS 的跨平台移动应用，所以这两项缺失并不会对我造成影响，无需理会。 最后一项「HTTP Host Availability」提示连接 https://maven.google.com/ 超时，这是因为众所周知的原因国内无法访问到该域名，解决的方法也有很多种。 我参考的是『Android Studio』内的处理方式，目前『Android Studio』内部「SDK Update Sites」使用的都是 https://dl.google.com/ 这个域名，日常使用没有问题，证明这个域名是可通的。 那我也可以将 Flutter 的下载切到这个源上。在 Flutter SDK 安装目录中打开 ./packages/flutter_tools/lib/src/http_host_validator.dart 文件，将 https://maven.google.com/ 修改为 https://dl.google.com/dl/android/maven2/ 并保存，然后删除 ./bin/cache 文件夹。实际上国内镜像源也很多，你可以切到其他镜像源上，比如阿里云等。 问题解决完了，接下来重新执行 flutter doctor。 可以看到上面的问题都正确处理了。 建立项目 上面的配置没问题后，就可以创建项目了，『Android Studio』支持直接创建 Flutter 项目。 初次创建可能需要配置 Flutter SDK 的路径。 简单填写一下项目的信息，就可以创建了。 这里有一个需要注意的点，就是项目名称不能使用大写，这是与常规 Android 项目不一致的地方，只能使用小写字母以及下划线，否则会提示错误。 创建成功之后你可以在上方工具栏中选择你的设备运行项目。 我初次运行的时候，报了以下错误： FAILURE: Build failed with an exception. * What went wrong: Execution failed for task ':app:stripDebugDebugSymbols'. &gt; NDK at D:\\AndroidSDK\\ndk-bundle did not have a source.properties file 大概意思就是 NDK 没有正确配置，我尝试在 /android/local.properties 文件中添加 NDK 的路径，并没有奏效。 需要前往 /android/app/build.gradle 中修改： android { ... defaultConfig { ... ndkVersion = &quot;22.0.6917172&quot; } } 添加 NDK 的版本即可，这个 NDK 版本可以从本地获取，打开 Android SDK 目录，在 ./ndk 文件夹下可以找到以版本号命名的文件夹。 比如我这里有两个，我就复制最新的填上去。 假如你本地没有 NDK，可以前往『Android Studio』的「SDK Manager」中下载。 添加了 NDK 版本信息后，就可以运行了，Flutter 相比原 Android 项目有一个不同，就是修改 build.gradle 文件不需要手动 Sync。 运行效果如下： Flutter 的默认 Demo 不是「Hello World」，而是一个计数器，通过点击右下方的 FloatingActionButton 来对屏幕中间的数进行自增。 Hot Reload 我们还可以体验一下 Flutter 的 Hot Reload 功能。 打开 ./lib/main.dart 文件，整个页面的代码就在这个文件中，MyApp 代码如下： class MyApp extends StatelessWidget { const MyApp({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: const MyHomePage(title: 'Flutter Demo Home Page'), ); } } 可以看到默认设置的主题色为 Colors.blue，我们将其修改为 Colors.green，然后保存文件（快捷键不用我教吧）或者点击工具栏上的闪电状 Hot Reload 按钮： 应用不需要重启，直接就改变了颜色： 总结 不难看出，相比 React Native 的开发环境搭建，Flutter 要轻松许多，这是好事，避免许多开发者在搭建环境的时候就劝退情况。 目前看来，Flutter 推广的门槛在于 Dart 语言。 不管怎么样，我依然看好 Flutter 的生态。 参考内容 Flutter - Build apps for any screen Flutter 中文开发者网站 | Flutter —— 为所有屏幕构建精美应用 ","link":"https://LiarrDev.github.io/post/Set-up-Flutter-Development-Environment-on-Windows/"},{"title":"Android 接入 QQ 加群组件","content":"为了增加玩家粘性，我们在游戏 SDK 内集成了一键加群的功能。 其实一键加群的功能并不难实现，只要『QQ』客户端给我们开放了相关的入口即可，在『QQ群』官网中我们可以看到有「加群组件」，就是它了。 登录后选择对应的群，它就会自动为我们在右边生成代码段，我们只需根据自己的平台复制对应的代码到自己的项目中即可。 Android 平台生成的代码段大概是这样的： /**************** * * 发起添加群流程。群号：*****群(965***949) 的 key 为： lTK**************************HTg * 调用 joinQQGroup(lTK**************************HTg) 即可发起手Q客户端申请加群 *****群(965***949) * * @param key 由官网生成的 key * @return 返回 true 表示呼起手Q成功，返回 false 表示呼起失败 ******************/ public boolean joinQQGroup(String key) { Intent intent = new Intent(); intent.setData(Uri.parse(&quot;mqqopensdkapi://bizAgent/qm/qr?url=http%3A%2F%2Fqm.qq.com%2Fcgi-bin%2Fqm%2Fqr%3Ffrom%3Dapp%26p%3Dandroid%26k%3D&quot; + key)); // 此Flag可根据具体产品需要自定义，如设置，则在加群界面按返回，返回手Q主界面，不设置，按返回会返回到呼起产品界面 // intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) try { startActivity(intent); return true; } catch (Exception e) { // 未安装手Q或安装的版本不支持 return false; } } 这段代码的重点其实是 QQ 群号码所生成的 key，我们只需要传入这个 key 即可，通过 URI 的方式拉起『QQ』客户端的 QQ 群资料页面，『QQ』客户端会解析这个 key 并加载对应的群信息。 效果如下： 该代码段十分简单，用到的知识点就是隐式 Intent。 我们可以查看一下『QQ』的 AndroidManifest.xml 文件，很容易找到其配置： &lt;manifest ... package=&quot;com.tencent.mobileqq&quot;&gt; ... &lt;application ...&gt; ... &lt;activity ... android:name=&quot;com.tencent.mobileqq.activity.JumpActivity&quot;&gt; ... &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;mqqopensdkapi&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; &lt;/manifest&gt; 『QQ』客户端在 JumpActivity 中响应第三方应用的隐式 Intent，处理唤起请求，除了该功能用到的 mqqopensdkapi 协议外，还定义了其他各种各样的协议，比如 mqqverifycode、mqqapi 等等，JumpActivity 在内部再根据不同的 Intent 做相应的处理。 ","link":"https://LiarrDev.github.io/post/Access-Join-QQ-Group-Component-in-Android/"},{"title":"Android 自定义「年月选择器」","content":"在之前『Android 日期选择器』中介绍了 DatePicker 和 DatePickerDialog 的使用方法，可以满足我们平时开发中对日期选择的需要，日历卡的样式也十分讨喜。 但是，需求是万变的。我们假设这么一种场景，比如说我在做一个软件，用户可以查看以往的月度账单，『支付宝』就有类似的功能： 那么就需要有一个可以选择年份和月份但却没有具体日的功能，怎么实现？ Android 原生并没有类似的控件，所以必须要自己实现。其实对于月份，你完全可以手动把 12 个月都写进去，但是对于年份，你就无能为力了，因为年份理论上来说是一个无穷数，假设你这个软件可以使用 60 年，那么就至少要录入 60 个年份，重复而无意义的工作。 我们能否定制一个类似 DatePicker 的月份选择器呢？ 看上去，『支付宝』的月份选择器和 DatePicker 很相像，区别在于去掉了日子列表。二者之间如此相似，是否意味着两者可能并非偶然撞衫，而是本来系出一源呢，我们只需要在 DatePicker 中隐藏日子的滚轮，即可实现移花接木的效果。 public class MonthPicker extends DatePicker { public MonthPicker(Context context, AttributeSet attrs) { super(context, attrs); ViewGroup viewGroup = (ViewGroup) ((ViewGroup) getChildAt(0)).getChildAt(0); int groupChildCount = viewGroup.getChildCount(); if (groupChildCount == 3) { viewGroup.getChildAt(1).setVisibility(GONE); } else if (groupChildCount == 5) { viewGroup.getChildAt(2).setVisibility(GONE); viewGroup.getChildAt(3).setVisibility(GONE); } } } 定义 MonthPicker 继承自 DatePicker，在构造方法中把显示日子的 View 去掉即可。这里做了一个判断分支，因为不同手机上的可能有不同的显示效果： 有些手机显示“月 日 年”三列，那我们就把“日”的列去掉，有些手机显示“月 | 日 | 年”五列，也就是每项中间会有一个分割线分开，那么我们就把“日”的列和分割线一起去掉。 在布局文件中，因为 MonthPicker 继承自 DatePicker，所以基本按照 DatePicker 的属性设置即可： &lt;com.picker.MonthPicker android:id=&quot;@+id/month_picker&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:calendarViewShown=&quot;false&quot; android:datePickerMode=&quot;spinner&quot; /&gt; 这里记得要设置为滚轮样式并隐藏日历卡样式，否则是无法呈现正常效果的。 最终效果如下： 可以看到，获取到的日期也是和 DatePicker 同样的格式，参照『Android 日期选择器』一文，做好相应的截取操作即可。 但是，“月 日 年”听起来是不是有点别扭，没错，这一般是西方国家的使用方法，中国一般会使用“年 月 日”这种说法，所以，当你把语言切换到中文后，就会出现这种情况： 你会尴尬地发现，我们在上面的方法中截掉了“月份”这一项，这就十分离谱了，所以还需要为 MonthPicker 做一些国际化的适配： public final class MonthPicker extends DatePicker { public MonthPicker(Context context, AttributeSet attrs) { super(context, attrs); ViewGroup viewGroup = (ViewGroup) ((ViewGroup) getChildAt(0)).getChildAt(0); int groupChildCount = viewGroup.getChildCount(); switch (Locale.getDefault().getLanguage()) { case &quot;zh&quot;: if (groupChildCount == 3) { viewGroup.getChildAt(2).setVisibility(GONE); } else if (groupChildCount == 5) { viewGroup.getChildAt(3).setVisibility(GONE); viewGroup.getChildAt(4).setVisibility(GONE); } break; case &quot;en&quot;: if (groupChildCount == 3) { viewGroup.getChildAt(1).setVisibility(GONE); } else if (groupChildCount == 5) { viewGroup.getChildAt(2).setVisibility(GONE); viewGroup.getChildAt(3).setVisibility(GONE); } break; ... } } } 我的做法是通过 Locale 获取当前语言名称，如果当前语言为中文，则截掉处在末端的 View，如果当前语言为英文，则截掉处在中间的 View。修改后中文语言下的效果如下： 如果想适配更多语言，只需继续添加 CASE 即可，如果有国家是用“日 月 年”的写法，则再添加截掉处在首位的 View 的逻辑。 ","link":"https://LiarrDev.github.io/post/Customizes-MonthPicker-in-Android/"},{"title":"用好手机系统自带的邮件客户端","content":"不知道现在还有多少人在使用 Email 这个东西，它可以称作是互联网之初最伟大的发明之一，随着 IM 的兴起，Email 也随之走向没落。 尽管如此，Email 依然是当今互联网中不可代替的存在，这点在互联网企业中尤为明显。 许多互联网企业的工单系统、招聘流程等，都依赖于 Email，甚至信用卡的账单，都可以通过 Email 来传达，在 IM 便捷的年代，Email 这种相对落后的通讯工具，反而显得更加庄重。 你是否曾注意过，实际上每台手机上都自带了一个邮件应用，而你，又是否使用过它呢？ 我见过许多邮件重度用户往往都是直接下载一个所注册的邮箱官方推出的应用，比如『QQ 邮箱』、『Outlook』、『Gmail』等等，而几乎不曾见过他们使用手机系统自带的邮箱应用。 当然，使用所注册邮箱的官方应用无可厚非，毕竟上手门槛低，即下即用。 不过你们也知道，如果一个应用能解决的事情，我是不会下载第二个应用的，接下来就教你如何正确使用手机系统自带的邮件客户端。 很多人可能都没有打开过这个应用，实际上现在的系统邮件应用对各种第三方的邮箱支持都挺好的，比如小米的系统邮箱应用就支持了常用的『QQ 邮箱』、『网易邮箱』、『Outlook』、『Gmail』等等： 我下面以『QQ 邮箱』为例，教大家如何配置： 一般邮箱如果不使用官方应用的话，都需要开启 POP3/IMAP/SMTP/Exchange/CardDAV/CalDAV 服务，简单来说，这些是邮件传输协议，具体的介绍就不在这里展开了，因为涉及到 TCP/IP 协议族等复杂的计算机知识，有兴趣的话可以自行研究。 这些服务在哪里开启呢？我们打开所注册邮箱的官网并登录账号，在邮箱设置中找到「账户」菜单： 里面就会有相关服务的设置： 开启哪一个服务一般取决于系统支持，大多数情况下 POP3 和 IMAP 都是支持的，你可以查看该设置项下的介绍以及系统邮件应用的帮助来了解应该开启哪项服务。 可以在上图中看到，我开启的是 POP3/SMTP 服务。 这里插播一句，我在开通『QQ 邮箱』的 POP3/SMTP 服务时是真的历尽艰辛，因为它要求我绑定密保手机，而绑定密保手机又要求提供资料进行身份验证。当我提供了尽可能多的资料后，我依然无法向腾讯证明我是我。 如果你遇到了同样的问题，不要慌，找腾讯客服申诉即可，解决问题的效率很高： 然后就可以回到邮箱官网继续进行设置，『QQ 邮箱』会要求你用密保手机发送一条短信到指定号码： 完成后，邮箱会生成一个授权码： 这时候再回到手机系统的邮箱应用，在密码框中输入上面生成的授权码，就能够成功登录邮箱了： 另外，系统邮箱应用还支持添加多个账号，让你的所有邮箱账号都能够在一个应用中管理。 通过简单的配置，你既可以通过该系统邮箱应用轻松收发和管理邮件，也不用额外下载一个第三方的邮箱应用，减少内存占用，何乐而不为。 ","link":"https://LiarrDev.github.io/post/Mastering-Smartphone-Built-in-Email-App/"},{"title":"Android WebView 和 JavaScript 交互","content":"Hybrid 开发已经成为一种常态了，根据百度百科释义： Hybrid App（混合模式移动应用）是指介于 web-app、native-app 这两者之间的 app，兼具“Native App 良好用户交互体验的优势”和“Web App 跨平台开发的优势”。 尽管我对「兼具“Native App 良好用户交互体验的优势”」持保守意见，但毋庸置疑，「跨平台开发的优势」让当今市场上绝大多数的应用都使用了 Hybrid 开发技术。 Hybrid 开发方案的流行，也衍生了许多第三方框架，如 QuickHybrid 等，但更多开发者仍然选择自行实现 Hybrid。 在 Android 中，Hybrid 开发就是使用 WebView 控件加载 H5 链接，由于 Android 端使用的语言是 Java 或 Kotlin，而 H5 端使用的是 JavaSrcipt，两者没有办法直接互相调用，所以 Hybrid 开发的核心实际上就是两者之间的控制桥。 JavaScript 调用 Android 因为是在移动平台使用，所以 H5 端调用原生平台的能力更为常用。 首先需要在 Android 端创建一个提供交互方法的类，如： public class JsInterface { @JavascriptInterface public void toast(String msg) { Toast.makeText(AppUtil.getContext(), msg, Toast.LENGTH_SHORT).show(); } } 有三个注意的点：一是方法必须添加 @JavascriptInterface 注解；二是方法的参数仅可为 JavaScript 能够提供的类型，比如上方的的 Toast 需要传入 Context 对象，这个对象是 Android 平台提供的，总不能找 H5 要吧；三是方法的返回值同样也仅能为 JavaScript 可用类型，理由同上。 然后，我们配置 WebView 使其能够调用上面的方法： public class WebActivity extends AppCompatActivity { ... WebView webView; @Override protected void onCreate(Bundle savedInstanceState) { ... webView.getSettings().setJavaScriptEnabled(true); webView.addJavascriptInterface(new JsInterface(), &quot;android&quot;); ... } } 因为启用 JavaScript 可能会在应用程序中引入 XSS 漏洞，从而产生安全问题，所以 WebView 默认情况下是禁止 JavaScript 调用的，可以通过 setJavaScriptEnabled() 开启，然后调用 addJavascriptInterface() 将刚刚的交互类添加进来，该方法接收两个参数，第一个就是刚刚的交互类的对象，第二个参数是是 Android 端和 H5 端约定的一个字符串，通过这个约定的字符串“暗号”，能够让 H5 端通过 JavaScript 调用 Android 端提供的方法。 最后，在 H5 端调用即可： &lt;html&gt; &lt;script type=&quot;text/javascript&quot;&gt; ... function toastMessage(message) { android.toast(message) } &lt;/script&gt; ... &lt;/html&gt; 调用方法就是使用刚刚约定好的字符串“暗号”拼接 . 以及 Android 端提供的方法名称即可。 Android 调用 JavaScript Android 调用 JavaScript 几乎都是通过字符串操作的，不像 JavaScript 调用 Android 一样通过类似函数的写法，所以写起来比较容易出错。 无返回值调用 首先在 H5 端创建一个能够给 Android 端调用的方法： &lt;html&gt; &lt;script type=&quot;text/javascript&quot;&gt; ... function alertMessage(msg) { alert(msg) } &lt;/script&gt; ... &lt;/html&gt; 然后 Android 端在合适的时机调用即可： public class WebActivity extends AppCompatActivity { WebView webView; ... public void alertMessage(String msg) { webView.loadUrl(&quot;javascript:alertMessage('&quot; + msg + &quot;')&quot;;); } } 同样是通过 loadUrl() 方法执行，传入 javascript: 拼接方法名称组成的字符串，需要两个点：一是如果有参数，同样要传入 JavaScript 能够处理的类型，理由同上文所述；二是假如传入的参数为字符串，可以使用单引号 ' 代替双引号 &quot;，如果想要使用双引号 &quot;，记得转义。 有返回值调用 由于通过 loadUrl() 方法调用 JavaScript 函数，没有办法直接获取返回值。 Android 4.4 之前并没有提供直接调用 JavaScript 函数并获取值的方法，所以在此之前，常用的思路是 Java 调用 JavaScript 方法，JavaScript 方法执行完毕后 H5 端再次调用 Android 端代码将值返回。 但是现在，有了更好的方法。 首先依然是现在 H5 端创建一个能够给 Android 端调用的方法： &lt;html&gt; &lt;script type=&quot;text/javascript&quot;&gt; ... function sum(m, n) { return m + n } &lt;/script&gt; ... &lt;/html&gt; 然后 Android 端在合适的时机调用即可： public class WebActivity extends AppCompatActivity { WebView webView; ... public void sum(m, n) { webView.evaluateJavascript(&quot;sum(&quot; + m + &quot;, &quot; + n + &quot;)&quot;, new ValueCallback&lt;String&gt;() { @Override public void onReceiveValue(String value) { System.out.println(value); } }); } } 改为使用 evaluateJavascript() 方法执行 JavaScript 函数，并在回调中获取返回值。 有两个需要注意的点：一是回调中限定了返回值的类型为 String，对于简单的类型会尝试转换成字符串返回，对于复杂的数据类型，建议以字符串形式的 JSON 返回；二是 evaluateJavascript() 需要 UI 线程调用，因此 onReceiveValue() 回调也执行在主线程。 ","link":"https://LiarrDev.github.io/post/Interactin-with-JavaScript-in-Android-WebView/"},{"title":"Android 为 EditText 设置错误提示浮窗","content":"之前的开发中，对于 EditText 的输入错误提醒，我常使用 Dialog 进行展示，如： 相比 Toast 而言，这是一种比较合适的交互，用户可以清楚地了解到为何自己的输入不合法，而不会因 Toast 显示时间太短导致错过具体信息。 但是，有一点不好的是增加了用户的点击成本。 当然也可以通过设定 Dialog 定时自动关闭来降低点击成本，不过由于 Dialog 在显示的时候会抢夺焦点，导致下方的 Activity 无法获取输入，所以这个成本并没有实际降低。 EditText 其实为我们提供了一种比较优雅的提示方式，它可以使用浮窗对非法输入进行提示，只需一行代码，比如用户输入为空，我们可以这样写： if (TextUtils.isEmpty(editText.getText().toString())) { editText.setError(&quot;Content cannot be empty!&quot;); } 在用户输入为空时，系统就会给出相应的提示： 用户可以查阅提示信息的同时，又不会增加点击成本，很友好。 用法就这么简单，但如果文章这样结束就太草率了。 我们跟踪一下 setError() 方法的源码会发现，这个方法并不来源于 EditText，而是来源于其父类 TextView： @RemoteView public class TextView extends View implements ViewTreeObserver.OnPreDrawListener { ... /** * Sets the right-hand compound drawable of the TextView to the &quot;error&quot; * icon and sets an error message that will be displayed in a popup when * the TextView has focus. The icon and error message will be reset to * null when any key events cause changes to the TextView's text. If the * &lt;code&gt;error&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the error message and icon * will be cleared. */ @android.view.RemotableViewMethod public void setError(CharSequence error) { if (error == null) { setError(null, null); } else { Drawable dr = getContext().getDrawable(com.android.internal.R.drawable.indicator_input_error); dr.setBounds(0, 0, dr.getIntrinsicWidth(), dr.getIntrinsicHeight()); setError(error, dr); } } } 如果你尝试直接对 TextView 调用 setError() 方法，会看到 TextView 虽然可以展示右侧的红色感叹号，但是并无法展示传入的内容： 不过只需认真阅读 setError() 方法上的注释，你就会发现其中的端倪，仅当 TextView 拥有焦点时 Error Message 才会显示，这也是为什么 EditText 能够直接显示的原因，因为 EditText 本身就拥有焦点： &lt;resources&gt; ... &lt;style name=&quot;Widget.EditText&quot;&gt; &lt;item name=&quot;focusable&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;focusableInTouchMode&quot;&gt;true&lt;/item&gt; ... &lt;/style&gt; &lt;/resources&gt; 也就是说，只要我们给 TextView 手动配置焦点，它也能够正常显示： textView.setFocusableInTouchMode(true); textView.requestFocus(); textView.setError(&quot;Error Message&quot;); 效果如下： 从注释中我们还能看到，当传入的错误信息为 null 时，错误信息和图标能够被清除。 噢对了，setError() 还提供了重载方法允许我们自行设置图标，实际上，上面的单个参数的 setError() 内部调用的也是这个重载方法： @RemoteView public class TextView extends View implements ViewTreeObserver.OnPreDrawListener { ... /** * Sets the right-hand compound drawable of the TextView to the specified * icon and sets an error message that will be displayed in a popup when * the TextView has focus. The icon and error message will be reset to * null when any key events cause changes to the TextView's text. The * drawable must already have had {@link Drawable#setBounds} set on it. * If the &lt;code&gt;error&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, the error message will * be cleared (and you should provide a &lt;code&gt;null&lt;/code&gt; icon as well). */ public void setError(CharSequence error, Drawable icon) { createEditorIfNeeded(); mEditor.setError(error, icon); notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED); } } 该重载方法需要传入一个 Drawable 对象，特别注意的是，该 Drawable 对象必须要调用 setBounds() 进行配置，本质上与我们之前在『Android 为 TextView 或 EditText 添加 ICON』介绍的差不多。 效果如下： 更深入的源码就不在本文继续解析了，有兴趣可以自行查阅。 ","link":"https://LiarrDev.github.io/post/Sets-Error-Floating-Window-for-Android-EditText/"},{"title":"Android 中各尺寸单位的区别","content":"众所周知，Android 设备厂商非常多，各种尺寸的 Android 手机、平板层出不穷，屏幕分辨率也各有出入。 Google 为了解决分辨率过多的问题，在 Android 开发文档中定义了多种衡量尺寸的单位，方便开发者适配不同分辨率的 Android 设备。 尺寸单位 in Inches，不难理解，就是英寸，基于屏幕的物理尺寸。1in=2.54cm。 mm Millimeters，也就是毫米，基于屏幕的物理尺寸。不用多解释。 px Pixels，即像素。我们用放大镜看显示屏，发现图像是由一个个小点组成的，这些小点就是像素点。 像素是图像的基本采样单位，它不是一个准确的物理量，因为像素点的物理大小是不确定的，像素也不是一个具体的点或者小方块（尽管可以用点和小方块来呈现），而是一个抽象的概念。 我们常说的手机分辨率就是指屏幕像素的数量，这就很好理解它的物理大小不确定的这句话了，比如一个屏幕比例为 16:9 的 5.5-inch 的手机，它的分辨率既可以是 1280×720 像素，也可以是 1920×1080 像素，也就是我们常说的 720P 和 1080P。 也正因为如此，px 单位并不被建议使用，因为同样像素大小的图片在不同手机显示的实际大小可能不同。 当然，你可以用在一些线条的绘制中，比如需要画 1 像素表格线或阴影线的时候。 dp / dip Density-independent Pixels，它是一种基于屏幕密度的抽象单位，密度无关像素，在不同的像素密度的设备上会自动适配。 虽然有 dp 和 dip 两种说法，实际上是同一个概念，为了和 sp 更加一致，dp 会更加常用。 要理解 dp，首先要先引入 DPI 和 PPI 这两个概念。 DPI 全称是 Dots Per Inch，即网点密度，在纸质媒介时代，我们常用网点密度来描述印刷品的打印精度。DPI 常用于“设备参数”描述（如扫描仪和打印机），例如我设置了打印的分辨率为 96DPI，那么打印机在打印过程中，每英寸（Inch）的长度打印了 96 个点（Dot），打印机在每英寸内打印的墨点数越多，图片看起来越精细。这种概念也带入到 PC 时代的 Windows 系统，Windows 系统的默认 DPI 为 96。 因此，在 Android 上你可以将其理解为对角线每英寸的像素点的个数，计算公式如下： DPI=height2+width2sizeDPI=\\frac{\\sqrt{height^{2}+width^{2}}}{size} DPI=sizeheight2+width2​​ 其中，height 和 weight 表示长宽的像素，平方和再开方其实就是勾股定理，得出对角线的像素个数，size 表示屏幕的尺寸，也就是我们常说的英寸，比如我们说这个手机是 5.5-inch 的，那么它的 size 在这里就是 5.5。 因此，屏幕同样大小的手机，分辨率越高，DPI 越高；分辨率相同，屏幕越小，DPI 越高。 前面也说了，DPI 其实面向的是印刷领域，而 PPI 面向的是计算机领域，PPI 全称是 Pixels Per Inch，即像素密度。在 Android 开发中 Drawable 文件对应的是DPI，实际上 PPI 和 DPI 的值是一样的，只是描述不同。 dp 表示的是在每英寸 160 点，即 160PPI 的屏幕上，和 px 相同长度的单位，计算公式如下： px=dp⋅PPI160px = dp \\cdot \\frac{PPI}{160} px=dp⋅160PPI​ 在 320×480 分辨率，像素密度为 160 时，1dp=1px。 在 480×800 分辨率，像素密度为 240 时，1dp=1.5px。 为什么规定 160DPI 规格的显示器上，1dp=1px？ 这个在官方文档中有给出解释，原因是因为第一款 Android 设备也就是 HTC T-Mobile G1 是属于 160DPI 的，事实上这也是 Android 1.6 之前唯一支持的屏幕配置。 HTC T-Mobile G1 准确的 DPI 并不等于160，它是 3.2-inch，320×480 分辨率，不难计算出它约为 180DPI，那为什么不使用 180DPI 作基准呢？ 原因是 180DPI 不好作适配，Android 其实为了不至于为每一个设备制造商做适配，将不同屏幕大小和不同 DPI 的设备大致划分为四类： 当然，随着设备屏幕越来越大，现在也增加了「xxhdpi」和「xxxhdpi」等，不过没关系，我们在这里只是讨论它的起源，大家可以看到 HTC T-Mobile G1 是属于「mdpi」区域的，所以也就是使用 160DPI 作基准的原因。 我们大致可以得出以下规格： 密度 密度值 代表分辨率 ldpi 120 240×320 mdpi 160 320×480 hdpi 240 480×800 xhdpi 320 720×1280 xxhdpi 480 1080×1920 不难看出，屏幕的密度值比 ldpi : mdpi : hdpi : xhdpi : xxhdpi = 0.75 : 1 : 1.5 : 2 : 3；即在「xhdpi」的密度下，1dp=2px；在「hdpi」情况下，1dp=1.5px，其他类推。 sp Scale-independent Pixels，它是 Android 中专门用来描述字体大小的单位，一般情况下，sp 的值和 dp 的值是相同的，那为什么要特地用一个新的单位来描述字体呢？ 如果你家里有老人家，或者你尝试教老年人使用智能手机时，你常常会先帮他们把字体调大，否则老人家可能会由于年纪大视力不好而看不清手机屏幕上的字。 而设置字体单位为 sp 的目的就是为了当用户调整系统设置的字体大小时，应用的字体也能够作出相应的改变。 也就是说，系统默认设置的 sp 和 dp 的大小值一致，而当用户把字体调大或调小后，这个 sp 则跟 dp 的值不一致了。 为什么 dp 不会像 sp 一样变化，这就是这两者应用对象的区别，sp 专门用于衡量字体，dp 则用来衡量控件以及间距的尺寸。那么假设有一张图片刚好填充整个屏幕，假如 dp 也像 sp 一样变化，把它调小了之后，它应该如何去显示，图片和屏幕边缘之间的空间应该由什么来填充？很不合理对吧。 pt Points，点，也是基于屏幕的物理尺寸，印刷行业常用单位，等于 1/72 英寸。 计算公式如下： 1pt=(DPI/72)px1pt=(DPI/72)px 1pt=(DPI/72)px 当『Photoshop』中新建画布的分辨率为 72DPI时，1pt=1px；当新建画布分辨率为 144DPI 时，1pt=2px。 在开发中的使用 为了更好的适配不同的屏幕，应该选择合理的单位，最常使用的，当然就是 dp 和 sp，其他几个单位虽然用得少，但既然提供了，就当然有对应的使用场景，所以应该根据当前项目作选择。 要在像素密度不同的设备上提供良好的图形质量，应该以相应的分辨率在应用中提供每个位图的多个版本（针对每个密度级别提供一个版本）。否则，Android 系统必须缩放位图，使其在每个屏幕上占据相同的可见空间，从而导致缩放失真模糊。 跟屏幕的密度比是一致的。之后，每当您引用该位图资源时，系统都会根据屏幕的 DPI 选择适当的位图。如果您没有为某个密度提供特定于密度的资源，那么系统会选取下一个最佳匹配项并对其进行缩放以适合屏幕。 如果您有一些系统绝不能缩放（或许是因为您在运行时自行对图片进行一些调整）的可绘制资源，则应将这些资源放在带有「nodpi」配置限定符的目录中。带有此限定符的资源被视为与密度无关，系统将不会对它们进行缩放。 除了创建多个特定于密度的图片版本之外，另一种方法是仅创建一个矢量图形。在借助矢量图形创建图片时，使用 XML 定义路径和颜色，而不是使用像素位图。因此，矢量图形可以缩放到任何尺寸而不会出现缩放失真，不过它们通常最适合图标等插图，而不太适合照片。 矢量图形通常以 SVG（可缩放矢量图形）文件的形式提供，但 Android 不支持此格式，因此必须将 SVG 文件转换为 Android 的矢量图格式。『Android Studio』中提供的『Vector Asset Studio』可以方便地进行转换。 另外，在合适的情况下使用矢量图形来代替位图也可以很好地达到减少安装包体积的效果。 ","link":"https://LiarrDev.github.io/post/Differences-between-Size-Units-in-Android/"},{"title":"SwitchHosts","content":"之前『Windows 修改 Hosts』和『macOS 修改 Hosts』已经详细介绍了如何在桌面平台上修改 Hosts 文件，『写个脚本给 Windows 自动添加 Hosts』也提供了一种技术人员给小白添加 Hosts 的方法，但实际上想要在公司内推广，依然十分困难，大多数人看着步骤繁琐，便束手无策。 是时候祭出大杀器，一款绝对符合小白使用习惯的 Hosts 管理工具。 『SwitchHosts』是一款可以方便你管理和一键切换多个 Hosts 方案的免费开源工具，基于 Electron，这也让它能够跨平台支持 Windows、macOS 和 Linux 系统。 它是由 80 后中年人老杰（@oldj）开发的，老杰毕业于中科大统计与金融系，曾在阿里工作超过 8 年，目前在一个小而美的团队，负责技术研发工作。 『SwitchHosts』的第一个版本发布于 2011 年，它也是老杰从事编程以来维护得最久的一个项目，目前在 Github 已经有超过 15.5K 的 Star 数，是当前 Hosts 管理这个非常小众的领域最知名的工具之一。 为什么我说『SwitchHosts』是一款绝对符合小白使用习惯的工具？因为它的操作真的非常简单：打开软件，修改文本，自动保存，没有复杂的权限。 这对于普通用户来说，大大降低了 Hosts 的配置门槛。 同时还支持夜间模式，真是照顾到像我一样的暗黑模式爱好者。 而对于高阶用户，『SwitchHosts』更是提供了各种灵活的功能特性。 它支持语法高亮，使用不同的颜色显示 IP、域名以及注释，各类信息一目了然，程序员都说好。 既然提到了注释，那就不得不说它的快捷键了，Ctrl + / 符合大多数 IDE 的热键设计，你甚至还可以直接点击行号进行注释。 方案多选功能，通过多选模式组合不同方案，完成复杂环境的配置。 在系统托盘菜单显示快捷菜单，点击可快速查看及切换 Hosts 方案。 除了本地修改 Hosts 外，还支持远程方案，可从网络下载并自动定时同步远程方案。 比如国内 Github 访问不稳定，我就配置了一个远程地址，每隔一个小时刷新一次 Hosts，这样就不用随时挂着梯子了。 考虑到团队内部的使用场景，『SwitchHosts』支持通过 JSON 文件导出和导入，配置一步到位。 『SwitchHosts』还提供了『Alfred』集成，如果你使用 macOS，可通过 Workflow 快速切换 Hosts。 它还支持代理、应用后执行命令等功能，不过多介绍了，如果你对这方面功能有需求，打开你便知道如何操作。 总的来说，『SwitchHosts』面对的不仅是对 Hosts 管理有较高需求的 Geek 玩家群体，而对于不常使用 Hosts 但被迫使用的小白也是十分友好，值得成为装机必装的软件之一。 ","link":"https://LiarrDev.github.io/post/SwitchHosts/"},{"title":"Android 动态获取 Resource ID","content":"在 Android 开发中，我们平时需要使用一些资源时，都需要传入 Resource ID。当然，这个 ID 是编译的时候自动生成的，我们不可能去手动填入这个 ID 值，而是通过 R 来获取这个 Resource ID，比如 R.layout.activity_main 或者 R.mipmap.ic_launcher 等。 但是在开发 SDK 的时候，我们并不推荐使用这种方式来开发。 为什么呢？你可能会写个 Module 打成 AAR 包验证一下并认为没有问题，的确，假如你所写的 SDK 是在你们团队内部使用的话，正常情况下的确不会有问题。 而当你的 SDK 需要提供给其他团队接入，甚至是给其他个人或公司的开发者接入，就不得不考虑兼容性问题。 假如某些开发团队需要使用 JAR 的方式来接入（可前往『「Android Studio」如何导入 AAR 包』一文了解），而你在 SDK 内部通过 R 来获取 Resource ID，很可能就会报类似下面的异常： E/AndroidRuntime: FATAL EXCEPTION: main Process: &lt;applicationId&gt;, PID: 1290 java.lang.NoClassDefFoundError: Failed resolution of: L&lt;package&gt;/R$layout; at ... Caused by: java.lang.ClassNotFoundException: Didn't find class &quot;&lt;package&gt;.R$layout&quot; on path: DexPathList[[zip file &quot;/data/app/&lt;package&gt;-7LVvXGSzJoLlgcJqzY5uYg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/&lt;package&gt;-7LVvXGSzJoLlgcJqzY5uYg==/lib/arm64, /system/lib64, /system/product/lib64, /hw_product/lib64, /system/product/lib64]] at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:196) at java.lang.ClassLoader.loadClass(ClassLoader.java:379) at ... 因为使用 JAR 的方式接入时，我们会将资源文件复制到我们项目的资源文件夹中，而不是如 AAR 一样直接引用，因此经过重新编译 AAPT（Android Asset Packaging Tool，Android 资源打包工具，可将资源文件编译成二进制文件）会给对应的资源文件生成一个新的 Resource ID。 我们在代码中通过 R 获取 Resource ID 实际上相当于将原来的 ID 硬编码到 APK 中，即 setContentView(R.layout.activity_main) 编译完成后相当于 setContentView(2131361821)（详见『Android 反编译入门指南』一文），那么新生成的 ID 和原有的 ID 不相同，自然就抛出找不到 Resource ID 的异常了。 在 SDK 中，我们常会使用动态获取 Resource ID 的方法来避免以上的坑。 Android 为我们提供了 getIdentifier() 方法： /** * Return a resource identifier for the given resource name. A fully * qualified resource name is of the form &quot;package:type/entry&quot;. The first * two components (package and type) are optional if defType and * defPackage, respectively, are specified here. * * &lt;p&gt;Note: use of this function is discouraged. It is much more * efficient to retrieve resources by identifier than by name. * * @param name The name of the desired resource. * @param defType Optional default resource type to find, if &quot;type/&quot; is not included in the name. Can be null to require an explicit type. * @param defPackage Optional default package to find, if &quot;package:&quot; is not included in the name. Can be null to require an explicit package. * * @return int The associated resource identifier. Returns 0 if no such resource was found. (0 is not a valid resource ID.) */ public int getIdentifier(String name, String defType, String defPackage) { return mResourcesImpl.getIdentifier(name, defType, defPackage); } 该方法本质上是通过反射调用实现获取资源的 int 型的 ID 数值，所以并不高效，也不鼓励使用。 我们只需传入资源名称、资源类型以及包名就可以获取到对应资源的 ID 了，比如： public class ModelActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(getResourceId(this, &quot;activity_model&quot;, &quot;layout&quot;)); } public static int getResourceId(Context context, String name, String defType) { return context.getResources().getIdentifier(name, defType, context.getPackageName()); } } 当然，我们可以封装成一个工具类，让使用更加方便： public class ResourceUtil { public static int getResourceId(Context context, String name, String defType) { return context.getResources().getIdentifier(name, defType, context.getPackageName()); } public static int getAnimId(Context context, String name) { return getResourceId(context, name, &quot;anim&quot;); } public static int getAnimatorId(Context context, String name) { return getResourceId(context, name, &quot;animator&quot;); } public static int getAttrId(Context context, String name) { return getResourceId(context, name, &quot;attr&quot;); } public static int getBoolId(Context context, String name) { return getResourceId(context, name, &quot;bool&quot;); } public static int getColorId(Context context, String name) { return getResourceId(context, name, &quot;color&quot;); } public static int getDimenId(Context context, String name) { return getResourceId(context, name, &quot;dimen&quot;); } public static int getDrawableId(Context context, String name) { return getResourceId(context, name, &quot;drawable&quot;); } public static int getComponentId(Context context, String name) { return getResourceId(context, name, &quot;id&quot;); } public static int getIntegerId(Context context, String name) { return getResourceId(context, name, &quot;integer&quot;); } public static int getInterpolatorId(Context context, String name) { return getResourceId(context, name, &quot;interpolator&quot;); } public static int getLayoutId(Context context, String name) { return getResourceId(context, name, &quot;layout&quot;); } public static int getMipmapId(Context context, String name) { return getResourceId(context, name, &quot;mipmap&quot;); } public static int getPluralsId(Context context, String name) { return getResourceId(context, name, &quot;plurals&quot;); } public static int getStringId(Context context, String name) { return getResourceId(context, name, &quot;string&quot;); } public static int getStyleId(Context context, String name) { return getResourceId(context, name, &quot;style&quot;); } public static int getStyleableId(Context context, String name) { return getResourceId(context, name, &quot;styleable&quot;); } public static int getXmlId(Context context, String name) { return getResourceId(context, name, &quot;xml&quot;); } } 使用以上封装的方法，你可以减少传入的参数，却能够更加清晰的知道自己所获取的资源类型，十分方便。 基于这个工具类，你甚至还可以实现一些有趣的骚操作，比如： ImageView[] imageViews = new ImageView[NUMBER]; for (int i = 0; i &lt; NUMBER; i++) { imageViews[i] = findViewById(ResourceUtil.getComponentId(context, &quot;image_&quot; + i)); } 当然这个例子并不那么合适，因为有更优雅的实现方式，只是想通过这个例子来表达，我们可以发挥我们的想象，来创作更多的应用场景。 ","link":"https://LiarrDev.github.io/post/Get-Android-Resource-ID-Dynamically/"},{"title":"可选择的 TextView 无法响应首次点击事件","content":"之前在『Android 使 TextView 支持长按选择』一文中介绍了使用 android:textIsSelectable 属性就能简单实现 TextView 可选择的小技巧，文末也提到实际使用的时候往往会有一些坑。 比如，当你为 TextView 设置了 android:textIsSelectable 属性的同时还设置了点击事件，那么你会发现，当首次点击 TextView 时，TextView 是不会响应的： 不难猜到，TextView 在设置了 android:textIsSelectable 属性后，对原有的 View 触摸事件监听有入侵。 我们可以继承 TextView，重写 onTouchEvent() 方法，对触摸事件重新做处理： public class SelectableTextView extends AppCompatTextView { private long mActionDownTime = 0L; public SelectableTextView(@NonNull Context context) { super(context); } public SelectableTextView(@NonNull Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public SelectableTextView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override public boolean onTouchEvent(MotionEvent event) { boolean click = false; boolean textSelectable = isTextSelectable(); switch (event.getAction()) { case MotionEvent.ACTION_DOWN: mActionDownTime = System.currentTimeMillis(); break; case MotionEvent.ACTION_UP: long actionUpTime = System.currentTimeMillis(); if (actionUpTime - mActionDownTime &lt; ViewConfiguration.getLongPressTimeout()) { setTextIsSelectable(false); performClick(); click = true; } break; } setTextIsSelectable(textSelectable); return click || super.onTouchEvent(event); } @Override public boolean performClick() { return super.performClick(); } } 代码的逻辑非常简单，首先拿到 TextView 有没有设置为可选择，并声明一个点击标识，当监听到 ACTION_DOWN 事件时，记录事件产生的时间，而当监听到 ACTION_UP 事件时，计算两次事件的时间差，假如不为长按，则将当前 TextView 设置为不可选择，再执行点击事件，并将点击标识设置为 true，不要忘了将 TextView 是否可选择的属性重置回来；假如为长按，则不需要执行我们的操作，交还给父类处理即可。最后 onTouchEvent() 需要一个返回值，当执行点击时，我们接管了事件的处理逻辑，返回 true 即可，当执行长按时，交还给父类处理。 有几个地方需要解释一下。判断是否为长按是由 ViewConfiguration 的 getLongPressTimeout() 返回值进行比较的，默认为 400ms，由 Android 系统定义，我们也可以根据实际情况自行判定。 执行点击时我先将是否可选择的属性设置为 false，是因为如果不设置的话，执行点击事件时，TextView 会莫名选中点击区域的文字： 当事件响应完之后我必须要将该属性重置回来，所以一开始就必须获取该属性的值。 最后返回值这行代码我用了简写，可能会看得有些莫名奇妙，其实只要熟悉逻辑运算符 || 就不难理解，当点击标识为 true 时，该表达式必为 true，不需要再计算后面的值，onTouchEvent() 就会直接返回 true，而当点击标识为 false 时，则会执行 super.onTouchEvent(event) 并返回其值，当然你也可以用更加易读的写法： public class SelectableTextView extends AppCompatTextView { ... @Override public boolean onTouchEvent(MotionEvent event) { boolean click = false; ... if (click) { return true; } else { return super.onTouchEvent(event); } } } 最后看看最终效果： ","link":"https://LiarrDev.github.io/post/The-Selectable-TextView-Cannot-Respond-to-the-First-Click-Event/"},{"title":"Android 使 TextView 支持长按选择","content":"我们知道，『WeChat』内可以通过双击聊天内容对文本进行选择和复制操作： 而 Android 中 TextView 在默认模式下是不支持长按选择的，那么这个操作是如何实现的呢？ 网上大多数教程都是利用自定义一个继承自 EditText 的控件来实现，或者直接在布局文件中修改 EditText 的控件属性： &lt;EditText ... android:background=&quot;@null&quot; android:editable=&quot;false&quot; android:textCursorDrawable=&quot;@null&quot; /&gt; 目的是使 EditText 取消底部横线背景、不可进行编辑以及取消游标闪烁，以达到伪装成 TextView 的效果。实际上 EditText 也的确是继承自 TextView。 宏观来说，XML 是一种可扩展标记语言，用元素和属性来描述数据，而不提供数据的显示方法。所以我个人并不太喜欢这种方式，这会给代码带来歧义。相比之下，自定义 View 还是会更合理一些。 但实际上 TextView 本身从 API 11 开始就支持长按选择，只需要设置属性即可： &lt;TextView ... android:textIsSelectable=&quot;true&quot; /&gt; 当然，也支持在逻辑中动态设置： textView.setTextIsSelectable(true); 效果如下： 虽然这种方式设置十分简单，但仅能够满足基本要求，如果需求的复杂度增加，依然会产生一些坑。 ","link":"https://LiarrDev.github.io/post/Android-TextView-Selectable-with-a-Long-Press/"},{"title":"一次实战爱上『Palette』","content":"最近在逛 Android 开发者官网的时候，发现了一个有趣的官方库 Palette，望文生义，就是调色板了，它是 Jetpack UI 组件的一部分。 为什么觉得有趣，因为它跟我们平时做图片时的取色器一样，能够从一张图片中吸取颜色。 这样说又过于笼统，实际上 Palette 是一个类似调色板的工具，能够根据传入的 Bitmap，提取出主体颜色，我们可以把提取的颜色融入到 UI 中，使 UI 风格更加美观融洽。 官方文档中就给出了一个应用场景： For example, a music app could use a Palette object to extract the major colors from an album cover, and use those colors to build a color-coordinated song title card. 例如，音乐应用可以使用 Palette 对象从影集封面中提取主要颜色，然后使用这些颜色制作颜色协调的歌曲片头字幕。 我打开 EMUI 的系统音乐应用，看到的确有用到相似的效果： 可以看到，该音乐应用随着歌曲的切换，背景和字体颜色都发生了改变，不过它这里的背景似乎并不是从图片中提取颜色，而是将专辑封面放大后添加了一个深色半透明的蒙层，但字体颜色应该是提取自封面的。 话不多说，我们来看看 Palette 的使用。 首先需要导入 Palette 的库： implementation 'androidx.palette:palette:{version}' 如果项目使用的是 Android Support 库，则该依赖也应切至 Support 版本。 Palette 可以帮助我们从图片中提取多种颜色： Vibrant Vibrant Dark Vibrant Light Muted Muted Dark Muted Light 接下来就需要一张图片，从网络获取或者丢到本地文件夹都可以，我这里选择从本地加载。 使用方法非常简单，只需要将图片转换成 Bitmap，接下来的一切交给 Palette。 Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.lake_urmia); Palette.from(bitmap).generate(new Palette.PaletteAsyncListener() { @Override public void onGenerated(Palette palette) { if (palette != null) { Palette.Swatch vibrantSwatch = palette.getVibrantSwatch(); if (vibrantSwatch != null) { vibrant.setBackgroundColor(vibrantSwatch.getRgb()); vibrant.setTextColor(vibrantSwatch.getBodyTextColor()); } Palette.Swatch darkVibrantSwatch = palette.getDarkVibrantSwatch(); if (darkVibrantSwatch != null) { vibrantDark.setBackgroundColor(darkVibrantSwatch.getRgb()); vibrantDark.setTextColor(darkVibrantSwatch.getBodyTextColor()); } Palette.Swatch lightVibrantSwatch = palette.getLightVibrantSwatch(); if (lightVibrantSwatch != null) { vibrantLight.setBackgroundColor(lightVibrantSwatch.getRgb()); vibrantLight.setTextColor(lightVibrantSwatch.getBodyTextColor()); } Palette.Swatch mutedSwatch = palette.getMutedSwatch(); if (mutedSwatch != null) { muted.setBackgroundColor(mutedSwatch.getRgb()); muted.setTextColor(mutedSwatch.getBodyTextColor()); } Palette.Swatch darkMutedSwatch = palette.getDarkMutedSwatch(); if (darkMutedSwatch != null) { mutedDark.setBackgroundColor(darkMutedSwatch.getRgb()); mutedDark.setTextColor(darkMutedSwatch.getBodyTextColor()); } Palette.Swatch lightMutedSwatch = palette.getLightMutedSwatch(); if (lightMutedSwatch != null) { mutedLight.setBackgroundColor(lightMutedSwatch.getRgb()); mutedLight.setTextColor(lightMutedSwatch.getBodyTextColor()); } } } }); 效果如下： 可以看到，Palette 从图片调色板中也解析到了对应的 6 组 Swatch，每组 Swatch 中包含了多种颜色，同时也提供了获取最终颜色的方法，其中 getPopulation() 表示样本中的像素数量，getRgb() 和 getHsl() 分别是获取颜色的 RGB 值和 HSL 值，getBodyTextColor() 和 getTitleTextColor() 则分别是该颜色下标题和正文所适合的字体颜色。 这里提几个需要注意的点。 一是注意判空，可以看到上面的示例代码中有多处判空，首先是回调得到的 Palette 有可能为空，所以要做判空，同时通过 Palette 解析得到的 Swatch 也可能为空，因为并不是所有图片的色彩都足够丰富以得到这 6 种 Swatch，如果不判空则可能会导致应用崩溃。 二是异步，Palette 除了上方示例的通过 Palette.PaletteAsyncListener() 回调的方法外，还有一个无参的 generate() 方法，不难知道知道分别是异步和同步生成。为什么需要异步，是因为图片过大或者色彩过于丰富的情况下解析有可能会阻塞线程，所以更倾向于使用异步的方式，当然你也可以自行构建异步逻辑。 参考内容 支持库软件包 | Android 开发者 | Android Developers androidx.palette.graphics | Android 开发者 | Android Developers ","link":"https://LiarrDev.github.io/post/Enjoy-Palette-in-One-Shot/"},{"title":"Scrcpy","content":"摸鱼是每个打工人的修养，我们在平时工作中一般都需要对着电脑屏幕，但是由于社交娱乐等需求的移动化，如果一直低着头玩手机，就会被老板认为需求不饱和，即使是像我一样的移动客户端开发者也不例外。 将摸鱼方式搬到电脑中刻不容缓。 模拟器是一个很好的替代品，但是许多应用都需要登录才能使用，这样我们就需要经常在手机和模拟器之间切换账号，很不方便。 如果能将手机投影到电脑中，并且能够通过键盘鼠标操作手机，岂不美哉。 『Scrcpy』是由法国专门研究企业版 Android 虚拟化工具的著名企业 Genymobile 开发的 Android 投屏工具，Genymobile 这个公司可能很多人没听说过，不夸张的说，它开发的名为『Genymotion』的 Android 模拟器做得甚至比 Google 官方都要受欢迎，有机会的话以后也可以唠一唠。 说回『Scrcpy』，它是一款通过 ADB 调试的方式来将手机屏幕投到电脑上，并可以通过电脑控制 Android 设备的投屏工具，支持 Windows、macOS 和 Linux 等桌面平台，可以通过 USB 或者 Wi-Fi 连接设备，不需要在手机上安装任何软件，也不需要 ROOT 权限，同时还拥有高性能低延迟等优点。 官方是这样总结的： It focuses on: lightness (native, displays only the device screen) performance (30~60fps) quality (1920×1080 or above) low latency (35~70ms) low startup time (~1 second to display the first image) non-intrusiveness (nothing is left installed on the device) 重要特性： 轻量（原生，仅显示设备屏幕） 性能（30 ~ 60 fps） 画质（1920×1080 或以上） 低延迟（35 ~ 70 毫秒） 启动快（约 1 秒内显示第一帧图） 非侵入（无需在设备安装任何软件） 下面介绍如何使用。 要连接的 Android 设备需要满足一定的环境，首先确保 Android 设备系统为 Android 5.0（Lollipop，API 21）以上版本，其次要在手机上启用「USB debugging」。 「USB debugging」在「Developer options」中启用，而关于「Developer options」的启用方式，你可以在网上轻易找到，这里不再介绍。 需要注意的是，在某些设备上你可能还需要启用附加选项以使用键盘和鼠标进行控制，比如上图右边的 MIUI 系统则需要启用「USB debugging（Security settings）」选项，否则仅能投屏不能用键鼠操控；而上图左侧的 EMUI 系统则无需相关选项。 接下来在桌面平台安装『Scrcpy』。 Windows 平台安装十分简单，只需前往项目主页下载并解压即可，『Scrcpy』还很贴心的帮你在压缩包内准备了 ADB 工具，你无需自己去下载。 我非常建议你将其配置到环境变量，因为这样可以在任何地方随时启用『Scrcpy』。 假如你已经安装了『Chocolatey』软件包管理器，你还可以用更加极客的方式安装『Scrcpy』： ➜ choco install scrcpy ➜ choco install adb # if you don't have it yet 『Scoop』也是可以的： ➜ scoop install scrcpy ➜ scoop install adb # if you don't have it yet macOS 平台的安装对于小白来说可能不太友好，因为它不提供 DMG 或 PKG 之类的安装文件，也没有像 Windows 一样提供 ZIP 压缩包，主要原因还是 macOS 设置环境变量要更加复杂，所以『Homebrew』是个很好的选择： ➜ brew install scrcpy ➜ brew install android-platform-tools # if you don't have adb yet Linux 平台同样是命令： ➜ apt install scrcpy 安装完成后，将 Android 设备通过数据线连接桌面平台，在使用『Scrcpy』之前，最好先用 ADB 监测一下 Android 设备是否连接成功： ➜ adb devices 如果设备列表为空，则应当确认一开始的前置条件是否满足。 设备连接成功后，就可以使用『Scrcpy』投屏了，也非常简单，只要在命令行中输入： ➜ scrcpy 『Scrcpy』便会启动，投屏窗口立即打开。 这丝滑顺畅的感觉，比模拟器要舒服的多。 Windows 还支持双击「scrcpy.exe」文件启用，你可以为其创建快捷方式，那就可以在桌面直接打开了。但是…命令行不香吗? 当然，如果你仅仅是用来投屏的话，的确感受不到区别，但命令行可以将『Scrcpy』的功能发挥到极致。 比如，我可以限制画面的分辨率： ➜ scrcpy --max-size 1024 ➜ scrcpy -m 1024 # short version 比如，我可以在启动『Scrcpy』的时候将 Android 设备的屏幕关闭： ➜ scrcpy --turn-screen-off ➜ scrcpy -S # short version 很多时候我们的手机都会设置一段时间不操作之后休眠，这样如果我们在休眠后想再次使用『Scrcpy』操作设备，只能重新点亮设备，再回到电脑操作，就会很麻烦；如果手动设置休眠间隔，在使用完了又要重新设置回来，也不方便，那可以使用命令： ➜ scrcpy --stay-awake ➜ scrcpy -w # short version 关闭屏幕以及防止休眠是可以组合使用的： ➜ scrcpy --turn-screen-off --stay-awake ➜ scrcpy -Sw # short version 当连接了多台 Android 设备时，我们可以通过 adb devices 查询到设备 ID，然后投屏指定的设备： ➜ scrcpy --serial $device_id ➜ scrcpy -s $device_id # short version 比如，在启动『Scrcpy』的时候将投屏窗口置顶： ➜ scrcpy ---always-on-top ➜ scrcpy -T # short version 比如，我想全屏显示投屏窗口： ➜ scrcpy --fullscreen ➜ scrcpy -f # short version 比如，我想投屏的时候，不允许使用键鼠操控： ➜ scrcpy --no-control ➜ scrcpy -n # short version 比如，投屏的时候我还想录个屏，但是手机录完屏还要将视频文件传输到电脑非常麻烦，那我可以直接使用『Scrcpy』的录屏命令，它会将视频保存到当前终端所在目录，支持 MP4 和 MKV 格式： ➜ scrcpy --record file.mp4 ➜ scrcpy -r file.mp4 # short version 假如我只是想录个屏，不需要用到投屏，那我还可以： ➜ scrcpy --no-display --record file.mkv ➜ scrcpy -Nr file.mkv # short version 我们知道，在电脑上我们是可以用鼠标点击的，很直观能够知道具体的点击位置，但是在设备上操作时，点击位置的感知往往需要靠应用的动画反馈，『Scrcpy』可以将你在设备本机上的物理触摸也显示出来： ➜ scrcpy --show-touches ➜ scrcpy -t # short version 假如我只想将设备屏幕的一部分投屏： ➜ scrcpy --crop 1224:1440:0:0 # 1224x1440 at offset (0,0) ➜ scrcpy -c 1224:1440:0:0 # short version 投屏窗口标题默认会显示设备型号，虽然不知道有啥用，不过如果你想修改，也是没问题的： ➜ scrcpy --window-title '$title' 不喜欢显示这个窗口外框，还可以去掉： ➜ scrcpy --window-borderless 你可以随意将文件拖到『Scrcpy』窗口以推送到 Android 设备中，在目前最新版本（V1.19）中，它会存放于 /sdcard/Download/ 目录，但在老版本（比如 V1.17）中则存放于 /sdcard/ 目录下，当然，你依然可以通过手动去设置这个存储路径： ➜ scrcpy --push-target=/sdcard/Movies/ 我常用的配置参数大概就这些，更加详细的配置可以使用命令查看帮助，也可以翻阅官方文档。 既然提到它可以通过拖动文件到『Scrcpy』窗口来推送到 Android 设备，那更要提一个跟模拟器很相似的操作了，当拖入的文件类型是 APK 时，『Scrcpy』会自动帮你在 Android 设备上安装，十分方便。 『Scrcpy』还支持键鼠的快捷键，我在这里列举一些常用的热键： Action Shortcut 切换全屏模式 MOD + f 调整窗口大小以移除黑色边框 MOD + w | 在黑色区域双击鼠标左键 设备 HOME 键 MOD + h | 鼠标中键（即单击滚轮） 设备 BACK 键 MOD + b | 鼠标右键 设备 APP_SWITCH MOD + s | 鼠标的第 4 个键（如果有的话） 设备 MENU MOD + m 设备 VOLUME_UP MOD + ↑ 设备 VOLUME_DOWN MOD + ↓ 设备 POWER 键 MOD + p 点亮屏幕 鼠标右键 展开通知面板 MOD + n | 鼠标的第 5 个键（如果有的话） 展开设置面板 MOD + n + n | 双击鼠标的第 5 个键（如果有的话） 折叠面板 MOD + Shift + n 复制到剪贴板（Android 7 以上设备支持） MOD + c 剪切到剪贴板（Android 7 以上设备支持） MOD + x 同步剪贴板并粘贴（Android 7 以上设备支持） MOD + v 以键盘事件序列注入电脑剪贴板文本 MOD + Shift + v 上表中的 MOD 一般指键盘的 Alt 或 Command 键，当然你也可以使用命令修改： ➜ scrcpy --shortcut-mod=rctrl # use RCtrl for shortcuts ➜ scrcpy --shortcut-mod=lctrl+lalt,lsuper # use either LCtrl+LAlt or LSuper for shortcuts 更加详细的热键表可以使用命令查看帮助，也可以翻阅官方文档。 最后再简单提一下无线网络连接『Scrcpy』，实际上这是关于 ADB 的知识，因为 ADB 本身是支持无线连接的，所以这里并不打算介绍如何操作，你可以在网上搜索相关教程。连接成功后，正常启用『Scrcpy』即可。 考虑到无线连接稳定性可能不如数据线，你可以手动调整码率： ➜ scrcpy --bit-rate 2M --max-size 800 ➜ scrcpy -b 2M -m 800 # short version ➜ scrcpy -b2M -m800 # short version 以上就是『Scrcpy』的常用功能介绍，而『Scrcpy』的实力远远不止这些，你可以前往其项目主页进行详细了解。 总的来说『Scrcpy』实现了在电脑前轻松处理手机端的事情的需求，开源免费，绝对是办公和摸鱼兼顾的利器。 ","link":"https://LiarrDev.github.io/post/Scrcpy/"},{"title":"Android R 不再支持 APK Signature Scheme v1","content":"最近刚对接了一个新游戏，处理完渠道广告后，市场和运营的同事反馈说在 ViVO 手机上无法安装，系统提示如下： 既然直接下载安装会失败，那可以借助 ADB 工具安装一下，收到如下报错： ➜ adb install game.apk Performing Streamed Install adb: failed to install game.apk: Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Scanning Failed.: No signature found in package of version 2 or newer for package &lt;package_name&gt;] 意思是说安装包没有 V2 或更高等级的签名。 因为在我的华为手机上是能安装成功的，所以首先可以考虑是 Android 版本问题或 ROM 的问题。 由于 ROM 的独有特征比较难去追踪，因此先看看是否为 Android 版本问题，反馈的两台 ViVO 手机皆为 Android R（API 30，Android 11），而我的华为手机是 Android Q（API 29，Android 10），去官网看看 Android 11 的版本新特性： Apps that target Android 11 (API level 30) that are currently only signed using APK Signature Scheme v1 must now also be signed using APK Signature Scheme v2 or higher. Users can't install or update apps that are only signed with APK Signature Scheme v1 on devices that run Android 11. 对于以 Android 11（API 30）为目标平台，且目前仅使用 APK 签名方案 v1 签名的应用，现在还必须使用 APK 签名方案 v2 或更高版本进行签名。用户无法在搭载 Android 11 的设备上安装或更新仅通过 APK 签名方案 v1 签名的应用。 简单来说就是，targetSdkVersion 为 30 且仅使用 V1 签名的应用无法在 Android 11 的手机上正常安装。 我遇到的这个问题恰好就是因为这个原因导致的，因为在对接某些渠道的时候，渠道方会要求使用 V1 签名于是我们目前全渠道都使用 V1 签名方案，而这次研发提供的游戏包又恰好 targetSdkVersion 是 30。 既然这个问题由两个条件产生的，那就有两个解决方法。 第一种解决方法是使用 V2 或更高版本的签名方案，即使用『ApkSigner』工具进行签名。 使用这个方法也有要注意的地方，官方文档中都有提到： Apps that target Android 11 (API level 30) or higher can't be installed if they contain a compressed resources.arsc file or if this file is not aligned on a 4-byte boundary. 如果以 Android 11（API 30）或更高版本为目标平台的应用包含压缩的 resources.arsc 文件或者如果此文件未按 4 字节边界对齐，应用将无法安装。 即 targetSdkVersion 为 30 的应用必须对 APK 文件作对齐优化，在此之前，Android 官方一直都只是建议对齐，并未强制要求。 具体的操作方法在之前的『Android 反编译入门指南』一文中有详细的介绍。 第二种解决方法是将 targetSdkVersion 降为 30 以下。 将 targetSdkVersion 降级最好由应用的开发者来处理，在游戏行业由于游戏包往往需要经过多个公司发行联运流转，这种情况就会比较麻烦，最好交给上游处理，除非上游不予处理，下游才自行处理。 因为上游可以在工程项目中做调整，有什么问题也能够及时发现，下游只能对现有 APK 文件做修改，很容易出问题。 上游的修改就不多说了，直接在『Android Studio』中处理即可，主要介绍一下下游的处理方案。 依然参考『Android 反编译入门指南』一文，首先对 APK 文件使用『Apktool』进行反编译，然后在 apktool.yml 中修改 targetSdkVersion： sdkInfo: minSdkVersion: '16' targetSdkVersion: '29' 修改完成后理论上就可以重新打包了，但是我重新打包后发现即使 targetSdkVersion 已经降为 29 了但依然有可能没有解决问题，还需要去 AndroidManifest.xml 中将相关版本信息删除掉，即将： &lt;manifest ... platformBuildVersionCode=&quot;1&quot; platformBuildVersionName=&quot;1.0&quot; android:compileSdkVersion=&quot;23&quot; android:compileSdkVersionCodename=&quot;6.0-2438415&quot; android:installLocation=&quot;auto&quot;&gt; ... &lt;/manifest&gt; 修改为： &lt;manifest ... platformBuildVersionCode=&quot;1&quot; platformBuildVersionName=&quot;1.0&quot; android:installLocation=&quot;auto&quot;&gt; ... &lt;/manifest&gt; 然后回编译，相关版本信息会自动补全，最后使用『JarSigner』或『ApkSigner』工具进行 V1 签名即可。 虽然两种方法都能解决问题，但依然建议使用第一种方案，即使用『ApkSigner』工具进行 V2 签名，毕竟降级只是一个缓兵之计，开倒车就跟不上技术发展的潮流了。 参考内容 行为变更：以 Android 11 为目标平台的应用 | Android 开发者 | Android Developers ","link":"https://LiarrDev.github.io/post/APK-Signature-Scheme-v1-is-No-Longer-Supported-on-Android-R/"},{"title":"Android 实现双击 Back 键退出应用","content":"现在很多应用都提供了双击 BACK 键退出的功能，用不算高的操作成本，来增加用户的留存时间，也降低了误触的风险。 今天介绍一下如何实现这个功能。 Android 中没有直接提供监听双击 BACK 键的方法，所以我们要自己实现。思路大概是监听 BACK 键是否有点击事件，有的话判断是第几次点击，并设置一个时间来对点击的状态进行重置，避免两次点击相差时间过长也可以响应的情况。 好的，接下来就是实现了： 利用线程延时 public class MainActivity extends Activity { ... private static boolean mBackKeyPressed = false; // 记录是否有首次按键 @Override public void onBackPressed() { if (!mBackKeyPressed) { Toast.makeText(this, &quot;Click again to exit&quot;, Toast.LENGTH_SHORT).show(); mBackKeyPressed = true; new Timer().schedule(new TimerTask() { @Override public void run() { mBackKeyPressed = false; } }, 2000); } else { super.onBackPressed(); } } } 这里定义了一个 boolean 类型的变量来记录是否已经点击过 BACK 键，如果没有，则给出提示，让用户再点一次退出，如果已经点击过一次，那么这次响应就直接退出应用。 监听 BACK 键的方法在『Android 为 WebView 重写 Back 键』一文有相关介绍，这里选取了 onBackPressed() 来进行监听，通过 Timer 来设置响应间隔，即 2 秒内如果不退出应用，则对第一次点击擦除。 通过计算时间差 public class MainActivity extends Activity { ... private long mPressedTime = 0; @Override public void onBackPressed() { long mNowTime = System.currentTimeMillis(); if ((mNowTime - mPressedTime) &gt; 2000) { Toast.makeText(this, &quot;Click again to exit&quot;, Toast.LENGTH_SHORT).show(); mPressedTime = mNowTime; } else { super.onBackPressed(); } } } 这里定义一个 long 类型的变量用来记录用户点击 BACK 键时的时间，默认为 0，表示没有点击，并在 onBackPressed() 内获取到点击 BACK 键时的时间，然后作判断，假如差大于 2 秒，则给出提示，让用户再点一次退出，如果小于 2 秒，则直接退出应用。 该方法不像上方线程延迟将状态重置为初始值，这里每次超时点击都会将 mPressedTime 置为当时点击的时间，也就是说该值会不断增长，直至退出应用。 实现效果如下 这里顺便再给个反例，是广发银行旗下的信用卡应用『发现精彩』的双击退出实现： 『发现精彩』使用的是弹窗而非 Toast，当用户连续双击 BACK 键后，才会给出弹窗，也就是说正常情况下用户需要点击三次才能成功退出，无形中就增加了用户的点击成本。 另外，当用户连续点击奇数次时，弹窗会消失，但应用不会退出，如此反复。用户平时如果进入多个页面后，点击 BACK 键会将多个页面出栈，直至最后一个页面才会退出，那么当用户所处的页面为非主页而用户此时想退出时，就会一直连续点击 BACK 键，由于点击过于迅速，用户也不会在意自己点了多少次，所以很大几率会导致弹窗消失，使用户的点击成本越来越高，这种交互一定是产品经理脑抽才会想出来的。 ","link":"https://LiarrDev.github.io/post/Double-Click-the-BACK-Key-to-Exit-on-Android /"},{"title":"绕过阿里云本机号码一键登录的包名检测机制","content":"现在越来越多的 App 开始支持本机号码一键登录的功能了，通过和运营商合作，获取到当前使用网络的手机卡号码，进行登录流程，能够减少用户的操作步骤，提高转化率。 众所周知，国内现在主流通讯运营商有三家，分别是中国移动、中国联通和中国电信。 这就意味着，对接三家运营商就有三套对接流程，要对接三次 SDK，但，正如所有的聚合服务所需，总会产生聚合这三家运营商一键登录服务的 SDK 供大家使用。 阿里云作为国内数字经济基础设施比较完善的代表，往往会作为许多企业的首选。我所在的企业，自然也是选择了它。 文前预警，本文需配合阿里云本机号码一键登录文档一同食用，建议先按照文档和官方提供的 Demo 先接一遍了解流程。 接入阿里云本机号码一键登录服务首先要到阿里云后台申请参数，申请参数需要提供应用的包名和签名，然后阿里云会为我们生成一个密钥。 之前的文章有提到过，我目前从事游戏行业，国内游戏行乱象大家都知道，马甲包遍地都是，拥有不同包名的马甲包如果想要都接入本机号码一键登录功能的话，就得申请多套不同的参数，这大大增加了对接成本。 那么，我们能不能绕过阿里云对包名的检测，让多个马甲包都共用同一套参数呢？ 来试试看。 我这里拿阿里云官方 Demo 提供的参数进行演示，实际项目按需修改。 public class AliParameter { // 阿里云官方 Demo 里的包名，替换为申请参数时填写的包名 public static String AUTH_PACKAGE_NAME = &quot;com.aliqin.mytel&quot;; // 阿里云官方 Demo 里的密钥，替换为申请的密钥，理论上密钥应当放在服务端 public static String AUTH_KEY = &quot;7KHffk2Cn1j17+QVA2zbJfdDteDSUDspB/s+FUoAhyXmQ/wueAQBcpMDOVLrp5lt5BDIGxDrCuTBZk7TcR4CxAQvHnJUPIaCI5dscbBFqHgHVI8Yoy0nYwsFo8Gyd2RZ6MbUAZr3lsnPQsA+UW1MZY9EP94x0TrXmwEJkU5xJgmOJfCSekYWHP5xNc0as/aWkTmNrjFyb5//93cAMwQllH0FFEFF+GEd7XMvm6ap/g4BD8676+z29MbePXPjoY6u3VrNTMkksQHW1EolxJkw+9Sa5pDsdOrQjXBz056J79PpNAFlTvPMZw==&quot;; // 三大运营商的协议地址 public static String PHONE_AUTH_YIDONG_CONTRACT = &quot;https://wap.cmpassport.com/resources/html/contract.html&quot;; public static String PHONE_AUTH_LIANTONG_CONTRACT = &quot;https://ms.zzx9.cn/html/oauth/protocol2.html&quot;; public static String PHONE_AUTH_DIANXIN_CONTRACT = &quot;https://e.189.cn/sdk/agreement/content.do?type=main&amp;appKey=&amp;hidetop=true&quot;; } 记得签名也要配置，参考之前『「Android Studio」用 Gradle 实现自动签名』一文： android { ... signingConfigs { // 阿里云官方 Demo 里的签名，应用中应替换为申请参数时填写的签名 config { keyAlias 'androiddebugkey' keyPassword 'android' storeFile file('sig-adaptation/debug/debug.keystore') storePassword 'android' v1SigningEnabled true v2SigningEnabled true } } buildTypes { release { signingConfig signingConfigs.config minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } debug { debuggable true signingConfig signingConfigs.config } } } 首先需要了解阿里云本机号码一键登录 SDK 是如何检测包名的，很简单，跟我们获取包名的操作类似，通过调用 Context 的 getPackageName() 来获取，再与服务端校验。 Context 如何获取，看初始化就可以，大多数 SDK 的初始化操作都是为了获取 Context 对象，而幸运的是，阿里云本机号码一键登录 SDK 并没有使用 App Startup 这些新技术，而是让对接方手动调用： /** * 获取号码认证服务实例，此实例为单例，获取多次为同⼀对象 * @param context Android上下⽂ * @param tokenListener 需要实现的获取token回调 * @return PhoneNumberAuthHelper */ public static PhoneNumberAuthHelper getInstance(Context context, TokenResultListener tokenListener) 这就简单许多了，假如我们能够自定义一个 Context 传给本机号码一键登录的 SDK，使得 SDK 在获取包名时，返回我们申请参数的包名而不是实际包名，就能够绕过它的检测机制了。 Context 是一个抽象类，而在 Android 中对 Context 的实现非常多，但往往继承越深，代码也就越复杂，根据开发经验，继承自 Context 的 Application 对于获取这种全局的东西往往会比其他组件要稍微方便一些，所以可以自定义一个 Application 来实现我们的需求。 public class AliApplication extends Application { public AliApplication(Context realContext) { try { Method method = Application.class.getDeclaredMethod(&quot;attach&quot;, Context.class); method.setAccessible(true); method.invoke(this, realContext); } catch (Exception e) { e.printStackTrace(); } } } 因为这个 Application 我们只用来欺骗阿里云本机号码一键登录 SDK，所以不会在 AndroidManifest 中注册它，那么这个 Application 的一些初始化方法就不能得到执行。 所以需要采用反射获取，并使用 invoke() 执行实例对应的方法。 当我们把这个 Application 对象传给 SDK 后，包名和签名都会由这个 Application 来提供。 先来看签名，因为我们的签名不需要改变，所以只需要将应用本身的签名回传即可。 写一个获取应用签名的方法： public static Signature[] getSignatures(PackageManager manager, String packageName) { try { PackageInfo packageInfo = manager.getPackageInfo(packageName, PackageManager.GET_SIGNATURES); return packageInfo.signatures; } catch (PackageManager.NameNotFoundException e) { e.printStackTrace(); } return null; } 这时候你应该发现，获取应用签名需要提供一个 PackageManager 对象，阿里云本机号码一键登录 SDK 也是如此，那就得再向它提供一个自定义的 PackageManager 了。 public class AliPackageManager extends PackageManager { private final PackageManager packageManager; private final String realPackageName; private Signature[] sSignature; public AliPackageManager(PackageManager packageManager, String realPackageName) { this.packageManager = packageManager; this.realPackageName = realPackageName; } @Override public PackageInfo getPackageInfo(@NonNull String packageName, int flags) throws NameNotFoundException { PackageInfo packageInfo = packageManager.getPackageInfo(realPackageName, flags); packageInfo.signatures = getSignature(); packageInfo.packageName = AliParameter.AUTH_PACKAGE_NAME; return packageInfo; } private Signature[] getSignature() { if (sSignature != null) { return sSignature; } sSignature = SignatureUtil.getSignatures(packageManager, realPackageName); return sSignature; } ... } PackageManager 也是一个抽象类，需要实现很多个方法，但这些方法大多数我们都用不上，所以可以忽略，只将 getPackageInfo() 方法实现即可，主要就是封装包名与签名。 接下来就要在 AliApplication 中调用： public class AliApplication extends Application { ... @Override public PackageManager getPackageManager() { return new AliPackageManager(super.getPackageManager(), super.getPackageName()); } } 这个时候调用： AliApplication application = new AliApplication(context); PhoneNumberAuthHelper mPhoneNumberAuthHelper = PhoneNumberAuthHelper.getInstance(application, tokenResultListener); mPhoneNumberAuthHelper.setAuthSDKInfo(AliParameter.AUTH_KEY); mPhoneNumberAuthHelper.getReporter().setLoggerEnable(true); mPhoneNumberAuthHelper.checkEnvAvailable(PhoneNumberAuthHelper.SERVICE_TYPE_AUTH); 你就发现，应用崩溃了… 实际上还漏了一个方法： public class AliApplication extends Application { ... @Override public Context getApplicationContext() { return this; } } 你可能会有疑惑，为什么不需要重写 Application 的 getPackageName()。只不过 SDK 似乎都是通过 PackageManager 来获取的，实际上你重写也没有问题。 再运行，你会发现，应用没有崩溃，但是却没有拉起授权页，SDK 回调了以下错误： { &quot;code&quot;:&quot;600002&quot;, &quot;msg&quot;:&quot;唤起授权页失败&quot;, ... } 这个错误信息你查文档的话并没有什么作用，但是它能够告诉我们签名和包名都已获取正确了，也就是上面的步骤操作正确。 接下来就要开始对 SDK 进行魔改了。 在进行这一步之前，我必须要提个醒，阿里云提供的接入文档中有相关服务声明： 注意： 一键登录或注册需用户确认授权方可使用，开发者不得通过任何技术手段跳过或模拟此步骤，否则我方有权停止服务并追究相关法律责任。 登录按钮文字描述必须包含“登录”或“注册”等文字，不得诱导用户授权。 对于接入移动认证SDK并上线的应用，我方会对上线的应用授权页面做审查，如果有出现未按要求弹出或设计授权页面的，将关闭应用的一键登录或注册服务。 以下内容仅作学习交流，如产生任何责任由应用的开发者承担。 回到正题，魔改的话要从哪里入手？ 不难注意到接入流程要我们手动注册三个 Activity，很明显，LoginAuthActivity 就是我们的目标，而且你也发现有两个 LoginAuthActivity。 另一方面，我们无法正常唤起授权页，证明唤起的流程也需要修改。 这两个问题合在一起思考，我们能不能在修改唤起流程的时候，将两个 LoginAuthActivity 合并，即无论是移动、联通还是电信，都只唤起同一个 LoginAuthActivity，因为同样的功能分两个页面我实在想不到原因。 想要篡改，首先就得弄清楚流程，先反编译看看代码。 根据包名可以定位到是「phoneNumber-L-AuthSDK.arr」这个库里面的，解压拿到 Jar 包丢进之前在『Android 反编译入门指南』一文中提到的工具『JADX』里面就可以了，但反编译后我瞬间就懵了，阿里云对这个 SDK 做了混淆，并且还有一些方法写在了 SO 库中，大大增加了我们修改的难度。 通过代码搜索，最终定位到唤起流程在一个混淆名为 d 的类中： public class d { ... public void a(long j2, String str, String str2, ResultCodeProcessor resultCodeProcessor, e eVar) { ... try { ... Intent intent = new Intent(this.c, LoginAuthActivity.class); intent.putExtra(Constant.LOGIN_ACTIVITY_NUMBER, str); intent.putExtra(Constant.LOGIN_ACTIVITY_VENDOR_KEY, str2); intent.putExtra(Constant.LOGIN_ACTIVITY_UI_MANAGER_ID, this.j); intent.putExtra(Constant.START_TIME, System.currentTimeMillis()); ... if (f().getAuthPageActIn() == null || f().getActivityOut() == null) { if (activity != null) { activity.startActivityForResult(intent, 1); } else { intent.addFlags(268435456); this.c.startActivity(intent); } } else if (activity != null) { ... if (TextUtils.isEmpty(authPageActIn) || TextUtils.isEmpty(activityOut)) { SupportJarUtils.startActivityForResult(activity, intent, 1, (String) null, (String) null); } else { SupportJarUtils.startActivityForResult(activity, intent, 1, authPageActIn, activityOut); } } else { intent.addFlags(268435456); this.c.startActivity(intent); } ... } catch (Exception e2) { ... } catch (Throwable th) { ... } } } 中间那一堆判断我也不知道它有啥用，干脆直接去掉： public class d { ... public void a(long l, String number, String vendor, ResultCodeProcessor resultCodeProcessor, com.mobile.auth.gatewayauth.e eVar) { try { this.t = l; Application application = ReflectionUtils.getApplication(); if (application != null) { application.registerActivityLifecycleCallbacks(this.v); } Activity activity = ReflectionUtils.getActivity(); Intent intent = new Intent(activity, LoginAuthActivity.class); intent.putExtra(&quot;isAli&quot;, true); intent.putExtra(&quot;number&quot;, number); intent.putExtra(&quot;vendor&quot;, vendor); intent.putExtra(&quot;ui_manager_id&quot;, this.j); intent.putExtra(&quot;startTime&quot;, System.currentTimeMillis()); this.a(resultCodeProcessor); b.put(this.j, this); activity.startActivityForResult(intent, AliParameter.ACTIVITY_REQUEST_CODE); if (eVar != null) { eVar.a(vendor, number); } } catch (Throwable throwable) { com.mobile.auth.gatewayauth.a.a(throwable); } } } 不管三七二十一，反正 Intent 封装好了，那就直接拉起 LoginAuthActivity 吧，为了更好的处理回调，这里通过 startActivityForResult() 拉起。 然后处理 LoginAuthActivity，对于 Activity 一般先看 onCreate() 方法： @AuthNumber public class LoginAuthActivity extends Activity { ... public native void onCreate(Bundle bundle); } 可惜的是，LoginAuthActivity 直接把 onCreate() 写在了 SO 库中，所以我们不能直接修改，不要紧，幸好还有别的生命周期： @AuthNumber public class LoginAuthActivity extends Activity { ... public void onResume() { try { super.onResume(); } catch (Throwable th) { a.a(th); } } } 可以看到 SDK 里的 onResume() 并没有做什么操作。 首先我们需要写一个自己的界面来处理登录回调，我这里就用一个 TextView 来显示手机号码，一个 Button 来点击登录，还有一个 TextView 用来显示运营商协议，太简单我就不写了。 因为 SDK 本来就有授权页，所以我们要覆盖它，可以通过 LayoutInflater 来操作： @AuthNumber public class LoginAuthActivity extends Activity { ... public void onResume() { super.onResume(); ViewGroup viewGroup = (ViewGroup) findViewById(android.R.id.content); View view = LayoutInflater.from(this).inflate(R.layout.activity_login_auth, null); viewGroup.addView(view); TextView tvPhone = (TextView) view.findViewById(R.id.tv_phone); tvPhone.setText(mNumberPhone); view.findViewById(R.id.btn_auth).setOnClickListener(v -&gt; { onLogin(); }); TextView tvContract = (TextView) view.findViewById(R.id.tv_contract); String url = &quot;&quot;; if (mSlogan.contains(&quot;移动&quot;)) { tvContract.setText(&quot;中国移动认证服务条款&quot;); url = AliParameter.PHONE_AUTH_YIDONG_CONTRACT; } else if (mSlogan.contains(&quot;联通&quot;)) { tvContract.setText(&quot;中国联通认证服务条款&quot;); url = AliParameter.PHONE_AUTH_LIANTONG_CONTRACT; } else if (mSlogan.contains(&quot;电信&quot;)) { tvContract.setText(&quot;天翼账号服务与隐私协议&quot;); url = AliParameter.PHONE_AUTH_DIANXIN_CONTRACT; } else { tvContract.setVisibility(View.GONE); } Uri uri = Uri.parse(url); Intent intent = new Intent(Intent.ACTION_VIEW, uri); tvContract.setOnClickListener(v -&gt; startActivity(intent)); } public void onLogin() { boolean access$400 = LoginAuthActivity.access$400(this); LoginAuthActivity.access$200(this).a(LoginAuthActivity.access$100(this), true, access$400); showLoadingDialog(); LoginAuthActivity.access$700(this).a(&quot;LoginAuthActivity&quot;, &quot;; PhoneNumberAuthHelper2 = &quot;, String.valueOf(LoginAuthActivity.access$200(this))); LoginAuthActivity.access$200(this).b(LoginAuthActivity.access$200(this).a()); } public void showLoadingDialog() { LoginAuthActivity.access$000(LoginAuthActivity.this).setClickable(true); access$200(this).a((TokenResultListener) new MyTokenResultListener(this)); } } 手机号码实际上展示的是掩码，和文章开头的各家应用截图一致。运营商协议则根据 mSlogan 这个字段处理一下，三大运营商的协议我已经把链接抓下来了，跳转到浏览器打开就可以。 按钮点击响应执行登录事件，并回调给 TokenResultListener。 可以发现，这里的 TokenResultListener 和前面初始化的 TokenResultListener 并不是同一个，因为初始化的那个 TokenResultListener 我没有想到优雅的办法传递过来。 看看授权完成的 TokenResultListener 回调处理： public class MyTokenResultListener implements TokenResultListener { private final LoginAuthActivity mLoginAuthActivity; public MyTokenResultListener(LoginAuthActivity activity) { this.mLoginAuthActivity = activity; } @Override public void onTokenSuccess(String value) { TokenRet tokenRet = TokenRet.fromJson(value); if (tokenRet.getCode().equals(ResultCode.CODE_SUCCESS)) { doLogin(tokenRet.getToken()); } } @Override public void onTokenFailed(String value) { TokenRet tokenRet = TokenRet.fromJson(value); LogUtil.e(&quot;onTokenFailed TokenRet Msg: &quot; + tokenRet.getMsg()); } private void doLogin(String authToken) { // 请求服务端完成登录操作 ... mLoginAuthActivity.setResult(Activity.RESULT_OK); mLoginAuthActivity.finish(); } } 这个 onTokenSuccess() 只需处理获取 Token 的 Code 即可，解析对应的 Token，并回传给服务端，完成登录流程，可以参考文档提供的流程图。 己方服务端登录成功后，再销毁 LoginAuthActivity，不要忘了将结果告知拉起授权页的 Activity，也不要忘了在拉起授权页的 Activity 处理结果： @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == AliParameter.ACTIVITY_REQUEST_CODE &amp;&amp; resultCode == RESULT_OK) { // 登录完成 } } 最后再看看一开始初始化时的 TokenResultListener： TokenResultListener tokenResultListener = new TokenResultListener() { @Override public void onTokenSuccess(String s) { TokenRet tokenRet = TokenRet.fromJson(s); switch (tokenRet.getCode()) { case ResultCode.CODE_ERROR_ENV_CHECK_SUCCESS: // 支持使用本机号码一键登录 mPhoneNumberAuthHelper.getLoginToken(application, 5000); break; case ResultCode.CODE_START_AUTHPAGE_SUCCESS: // 唤起授权页成功 break; case ResultCode.CODE_SUCCESS: // 实际上并不会走这里回调 break; } } @Override public void onTokenFailed(String s) { TokenRet tokenRet = TokenRet.fromJson(s); if (ResultCode.CODE_ERROR_USER_CANCEL.equals(tokenRet.getCode())) { // 用户手动取消登录 } } }; 修改完之后，我们要将原来「phoneNumber-L-AuthSDK.arr」这个库文件重新导入，因为重写了 LoginAuthActivity 和 d 两个类，所以需要把库文件中对应的 CLASS 文件删除掉。 之前『「Android Studio」如何导入 AAR 包』一文提到，AAR 是以 Zip 格式构建的，所以可以直接通过压缩工具打开将其删除，也可以改用文章中提到的 JAR 的方式接入，解压后将资源放到对应的目录即可，由『「Android Studio」如何导入 JAR 包』一文可知，JAR 也是以 Zip 格式构建的，所以同样也可以用压缩软件打开并删除掉对应的 CLASS 文件。 而我们所修改的 LoginAuthActivity 和 d，则根据原来 SDK 内的包名，放到项目中对应的包目录下即可。 最终运行效果如下： 关于后面魔改 SDK 的相关代码，文章讲的比较简单，所以我写了个 Demo 放在 Github，需要的话可以参考我的 Demo 进行修改。 参考内容 接入概述 - 号码认证服务 - 阿里云 Android客户端接入 - 号码认证服务 - 阿里云 ","link":"https://LiarrDev.github.io/post/Bypassing-the-Package-Name-Detection-of-Phone-Number-Verification-Service-Provided-by-Alibaba-Cloud/"},{"title":"Android 反编译入门指南","content":"之前的文章已经多次提到我现在在游戏发行公司工作，当前由于国内游戏和广告环境，反编译是作为游戏 Android SDK 工程师必备的技能，经常需要将上游 CP 提供的游戏母包反编译，然后接入一些我们自己的或者是第三方的 SDK 再重新编译打包并转成多个子包再上线。 在我接触这个行业之前，我以为反编译更多的是用在破解软件或者是某些公司对其他公司的技术窃取途径，没想到游戏发行居然能这么玩。 今天就来带大家入门 Android 反编译。 我们都知道，Android 应用程序打包之后得到的是一个 APK 文件，这个文件是可以直接安装到任何 Android 手机上的，所以我们反编译其实也就是对这个 APK 文件进行反编译。 Android 的反编译主要又分为两个部分，一是对代码的反编译，二是对资源的反编译。 准备 既然是对 APK 文件进行反编译，那么理应有个前提 —— 有一个 APK 文件。 为了能够更加简单的演示，以及对其他开发者的尊重，就不使用任何一款已上线的应用了，简单写个 Demo 就行，而且是越简单越好。 另一方面，现在上架应用市场的大多数应用都经过了加固处理，如果对其进行反编译还需要脱壳，相对来说会更加麻烦。 话不多说，新建一个项目，布局就一个 Button，没有其他东西： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;androidx.appcompat.widget.AppCompatButton android:id=&quot;@+id/button&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Button&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 逻辑就是点击这个 Button 后弹出一个 Toast： public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); findViewById(R.id.button).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Toast.makeText(MainActivity.this, &quot;Hello World&quot;, Toast.LENGTH_SHORT).show(); } }); } } 编译打包成一个 APK 文件，并安装到手机上，效果如下： 至此，准备工作完成。 反编译代码 要对应用的代码进行反编译，我们首先得大概了解 Dex 文件。 而在明白什么是 Dex 文件之前，要先了解一下 JVM、Dalvik 和 ART。 JVM 是 Java 虚拟机，用来运行 Java 字节码程序。Dalvik 是 Google 设计的用于 Android 平台的运行时环境，适合移动环境下内存和处理器速度有限的系统。ART 即 Android Runtime，是 Google 为了替换 Dalvik 设计的新 Android 运行时环境，在 Android 4.4 推出，比 Dalvik 的性能更好。 Android 程序一般使用 Java 语言开发，但是 Dalvik 虚拟机并不支持直接执行 Java 字节码，所以会对编译生成的 CLASS 文件（即以 .class 结尾的文件）进行翻译、重构、解释、压缩等处理，这个处理过程是由『DX』或『D8』进行处理，处理完成后生成的产物会以 .dex 结尾，称为 Dex 文件。Dex 文件格式是专为 Dalvik 设计的一种压缩格式。所以可以简单的理解为：Dex 文件是很多 CLASS 文件处理后的产物（类似 Jar 包），最终可以在 Android 运行时环境执行。 上面这张图简化形象地描述了 Java 文件转化为 Dex 文件的过程，当然真的处理流程不会这么简单。 而我们反编译代码就是将这个操作反过来，通过将可以在 Android 运行时环境执行的 Dex 文件转化为可供我们阅读的代码。 这时候你可能就疑惑了，我们只有 APK 文件，去哪里找这个应用的 Dex 文件呢？ 之前也说过，软件安装包 APK 文件实质上也是一个压缩包，所以只需解压 APK 文件即可，相同的操作在之前『获取手机应用 ICON 的方法』一文中也提到过。 解压之后，可以看到一个名为 classes.dex 的文件，这就是我们所需要的 Dex 文件，即存放所有 Java 代码的地方。 Dex2Jar 首先我们需要一个叫『Dex2Jar』的小工具，看名字就知道，它可以帮助我们把 Dex 文件转换成一个 Jar 文件。 下载解压后可以得到一大堆文件，我们暂时只需要用到一个文件，Windows 平台下用到的是 d2j-dex2jar.bat，Linux 或 macOS 平台用到的则是 d2j-dex2jar.sh。 为了方便，我们把 classes.dex 文件复制到『Dex2Jar』解压后所在的目录，并打开命令行终端进入到该目录，执行以下命令： ➜ d2j-dex2jar classes.dex 一般执行结果如下所示： 但也时常有报错： 网上的文章说产生该报错可能是因为安装的『Dex2Jar』不是最新版，而实际上我安装了最新版也出现该情况。 尽管有报错，但『Dex2Jar』依然帮我把 Dex 文件转成了 Jar 文件，只不过多了一个错误日志的压缩包罢了。 而 classes-dex2jar.jar 这个文件，才是真正有用的文件。 JD-GUI 可是对于我们而言，Jar 文件也不是可读的，因此这里还需要再借助一下『JD-GUI』这个工具来将 Jar 文件转换成 Java 代码。 『JD-GUI』安装完后，坑还没完，你得确定你安装了 JRE，否则是无法运行的。 这时候你可能就会想，做 Android 开发的，怎么可能没有 JRE 呢，Android SDK 里都自带了呢。 Too young too simple. 按照之前在『Windows 平台 React Native 开发环境搭建笔记』提到的方法把 JRE 配置到环境变量后，打开『JD-GUI』，依然可能会报出需要 JRE 的提示： 使用命令的方式来打开： ➜ java -jar jd-gui.exe 相信有部分用户能正常打开了，而没有正常打开的用户会发现，在『JD-GUI』的 Logo 一闪而过后，报了错： 应该可以猜到原因，上面报需要 JRE 的提示框中，点击确定后会打开一个网页： 熟悉吗？我们刚开始学 Java 的时候就是来这个网站下载 JDK 的。 至于原因，你要清楚这两者的区别，Android SDK 中使用的是 OpenJDK，而我们安装 Java 开发环境的时候使用的是 Oracle JDK。 OpenJDK 是 Sun 在 2006 年末把 Java 开源而形成的项目，如 IcedTea、UltraViolet 等都是从 OpenJDK 源码衍生出的发行版，包括国内的大厂也有单独维护的基于 OpenJDK 的发行版，比如华为的毕昇JDK、阿里巴巴的 Dragonwell、腾讯的 Kona 等。 Oracle JDK 采用了商业实现，而 OpenJDK 使用的是开源的 FreeType。当然，相同是建立在两者共有的组件基础上的，Oracle JDK 中还会存在一些 OpenJDK 没有的、商用闭源的功能。 尽管我们编译的 OpenJDK 基本上可以认为性能、功能和执行逻辑上都和 Oracle JDK 是一致的，但这么一小点的差别就在『JD-GUI』中被体现出来了。 所以我也顺手在『JD-GUI』的 Github 开源项目上提了 Issue，发现包括微软工程师在内的不少用户都遇到这个问题，实际上这是 OpenJDK 的 Bug，『Android Studio』内置的 OpenJDK 1.8 版本恰好就包含了这个 Bug，而在『Android Studio』更新到 4.2 版本之后内置的 OpenJDK 也提升至 11.0.8，这个问题也就不再出现了，假如你用的是『Android Studio』内置的 OpenJDK 且不想升级『Android Studio』，另外再下载一套新的 JDK 即可。 更换 JDK 后应该就能正常启动『JD-GUI』了，然后把上面得到的 Jar 文件拉进来即可。 可以发现，代码反编译操作十分成功，MainActivity 中的内容基本全部还原，但你会发现 setContentView() 和 findViewById() 之类的方法传参并不是之前 Demo 中写的，因为这个参数实际上只是资源的 ID 值，那么这里反编译也就只能将相应的 ID 值进行还原，而无法变成像 R.layout.activity_main 和 R.id.button 这样直观的代码展示。 除了 MainActivity 之外，还有很多其它的代码也被反编译出来了，比如当前项目中引用的 AndroidX 的包，这些引用的 Library 也会作为代码的一部分被打包到「classes.dex」文件当中，因此反编译的时候这些代码也会一起被还原。 JADX 『JD-GUI』算是我刚接触反编译时使用的工具，从上面的流程可以看到，反编译的操作其实是比较繁琐的，为了提高工作效率当然要寻找更优秀的工具，后来我便发现了『JADX』。 『JADX』能够直接将 APK、Dex、AAR、AAB 等 Dalvik 字节码格式文件反编译，只需将文件拖进『JADX』即可。 将上面生成的 APK 文件用『JADX』打开： 可以看到几乎与『JD-GUI』无异，但是一步到位真的太省事了。 反编译资源 你可能会有些奇怪，刚才解压 APK 文件后不是已经可以看到资源文件的目录了吗，之前『获取手机应用 ICON 的方法』一文也通过这种方法获取到了安装包里面的许多图片资源，那怎么还需要反编译资源呢？ 这里说的当然不是图片资源，有时候会需要查看或者修改布局文件甚至是 AndroidManifest.xml 中的内容，而你如果直接打开上面解压后的文件，可能会是一脸懵逼的： 或者是这样的： 在 Android 打包的时候，资源文件会被编译，所以直接打开是无法看到明文的，因此我们还需要对资源进行反编译。 Apktool 于是，又需要另外一个工具 ——『Apktool』。 『Apktool』可以用于最大幅度地还原 APK 文件中的 9-patch 图片、布局、字符串等等一系列的资源。 下载下来后同样是得到一个 Jar 包，所以我们还是会通过命令来进行反编译操作。 把需要反编译的 APK 文件复制到和『Apktool』相同的目录，在命令行终端进到该文件夹中，执行以下命令： ➜ java -jar apktool.jar d Demo.apk 其中 d 是指 Decode 的意思，表示对后面的 Demo.apk 文件进行解码。还可以加上一些附加参数来控制 Decode 行为： -f：如果目标文件夹已存在，则强制删除现有文件夹（默认如果目标文件夹已存在，则解码失败）。 -o：指定解码目标文件夹的名称（默认在当前命令行所在目录使用 APK 文件的名字来命名目标文件夹）。 -s：不反编译 Dex 文件，也就是说 classes.dex 文件会被保留（默认会将 Dex 文件解码成 Smali 文件）。 -r：不反编译资源文件，也就是说 resources.arsc 文件会被保留（默认会将 resources.arsc 解码成具体的资源文件）。 有时候 APK 包体太大，为了避免文件的复制或移动耗时太长，我会使用以下的命令： ➜ java -jar apktool.jar d -f {需要解码的Apk文件} -o {解码后项目存储目录} 不过使用该命令需要注意的是，需要解码的 APK 文件路径和解码后项目所在路径不能为同一目录，因为有 -f 参数，解码后指定的项目目录会执行一次清空操作，即假如被反编译的 APK 在这一目录，则会被删除，而此时反编译操作仍未结束，就会导致报错。 当然你按照上面的操作也有可能会反编译失败，比如报以下错误： 这是因为 APK 里有加密过的 Dex 文件，比如有些 APK 会在 /assets 目录下存放加密的 Dex 文件，就会报这个错。要解决这个错误需要将『Apktool』升级至 2.4.1 或以上版本，然后增加如下参数： ➜ java -jar apktool.jar d -f {需要解码的Apk文件} -o {解码后项目存储目录} --only-main-classes 这个参数是在 2.4.1 版本上新增的，源码判断如下： case DECODE_SOURCES_SMALI_ONLY_MAIN_CLASSES: if (file.startsWith(&quot;classes&quot;) &amp;&amp; file.endsWith(&quot;.dex&quot;)) { mAndrolib.decodeSourcesSmali(mApkFile, outDir, file, mBakDeb, mApiLevel); } else { mAndrolib.decodeSourcesRaw(mApkFile, outDir, file); } break; 即反编译根目录下的以 classes 开头，并以 .dex 结尾的 Dex 文件。 除此之外，你还可能遇到一些奇奇怪怪的错误，比如： 出现这个错误的原因很有可能是你之前使用过老版本的『Apktool』进行反编译操作，然后『Apktool』就会在你系统的 C:\\Users\\Administrator\\apktool\\framework 这个目录下生成一个名字为 1.apk 的缓存文件，将这个缓存文件删除掉，然后再重新执行反编译命令应该就可以成功了。 反编译成功后，就可以在默认目录或者指定目录中得到反编译的项目，项目结构跟我们平时开发的目录结构也是非常相似的。 现在打开 AndroidManifest.xml 瞧一瞧： 这样就完全看得懂了吧，除了格式相比在『Android Studio』里面要压缩了许多之外，其他基本无异，完全可以通过文本编辑器的格式化插件或者是直接放进『Android Studio』里面格式化解决。 入侵 反编译后我们就可以对 App 进行修改，或者说，入侵。 在游戏发行领域，我们常用于为游戏母包注入自己或第三方的 SDK，如统计数据等，在这种情况下，反编译是允许的，因为我们获得了游戏研发商的授权，且对游戏本体功能没有造成任何损害。 在其他领域可就不一定了，比如市面上流行的很多破解版软件，实际上就是通过反编译技术对原作者的一种侵权行为。 当然，还有一些或许还在灰色地带的用法，比如说汉化，它并没有向破解软件一样入侵软件的原有逻辑，只是翻译其中的资源进行打包，但不管怎么说依然是对他人开发的程序进行了修改，虽然造福了用户，却依然不是一件值得吹捧的事。 这次就不去讨论本身这件事情的对或错，只是站在技术的角度来了解相关知识。 我们游戏发行常常需要修改的是 App 的资源文件，比如说包名，比如说应用图标，比如说应用名称等，跟我们平时开发中的差别不大，只需要把资源复制到相应的文件夹，修改资源文件内对应的部分即可，一般遵循有则覆盖无则追加的原则。 解释一下另外两个目录，/original 目录下存放的是未经反编译过、原始的 AndroidManifest.xml 文件，/smali 目录下存放的是反编译出来的所有代码。 进入 /smali 目录后你可以发现它的目录结构和我们平时开发时的 /app/src 目录结构十分相似，主要区别就是 Java 文件全都变成了 Smali 文件，因此这些 Smali 文件实际上也就是真正的源代码，只不过它的语法和 Java 完全不同，有点类似于汇编的语法，是 Android 虚拟机所使用的寄存器语言。 看不懂也是十分正常的，但是一旦能够看得懂 Smali 文件，你就可以做很恐怖的事情了 —— 随意修改应用程序内的逻辑，将其破解。 说实话我并没有学习过 Smali 的语法，但即使这样我也可以对这个 Demo 做一定程度的修改了，因为这个 Demo 实在写得太简单了，打开反编译后的 MainActivity，它处在对应的包目录下。 打开后会发现有两个与 MainActivity 相关的文件，一个是 MainActivity.smali，还有一个是 MainActivity$1.smali，一般情况下，当类内包含内部类或匿名类时，就会产生多个同名的以 $ 及后面数字或类名区分的 Smali 文件。 先来看「MainActivity.smali」： .class public Lcom/example/reverse/MainActivity; .super Landroidx/appcompat/app/AppCompatActivity; .source &quot;MainActivity.java&quot; # direct methods .method public constructor &lt;init&gt;()V .locals 0 .line 9 invoke-direct {p0}, Landroidx/appcompat/app/AppCompatActivity;-&gt;&lt;init&gt;()V return-void .end method # virtual methods .method protected onCreate(Landroid/os/Bundle;)V .locals 1 .line 13 invoke-super {p0, p1}, Landroidx/appcompat/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V const p1, 0x7f0a001c .line 14 invoke-virtual {p0, p1}, Lcom/example/reverse/MainActivity;-&gt;setContentView(I)V const p1, 0x7f070042 .line 15 invoke-virtual {p0, p1}, Lcom/example/reverse/MainActivity;-&gt;findViewById(I)Landroid/view/View; move-result-object p1 new-instance v0, Lcom/example/reverse/MainActivity$1; invoke-direct {v0, p0}, Lcom/example/reverse/MainActivity$1;-&gt;&lt;init&gt;(Lcom/example/reverse/MainActivity;)V invoke-virtual {p1, v0}, Landroid/view/View;-&gt;setOnClickListener(Landroid/view/View$OnClickListener;)V return-void .end method 反编译后的代码虽然咋一看与我们平时写的代码大相径庭，但仔细一行行读过去，其实也不是读不通。即使我对 Smali 的语法依然不熟悉，这里也不打算介绍，我们逐行阅读，依然能够读懂。 第一部分： .class public Lcom/example/reverse/MainActivity; .super Landroidx/appcompat/app/AppCompatActivity; .source &quot;MainActivity.java&quot; 与 Java 中的 class 关键字相似，Smali 用 .class 来指定当前的类名，同时还包含了完整的包名。 .super 我们也很熟悉，在 Java 中可以理解为是指向父类的指针，在这里的作用应该和 extends 相似，即继承自 AppCompatActivity。 .source 不难看出，描述的是源 Java 文件。 第二部分： # direct methods .method public constructor &lt;init&gt;()V .locals 0 .line 9 invoke-direct {p0}, Landroidx/appcompat/app/AppCompatActivity;-&gt;&lt;init&gt;()V return-void .end method .method 指代方法，constructor 顾名思义就是构造方法了，因为我们没有写 MainActivity 的构造方法，所以它会使用父类 AppCompatActivity 的构造方法。 第三部分： # virtual methods .method protected onCreate(Landroid/os/Bundle;)V .locals 1 .line 13 invoke-super {p0, p1}, Landroidx/appcompat/app/AppCompatActivity;-&gt;onCreate(Landroid/os/Bundle;)V const p1, 0x7f0a001c .line 14 invoke-virtual {p0, p1}, Lcom/example/reverse/MainActivity;-&gt;setContentView(I)V const p1, 0x7f070042 .line 15 invoke-virtual {p0, p1}, Lcom/example/reverse/MainActivity;-&gt;findViewById(I)Landroid/view/View; move-result-object p1 new-instance v0, Lcom/example/reverse/MainActivity$1; invoke-direct {v0, p0}, Lcom/example/reverse/MainActivity$1;-&gt;&lt;init&gt;(Lcom/example/reverse/MainActivity;)V invoke-virtual {p1, v0}, Landroid/view/View;-&gt;setOnClickListener(Landroid/view/View$OnClickListener;)V return-void .end method 同样是方法，这里描述的是 onCreate() 方法，参数为 Bundle 对象，然后执行 super 也就是 AppCompatActivity 中的 onCreate() 方法，接着便看到了 setContentView() 方法被调用，参数 I 表示 int 类型。至此为项目默认生成的代码。 接下来是我们的逻辑，通过 findViewById() 找到我们的 View 控件，也就是我们在布局文件中的 Button，最后再调用 setOnClickListener() 传入我们的点击事件 View.OnClickListener。 那我们点击事件的逻辑呢？ 上文提到，当类内包含内部类或匿名类时，就会产生多个同名的以 $ 及后面数字或类名区分的 Smali 文件，所以接下来看 MainActivity$1.smali 文件： .class Lcom/example/reverse/MainActivity$1; .super Ljava/lang/Object; .source &quot;MainActivity.java&quot; # interfaces .implements Landroid/view/View$OnClickListener; # annotations .annotation system Ldalvik/annotation/EnclosingMethod; value = Lcom/example/reverse/MainActivity;-&gt;onCreate(Landroid/os/Bundle;)V .end annotation .annotation system Ldalvik/annotation/InnerClass; accessFlags = 0x0 name = null .end annotation # instance fields .field final synthetic this$0:Lcom/example/reverse/MainActivity; # direct methods .method constructor &lt;init&gt;(Lcom/example/reverse/MainActivity;)V .locals 0 .line 15 iput-object p1, p0, Lcom/example/reverse/MainActivity$1;-&gt;this$0:Lcom/example/reverse/MainActivity; invoke-direct {p0}, Ljava/lang/Object;-&gt;&lt;init&gt;()V return-void .end method # virtual methods .method public onClick(Landroid/view/View;)V .locals 2 .line 18 iget-object p1, p0, Lcom/example/reverse/MainActivity$1;-&gt;this$0:Lcom/example/reverse/MainActivity; const-string v0, &quot;Hello World&quot; const/4 v1, 0x0 invoke-static {p1, v0, v1}, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast; move-result-object p1 invoke-virtual {p1}, Landroid/widget/Toast;-&gt;show()V return-void .end method 重复的内容就不过多解释了，来看刚刚没有提到的。 接口： # interfaces .implements Landroid/view/View$OnClickListener; .implements 依然是老朋友，指实现了哪些接口，回到一开始我们写的代码，里面按钮中实现了一个点击事件，就是用的 View.OnClickListener。 注解： # annotations .annotation system Ldalvik/annotation/EnclosingMethod; value = Lcom/example/reverse/MainActivity;-&gt;onCreate(Landroid/os/Bundle;)V .end annotation .annotation system Ldalvik/annotation/InnerClass; accessFlags = 0x0 name = null .end annotation .annotation 就是注解，很容易联想到我们代码中常用的注解 @Override，这里指向了 onCreate() 方法，参数为 Bundle。 实例域： # instance fields .field final synthetic this$0:Lcom/example/reverse/MainActivity; 到最重要的点击事件： # virtual methods .method public onClick(Landroid/view/View;)V .locals 2 .line 18 iget-object p1, p0, Lcom/example/reverse/MainActivity$1;-&gt;this$0:Lcom/example/reverse/MainActivity; const-string v0, &quot;Hello World&quot; const/4 v1, 0x0 invoke-static {p1, v0, v1}, Landroid/widget/Toast;-&gt;makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast; move-result-object p1 invoke-virtual {p1}, Landroid/widget/Toast;-&gt;show()V return-void .end method 这里就是点击事件 onClick() 的实现，我们看到了定义的要显示的字符串，Toast 的 makeText() 方法以及 show() 方法。 至此，整个 MainActivity 就通读一遍了，虽然不会写，但只要有写过代码，并且比对原 Java 文件，相信都能读出个大概。 尽管不知道怎么写，但我们知道，字符串在这里只是显示作用，我们并没有对这个字符串做其他操作，所以可以直接修改这个字符串，当用户点击 Button 后，弹出的是我们修改后的内容，同时也不会影响到程序的正常运行。 而在我们游戏渠道打包的时候，大多数情况并不会手动修改里面的内容，因为实际上也没有太多必要，游戏逻辑是游戏研发商设计的，我们只需要注入 SDK，具体做法就是把我们的 SDK 打包并反编译成 Smali 文件，然后一一复制到母包中，覆盖原有的内容。 重新打包 不管是何种修改，肯定要重新打包才能够安装到手机上，重新打包也同样要用到『Apktool』，执行命令： ➜ java -jar apktool.jar b Demo -o New_Demo.apk 其中 b 是指 Build 的意思，后面指定了重新打包后的 APK 文件名称，这样你就会在同级目录中得到这个重新打包后的文件。 同样，为了简便可以用以下命令： ➜ java -jar apktool.jar b {解码后项目所在目录} 没有指定重新打包后的 APK 文件名，会默认在解码后的项目中创建一个名为 /dist 的文件夹，打开这个文件夹你就会发现一个和项目同名的 APK 文件，这就是重新打包后的文件了。 不过也不要高兴得太早，因为这个 APK 文件还不能直接安装在手机上。 APK Signature Scheme v1 重新打包后的 APK 文件不能直接安装在手机上，是因为这个安装包还没进行签名，平时我们要上线应用，都要先对应用进行签名，而现在经过我们反编译后原签名已经被破坏掉了，所以我们需要手动签名。 但是，假如我们反编译的是别人的 App，那我们从哪儿能拿到它原来的签名文件呢？很显然，根本没有办法拿到，因此我们只能拿自己的签名文件来对这个 APK 文件重新进行签名，但同时也表明我们重新打包出来的软件就是个十足的盗版软件。 这是 Android 为了保护版权而设立的机制，因此判定盗版 App 的标准就很明确了，只要你不是使用原版的签名，那就是盗版的，所以汉化软件实际上也是盗版软件，当然如果有人通过非法途径获取到了原版签名，那我也无话可说了。 签名的生成相信做 Android 开发的都不会陌生吧，直接到『Android Studio』中生成一个即可，有了签名文件后就可以执行命令： ➜ jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore {签名文件} -storepass {KeyStore_Password} {待签名的APK文件} {Key_alias} 该命令执行完成后你可能会发现并没有新增其他文件，实际上它是生成一个和原来待签名文件名相同的已签名的 APK 文件，并且覆盖了原来待签名的文件。 当然，配置参数不同写法也不尽相同，比如我最常用的： ➜ jarsigner -keystore {签名文件} -storepass {KeyStore_Password} -keypass {Key_Password} -signedjar {签名后的APK文件} {待签名的APK文件} {Key_alias} 这种方法会指定签名后的文件名称，而不会覆盖原有的待签名文件。 相信你已经注意到，这里用于签名的工具实际上是 JDK 中用于给 Jar 包签名的『JarSigner』，它会使用 SHA1 或者 SHA256 算法对 APK 中每个文件生成摘要并进行 BASE64 编码写入到 MANIFEST.MF 文件中，然后使用 SHA1 算法对 MANIFEST.MF 二次摘要再写入到 CERT.SF 中，接着使用私钥对 CERT.SF 签名，签名结果与公钥和证书一起打包写入 CERT.RSA 里，最后将以上生成的这三个文件保存到 /META-INF 目录，压缩入 APK 内。 当你直接解压 APK 文件的时候也会发现这些经过签名生成的文件。 签名之后的 APK 文件现在已经可以安装到手机上了。 对齐 Android 还极度建议我们对签名后的 APK 文件进行一次对齐操作，因为这样可以使得我们的程序在 Android 系统中运行得更快。 对齐操作使用的是『ZipAlign』工具，该工具存放于 /{Android_SDK}/build-tools/{version} 目录下，将这个目录配置到系统环境变量当中就可以在任何位置执行此命令了。命令格式如下： ➜ zipalign 4 {已签名的APK文件} {对齐后的APK文件} 其中 4 是固定值不能改变，指的是字节对齐参数，代表对齐为 4 个字节，据说输入其他值起不到任何作用，在 4 个字节边界上对齐的意思就是，一般来说，是指编译器把 4 个字节作为一个单位来进行读取的结果，这样的话相比之前没有对齐的情况，CPU 能够对变量进行高效、快速的访问。 另外，验证一个 APK 文件是否对齐的命令如下： ➜ zipalign -c -v 4 {待验证的APK文件} 其中 -c 就是用于确认 APK 文件是否对齐，-v 则表示输出详细日志，是可选参数，同时也可以用在上方对齐的命令中，4 也是字节对齐参数。 最后就可以得到一个已签名并对齐的安装包了。 APK Signature Scheme v2 我们在老版本的『Android Studio』中打包时会要求勾选 V1 和 V2 签名（新版本中已无需勾选，默认会两者都启用）： APK Signature Scheme v2 是一种全文件签名方案，该方案能够发现对 APK 的受保护部分进行的所有更改，从而有助于加快验证速度并增强完整性保证。 它从 Android 7.0（Nougat）开始支持，用于签名的工具『ApkSigner』内置在 Android SDK Build Tools 24.0.3 及更高的版本中。 官方文档中提到： To make a APK installable on Android 6.0 (Marshmallow) and older devices, the APK should be signed using JAR signing before being signed with the v2 scheme. 为了使 APK 可在 Android 6.0（Marshmallow） 及更低版本的设备上安装，应先使用 JAR 签名功能对 APK 进行签名，然后再使用 v2 方案对其进行签名。 因此，尽管你仅使用 V1 方案签名也可以使 APK 在设备上正常安装运行，但应当同时采用 V2 方案，且两套签名方案有明确的先后顺序。 官方文档中还提到： Caution: You must use zipalign at one of two specific points in the app-building process, depending on which app-signing tool you use: If you use apksigner, zipalign must only be performed before the APK file has been signed. If you sign your APK using apksigner and make further changes to the APK, its signature is invalidated. If you use jarsigner, zipalign must only be performed after the APK file has been signed. 注意：您必须在应用构建过程中的两个特定时间点之一使用 zipalign，具体在哪个时间点使用，取决于您所使用的应用签名工具： 如果您使用的是 apksigner，只能在为 APK 文件签名之前执行 zipalign。如果您在使用 apksigner 为 APK 签名之后对 APK 做出了进一步更改，签名便会失效。 如果您使用的是 jarsigner，只能在为 APK 文件签名之后执行 zipalign。 这样顺序就更加明确了，先使用『JarSigner』进行 V1 方案签名，再使用『ZipAlign』做对齐操作，最后再使用『ApkSigner』进行 V2 方案签名。 V2 方案签名命令如下： ➜ java -jar apksigner.jar sign --ks {签名文件路径} --ks-key-alias {Key_alias} --ks-pass pass:{KeyStore_Password} --key-pass pass:{Key_Password} --out {V2签名后的APK文件} {对齐后的APK文件} 虽然上方文档要求我们手动进行 V1 和 V2 方案签名，但是实际上『ApkSigner』也是支持 V1 方案签名的。它有一个配置的选项： The following options specify basic settings to apply to a signer: --v1-signing-enabled &lt;true | false&gt;: Determines whether apksigner signs the given APK package using the traditional, JAR-based signing scheme. By default, the tool uses the values of --min-sdk-version and --max-sdk-version to decide when to apply this signature scheme. 以下选项指定要应用于签名者的基本设置： --v1-signing-enabled &lt;true | false&gt;：确定 apksigner 是否会使用基于 JAR 的传统签名方案为给定的 APK 软件包签名。默认情况下，该工具会使用 --min-sdk-version 和 --max-sdk-version 的值来决定何时采用此签名方案。 因此我们可以不需要手动使用『JarSigner』进行 V1 方案签名，直接使用『ApkSigner』进行 V2 方案签名即可。 查询 APK 文件签名情况可以使用以下命令： ➜ java -jar apksigner.jar verify -v {需要查看签名的 APK} 至此，V2 签名方案也操作完成了。 生成已签名的 APK 文件的同时，你可以发现还自动生成了一个以 APK 文件名命名的 IDSIG 文件，默认情况下，IDSIG 文件包含 APK 文件的完整 Merkle 树。使用此标志时，『ApkSigner』会生成一个 V4 签名方案的 IDSIG 文件，且不会嵌入完整的 Merkle 树。 Google 在 Android 9（Pie）中引入了 APK Signature Scheme v3，在 Android 11（R）中引入了 APK Signature Scheme v4，这里暂不介绍。 测试 无论是破解还是 SDK 注入，都需要对最终的安装包进行测试，确认其是否按照我们期望的效果正常运行。 把这个 APK 文件安装到手机上来查看效果： 可以看到，无论是应用图标、应用名称，还是点击按钮后的响应逻辑，都修改成了我设定的样子，说明以上的所有操作都成功了。 以上就是 Android 反编译中的基本操作，当然也只是一个简单的入门，有很多东西没办法一一展开，以后有机会的话，可以再深入聊聊。 另外，还是要再次提醒，反编译技术仅用于学习和交流，请勿作于非法用途。 参考内容： zipalign | Android 开发者 | Android Developers APK 签名方案 v2 | Android 开源项目 | Android Open Source Project apksigner | Android 开发者 | Android Developers ","link":"https://LiarrDev.github.io/post/Getting-Started-with-Android-Decompilation/"},{"title":"Android 实时监听短信","content":"最近收到团队内部的一个需求，使用一台测试机来做短信转发，即写一个 App 监听短信，当收到的短信内容符合我们设定的规则时，通过接口传送给我们后端。 这个需求实际上并不难，有两个思路。 拦截短信广播 当手机收到短信时，会向系统发送一个广播，所以我们可以通过监听广播来获取短信内容。 public class SmsReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (!action.equals(&quot;android.provider.Telephony.SMS_RECEIVED&quot;)) { return; } Bundle bundle = intent.getExtras(); if (bundle == null) { return; } Object[] pdus = (Object[]) bundle.get(&quot;pdus&quot;); if (pdus == null) { return; } SmsMessage[] messages = new SmsMessage[pdus.length]; StringBuilder sender = new StringBuilder(); StringBuffer content = new StringBuffer(); StringBuffer time = new StringBuffer(); for (int i = 0; i &lt; pdus.length; i++) { sender.append(messages[i].getOriginatingAddress()); content.append(messages[i].getMessageBody()); time.append(messages[i].getTimestampMillis()); } ... } } 接收短信时发送的是一个有序广播，所以我们可以在注册时提高其优先级，避免被其他软件拦截： &lt;manifest ...&gt; &lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot; /&gt; &lt;application ...&gt; &lt;receiver android:name=&quot;.SmsReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;1000&quot;&gt; &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;/application&gt; &lt;/manifest&gt; 同时不要忘了动态申请 RECEIVE_SMS 权限。 这样就可以实时监听到短信的接收了，上面的代码我获取了发件人、短信内容以及时间戳，其他参数你也可以自行获取。 监听短信媒体库变化 除了监听系统广播，我们还可以监听短信媒体库的变化，短信一般都是存储在本地数据库中，我们能够像操作 SQLite 一样读取它。 public class SmsObserver extends ContentObserver { public SmsObserver(Handler handler, Context context) { super(handler); interceptSms(context); } private void interceptSms(Context context) { Cursor cursor = context.getContentResolver().query(Uri.parse(&quot;content://sms/inbox&quot;), null, null, null, &quot;date DESC&quot;); if (cursor.moveToFirst()) { String sender = cursor.getString(cursor.getColumnIndex(&quot;address&quot;)); String content = cursor.getString(cursor.getColumnIndex(&quot;body&quot;)); long date = cursor.getLong(cursor.getColumnIndex(&quot;date&quot;)); int type = cursor.getInt(cursor.getColumnIndex(&quot;type&quot;)); // 1：接收，2：发送 if (type == 1) { ... } } cursor.close(); } } 读取短信媒体库需要 READ_SMS 权限： &lt;manifest ...&gt; &lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt; ... &lt;/manifest&gt; 动态申请成功后，在代码中注册： SmsObserver smsObserver = new SmsObserver(new Handler(), this); getContentResolver().registerContentObserver(Uri.parse(&quot;content://sms&quot;), true, smsObserver); 这里给定的 Uri 可以查询不同的短信协议： 收件箱：content://sms/inbox 发件箱：content://sms/outbox 已发送：content://sms/sent 草稿：content://sms/draft 发送失败：content://sms/failed 待发送：content://sms/queued 通过 Cursor 查询并按照时间戳排序即可拿到最新的短信。 测试 测试也比较简单，两台手机就可以完成测试。 假如你没有两台手机，又或者心疼话费，那么也可以通过『Android Studio』自带的模拟器进行测试。 在实际生产环境应当在真机上进行测试，因为国产 ROM 魔改出于隐私考虑有可能会对短信做处理。 比较 通过广播拦截的方式，假如有其他应用的 BroadcastReceiver 高于你设定的优先级，那么你可能无法拦截到此短信。 而监听短信媒体库的方式，由于状态繁多，会导致 onChange() 方法多次触发，造成不必要的计算，即使是同一条短信，在接收时触发回调，在阅读时也会触发，应该是短信状态变更导致。 使用国产 ROM 测试发现，两种方法监听验证码类短信都无法 100% 成功，通过广播拦截方式，会接收不到该短信的广播，而使用监听短信媒体库的方式，会触发媒体库变动的接口，但你依然查不到验证码的短信。 由于模拟器没有实体 SIM 卡无法接收真实的短信，且国外对于短信验证码的普及率不高，所以无法测试也没有测试的必要。 如有条件可以使用国外手机如 Google Pixel 系列进行测试。 因此，暂时找不到能够拦截短信验证码的方法，但这也的确符合常理，因为在国内互联网环境下，获取到验证码就可以对其对应的账号进行各种操作，比如重置或盗刷等等，系统对于此类短信的屏蔽是完全合理的。 综上，对于非验证码类短信可以正常拦截，根据自己的需求选择不同的方法即可，对于验证码类短信，就别动坏心思了。 ","link":"https://LiarrDev.github.io/post/Real-time-Monitoring-of-SMS-in-Android/"},{"title":"Android 为 RecyclerView 设置分割线","content":"Android 开发者都知道，RecyclerView 是一个非常强大的组件，它的最基本作用是代替原来的 ListView，但又由于其灵活性，RecyclerView 能够帮我们实现许多复杂的页面布局方案。 用一句话概括就是，ListView 能实现的 RecyclerView 也能实现，ListView 实现不了的，RecyclerView 也能实现。 相信很多 Android 初学者也跟我一样，是从郭霖的《第一行代码——Android》这本书开始的，不得不说这是一本非常适合入门的书籍，但在里面介绍 RecyclerView 的章节中，郭霖并没有介绍过 RecyclerView 分割线的实现方法，而在第二版第 14 章实战『CoolWeather』项目中则有如下描述： 之所以这次使用了 ListView，是因为它会自动给每个子项之间添加一条分隔线，而如果使用 RecyclerView 想实现同样的功能则会比较麻烦，这里我们总是选择最优的实现方案。 的确，在默认情况下，ListView 是有分割线的，而 RecyclerView 却没有： 郭霖在书中对于 RecyclerView 界面的调整，大多是用 CardView 来实现，以致于我在后面很长一段时间内以为 RecyclerView 设置分割线需要写一些比较复杂的代码，但随着不断的学习，我发现这个理论实际上是错误的，RecyclerView 其实也能够轻松地设置分割线。 RecyclerView 设置分割线是通过 addItemDecoration() 方法来添加的，该方法接收一个 ItemDecoration 对象，ItemDecoration 是一个抽象类，而 RecyclerView 中恰好有一个默认的实现，也就是 DividerItemDecoration，所以我们可以直接使用： recyclerView.addItemDecoration(new DividerItemDecoration(this, DividerItemDecoration.VERTICAL)); DividerItemDecoration 的构造函数接收两个参数，第一个是 Context，用于访问资源，第二个 int 类型的参数表示分割线的方向，只能为 HORIZONTAL 或 VERTICAL，即水平或垂直。 只需要在 setAdapter() 之前调用上方代码即可。效果如下： 看到没有，只需添加一行代码，即可在每个子项之间添加一条与 ListView 中几乎一摸一样的分割线，相比 RecyclerView 的其他代码改造，实在不麻烦。当然，也有可能是郭霖为了避免在书中花篇幅介绍一个非基础的知识点而故意不提了，毕竟他也曾说要尽量减少书的厚度。 关于 DividerItemDecoration 的实现并不复杂，毕竟也就一条直线的事，我们可以看看源码： public class DividerItemDecoration extends RecyclerView.ItemDecoration { public static final int HORIZONTAL = LinearLayout.HORIZONTAL; public static final int VERTICAL = LinearLayout.VERTICAL; private static final String TAG = &quot;DividerItem&quot;; private static final int[] ATTRS = new int[]{ android.R.attr.listDivider }; private Drawable mDivider; private int mOrientation; private final Rect mBounds = new Rect(); public DividerItemDecoration(Context context, int orientation) { final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); if (mDivider == null) { Log.w(TAG, &quot;@android:attr/listDivider was not set in the theme used for this &quot; + &quot;DividerItemDecoration. Please set that attribute all call setDrawable()&quot;); } a.recycle(); setOrientation(orientation); } public void setOrientation(int orientation) { if (orientation != HORIZONTAL &amp;&amp; orientation != VERTICAL) { throw new IllegalArgumentException(&quot;Invalid orientation. It should be either HORIZONTAL or VERTICAL&quot;); } mOrientation = orientation; } public void setDrawable(@NonNull Drawable drawable) { if (drawable == null) { throw new IllegalArgumentException(&quot;Drawable cannot be null.&quot;); } mDivider = drawable; } @Nullable public Drawable getDrawable() { return mDivider; } @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) { if (parent.getLayoutManager() == null || mDivider == null) { return; } if (mOrientation == VERTICAL) { drawVertical(c, parent); } else { drawHorizontal(c, parent); } } private void drawVertical(Canvas canvas, RecyclerView parent) { canvas.save(); final int left; final int right; if (parent.getClipToPadding()) { left = parent.getPaddingLeft(); right = parent.getWidth() - parent.getPaddingRight(); canvas.clipRect(left, parent.getPaddingTop(), right, parent.getHeight() - parent.getPaddingBottom()); } else { left = 0; right = parent.getWidth(); } final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); parent.getDecoratedBoundsWithMargins(child, mBounds); final int bottom = mBounds.bottom + Math.round(child.getTranslationY()); final int top = bottom - mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); } canvas.restore(); } private void drawHorizontal(Canvas canvas, RecyclerView parent) { canvas.save(); final int top; final int bottom; if (parent.getClipToPadding()) { top = parent.getPaddingTop(); bottom = parent.getHeight() - parent.getPaddingBottom(); canvas.clipRect(parent.getPaddingLeft(), top, parent.getWidth() - parent.getPaddingRight(), bottom); } else { top = 0; bottom = parent.getHeight(); } final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); parent.getLayoutManager().getDecoratedBoundsWithMargins(child, mBounds); final int right = mBounds.right + Math.round(child.getTranslationX()); final int left = right - mDivider.getIntrinsicWidth(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(canvas); } canvas.restore(); } @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { if (mDivider == null) { outRect.set(0, 0, 0, 0); return; } if (mOrientation == VERTICAL) { outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); } else { outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); } } } 首先就是获取传入的方向，也就是水平还是垂直，然后在 onDraw() 中根据方向调用 drawVertical() 或 drawHorizontal() 实现对分割线的绘制。 绘制前先测量 RecyclerView 的 padding，以得到与 item 不相邻两边的宽度。通过 getChildCount() 获取 item 的数量，然后遍历各个 item，分别计算与 item 相邻两边的宽度，即可绘制出分割线的区域。 getItemOffsets() 方法用于设置 item 的 padding 属性，setDrawable() 则用于设置分割线的样式。 了解原理之后，我们就可以更灵活地为 RecyclerView 自定义分割线了。 举个例子，我们可以看到微信常用的一种分割线方式，是左侧有间隔的分割线： 那我们可以参照上方源码简单写一个： public class WeChatDividerItemDecoration extends RecyclerView.ItemDecoration { private static final int[] ATTRS = new int[]{android.R.attr.listDivider}; public static final int HORIZONTAL = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL = LinearLayoutManager.VERTICAL; private static final String TAG = &quot;DividerItem&quot;; private Drawable mDivider; private int mOrientation; private int mMarginStart, mMarginEnd; public WeChatDividerItemDecoration(Context context, int orientation, int marginStart, int marginEnd) { final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); if (mDivider == null) { Log.w(TAG, &quot;@android:attr/listDivider was not set in the theme used for this &quot; + &quot;DividerItemDecoration. Please set that attribute all call setDrawable()&quot;); } mMarginStart = marginStart; mMarginEnd = marginEnd; a.recycle(); setOrientation(orientation); } public void setOrientation(int orientation) { if (orientation != HORIZONTAL &amp;&amp; orientation != VERTICAL) { throw new IllegalArgumentException(&quot;Invalid orientation. It should be either HORIZONTAL or VERTICAL&quot;); } mOrientation = orientation; } @Override public void onDraw(@NonNull Canvas c, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) { if (parent.getLayoutManager() == null || mDivider == null) { return; } if (mOrientation == VERTICAL) { drawVertical(c, parent); } else { drawHorizontal(c, parent); } } private void drawVertical(Canvas canvas, RecyclerView parent) { final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left + mMarginStart, top, right - mMarginEnd, bottom); mDivider.draw(canvas); } } private void drawHorizontal(Canvas canvas, RecyclerView parent) { final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) { final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top + mMarginStart, right, bottom - mMarginEnd); mDivider.draw(canvas); } } @Override public void getItemOffsets(@NonNull Rect outRect, @NonNull View view, @NonNull RecyclerView parent, @NonNull RecyclerView.State state) { if (mDivider == null) { outRect.set(0, 0, 0, 0); return; } if (mOrientation == VERTICAL) { outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); } else { outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); } } } 效果如下： 只需通过构造函数将 marginStart 和 marginEnd 传入，通过在绘制时增减对应的边距，就可以自由的控制分割线两端的距离，同时还可以利用 drawVertical() 和 drawHorizontal() 分别适配两个方向。 可以看到，即使是自定义分割线，也并不困难，只要参考 DividerItemDecoration 中的代码，我们也可以依葫芦画瓢实现自己想要的效果。 ","link":"https://LiarrDev.github.io/post/Setting-Divider-for-RecyclerView-in-Android/"},{"title":"关于客户端域名被劫持的解决方案思考","content":"最近公司项目用到的某个域名在北京地区出现大量无法访问的情况，用户最直观的感受就是，打开 WebView 页面时，出现了他们看不懂的提示： 其实 net::ERR_CONNECTION_REFUSED 这个提示太虚，不只是用户，我们作为开发看到的时候也不一定能马上反应过来。 技术开会后得出是 DNS 被劫持了，这得联系当地运营商解决，我们临时的解决方案就是替换域名（一般企业都应该有备用域名），重新出包给用户替换。 等运营商解决全凭运气，重新出包也是临时解决，我们应该利用备用域名考虑一套解决方案。 复现 首先要尝试复现场景，因为我不在北京，自然无法直接的复现这个问题，但我们可以思考这个问题的本质。 之前在『一文带你简单了解 Hosts』中提到，域名和 IP 有映射关系，DNS 服务器与 Hosts 一样，充当着解析这层映射的角色，也就是说，当解析出错的时候，就会产生上面的问题。 那么所谓的「解析出错」应当如何判断？ 也很简单，既然域名和 IP 有映射关系，出错则意味着域名无法解析为正确的 IP，我们可以利用 Hosts 去实现这一点，具体操作参考『Android 修改 Hosts』一文。 接下来写个 WebView 加载一个网页，我这里就拿阿里云官网来写个 Demo，效果如下： 然后，通过『IPAddress.com』查一下百度官网的 IP，修改 Hosts 文件，将阿里云官网域名映射到百度的 IP 上： 14.215.177.38 www.aliyun.com 再次运行刚刚的 Demo，可以看到页面没有加载出来： 这似乎跟我一开始的情况不太一样，将域名指向本地主机试试看： 127.0.0.1 www.aliyun.com 情况复现： 复现之后就能够针对性的解决了。 WebView 处理方案 测试发现，以上两种情况会分别回调 WebViewClient 中的 onReceivedSslError() 和 onReceivedError() 接口，我们可以在这两个回调中去做切换域名的操作，来规避 DNS 被劫持产生的错误页面： webView.setWebViewClient(new WebViewClient() { @Override public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) { super.onReceivedSslError(view, handler, error); // 切换域名 } @Override public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) { super.onReceivedError(view, errorCode, description, failingUrl); // 切换域名 } @Override public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) { super.onReceivedError(view, request, error); // 切换域名 } }); 需要注意的是，尽管页面有提示 net::ERR_CONNECTION_REFUSED 的内容，但不要尝试抓取相应的描述内容去进行处理，因为不同的错误可能会产生不同的描述，你无法预测到所有的情况，还是在回调中统一处理比较好。 网络请求处理方案 大多数项目中使用的都是同一套域名，这也就意味着，WebView 不能正常打开网页的情况下，同域名的普通网络请求也会失败。 网络请求下判断劫持似乎有点麻烦，因为它不像 WebView 那样直接走对应的回调，而且每个网络请求框架的封装也不尽相同。 域名被劫持时进行网络请求，得到的响应理论上是为空的，但假如指向的 IP 拥有相同的目录也可能出现不为空的情况。 如果尝试根据响应的 HTTP CODE 判断，网络请求框架一般会返回 0，当然也会有返回如 404 或者 500 的，这种方法更加不靠谱。 而且当域名被劫持时，意味着该域名下的所有接口都不能正常访问，假若每个接口都做重复判断，会造成代码冗余以及耗时增加。 我们最终的处理方案是，单独提供一个判断域名是否正常的接口，在初始化阶段调用，如果出现问题就替换为备用域名，只需做一次判断操作，后续请求时直接将接口切到备用域名中。 代码大致如下： public enum HostChecker { INSTANCE; private int retryIndex = -1; private String HOST_NAME = BASE_DOMAIN; public void checkHost() { String[] domains = DomainConfig.getDomains(); if (domains == null || domains.length &lt;= 0) { return; } checkHostConnection(domains); } public String replaceHost(String url) { if (url.contains(BASE_DOMAIN)) { return url.replace(BASE_DOMAIN, HOST_NAME); } } private void checkHostConnection(final String[] domains) { RequestManager.checkHost(retryIndex, new RequestCallback() { @Override public void onRequestSuccess(String content) { try { JSONObject jsonObject = new JSONObject(content); if (jsonObject.optBoolean(&quot;status&quot;)) { HOST_NAME = retryIndex == -1 ? BASE_DOMAIN : domains[retryIndex]; } else { retryIndex++; checkHostConnection(domains); } } catch (JSONException e) { retryIndex++; checkHostConnection(domains); } } @Override public void onRequestError(String error) { retryIndex++; checkHostConnection(domains); } @Override public void onRequestTimeout(String msg) { retryIndex++; checkHostConnection(domains); } }); } } 封装一个单例的检查器，暴露两个方法，其中 checkHost() 在初始化的时候调用，用于判断域名是否正常运作，如果不能，则替换为可用的备用域名，replaceHost() 在网络请求的时候调用，这里无需再做判断，任何请求的接口都会切为可用的域名。 public class RequestManager { ... public void doRequest(final String requestUrl, final RequestParams params, final RequestCallback callback) { final String url = HostChecker.INSTANCE.replaceHost(requestUrl); HttpUtil.doRequest(url, params, callback); } public void checkHost(int retryIndex, final RequestCallback callback) { String[] domains = DomainConfig.getDomains(); if (domains == null || domains.length &lt;= 0) { return; } if (retryIndex &lt; -1 || retryIndex &gt;= domains.length) { return; } final String url; if (retryIndex &gt;= 0) { url = CHECK_HOST_URL.replace(BASE_DOMAIN, domains[retryIndex]); } else { // -1 url = CHECK_HOST_URL; } HttpUtil.doRequest(url, null, callback); } } 我这里将备用域名存放在数组中，这样如果备用域名有多个的话，可以通过索引直接访问到对应域名，我们知道数组的索引是从 0 开始的，我在这里将初始索引标记为 -1，可以理解为该索引对应的是默认的域名（实际上并不是），假如默认域名不能正常工作，只需将索引的值加 1 就能直接从备用域名数组的首个值开始了，索引自增操作在数组内可以访问下一个值，于是便能形成递归复用。 小结 实际上，假如 WebView 并不在应用打开时立即显示的话，我更建议直接复用网络请求的全局替换方案，因为这个方案只在初始化阶段执行一次，即可在当次会话中直接使用，否则 WebView 如果多次回调到失败接口会造成较长时间的白屏，影响体验。而如果首页即为 WebView 的话，使用网络请求全局替换方案由于请求异步，可能会造成 WebView 加载失败，所以应当结合项目实际情况合理选择方案。 虽然示例依然是 Android 客户端的 Java 代码，但标题我说的是「客户端」，也就意味着 iOS 等其他客户端平台开发也可以采用相似的策略，后来我还想了一下其他方案，靠 ping 来判断是否被劫持理论上也是可行的。 在网上搜索相关内容，基本都是无解的，实际上也正常，因为这本来就不是客户端的锅，但同时也不正常，毕竟在移动客户端发展的十余年间，相信有许多开发者都遇到过这种问题，理应有一个解决的思路。 标题中我用的是「思考」这个词，因为没有前辈们的方案做参考，所以我也不确切上面的方案是否正确，只能根据自己的思路来写，希望对后来者有所帮助，也希望有踩过坑的开发者能提供更好的思路。 ","link":"https://LiarrDev.github.io/post/Thinking-about-the-Solution-of-Client-Domain-being-Hijacked/"},{"title":"Android 修改 Hosts","content":"之前『一文带你简单了解 Hosts』文末提到会带来 Hosts 修改教程系列文章，在『Windows 修改 Hosts』和『macOS 修改 Hosts』之后，你以为这个系列就结束了？不，我又回来了。 这一次，是 Android 系统修改 Hosts 教程。 这篇文章其实机缘巧合，因为我在 Android 开发中刚好需要通过修改 Hosts 来跟后端工程师配合测试，所以这篇文章就正好水到渠成。 因为在 Android 上修改 Hosts 需要获取 ROOT 权限，所以我这次就用模拟器来代替真机演示，使用的是『夜神模拟器』，任何 Android 模拟器都可以使用以下方法操作。 由于现在很多国内 ROM 限制解锁权限，如 EMUI 等，获取 ROOT 权限操作步骤可能相对复杂，就不再花篇幅介绍了，假如你的手机成功获取了 ROOT 权限，以下方法也是适用的。 修改 Android 系统的 Hosts 需要提前准备 ADB（Android Debug Bridge）工具，我本来就是从事 Android 开发的，开发工具中已经集成了 ADB，不需要重新安装，在之前的『Android Device Monitor 权限笔记』中我也使用过它，在此就不过多介绍了。 如果你的电脑上没有 ADB，可以去单独下载；另外，Android 模拟器的安装目录下一般也会有 ADB 工具，配置到系统环境中即可。 首先，先用终端查看连接的设备： ➜ adb devices 许多模拟器在初次使用 ADB 连接时都不一定能连接上，可以自行搜索对应的解决方法，最常见的就是需要执行 adb connect 命令连接到对应的端口，也有可能遇到 ADB 版本不一致的问题，使用模拟器目录下的 ADB 或者将正在使用的 ADB 工具覆盖模拟器的 ADB 即可。 通过 ADB 正确连接上 Android 模拟器后，接下来就是修改 Hosts。 Hosts 目录为：/system/etc/hosts，在一切开始之前，我们还需要一个额外步骤，执行命令： ➜ adb remount 与其他系统一样，Android 对于 Hosts 文件的处理也是需要权限的，这条命令的作用是重新挂载 /system 分区为可读写。 然后通过命令将 Hosts 文件拉取到本地： ➜ adb pull /system/etc/hosts D:/hosts 这是一个常用的 ADB 命令，用于将手机上的文件复制到本地： ➜ adb pull {手机文件路径} {本机目录} 默认情况下 Hosts 里面只有两行内容： 127.0.0.1 localhost ::1 ip6-localhost 跟之前一样，直接在下面追加自己的 Hosts。然后推回去： ➜ adb push D:/hosts/hosts /system/etc/hosts 这也是一个常用的 ADB 命令，用于将本地的文件复制到手机： ➜ adb push {本机文件路径} {手机目录} 这里还有一个需要注意的点，不同于 Windows 和 macOS，在 Android 中修改 Hosts 一定要在文件末尾增加一个空行，假如你没有追加，Hosts 不会生效，而当你重新将 Android 设备的 Hosts 文件拉到本地你又会确认自己已经修改了，如此死循环导致你根本发现不了问题。 那这个问题我是如何发现的呢？ 很简单，不通过拉取文件来查看，因为你在电脑推到手机的文件，再拉回到电脑，依然是符合电脑的规范的，你需要知道 Android 是如何处理这个 Hosts 文件的。 依然需要通过 adb 命令来查看手机上的 Hosts 文件： ➜ adb shell ➜ cat /system/etc/hosts 解释一下，adb shell 很简单，就是进入 Shell 模式，之前在『Android Device Monitor 权限笔记』中也使用过了。 你可能会好奇，在『Android Device Monitor 权限笔记』中执行完 adb shell 后还需执行 su 来切换至超级管理员，为什么这里不需要呢？ 因为大部分模拟器默认就已经开启 ROOT 了所以不需要 su 来获取 ROOT 权限： 进入 Shell 后通过 cat 命令来查看文件内容。 默认情况下，查询结果如下： 假如添加完内容后，不追加一个空行，会得到如下结果： 发现了吗，下一条命令的输入位置跟在了最后一行 Hosts 内容之后，这就是导致 Hosts 不生效的原因，所以一定要确保 Hosts 文件最后一行为空行。 对文件的 push 和 pull 有点太麻烦，我更喜欢用命令来做写入操作： ➜ adb shell ➜ echo -e \\\\n &gt;&gt; /system/etc/hosts ➜ echo ***.***.***.*** www.domain.com &gt;&gt; /system/etc/hosts 通过 echo 写入一个换行符 \\n，这个程序员都不陌生了，实际上这个换行符不是必须的，不过是为了防止原 Hosts 末尾没有换行罢了，再把对应的 Hosts 写入，使用这条命令追加 Hosts 会自动在文件末尾追加一个空行，所以不用担心会出现上面的问题。如果要增加多个 Hosts 则重复最后这步即可。 前面用来查看文件内容的 cat 这个命令是否看起来有些许熟悉？ 没错，我们之前在『macOS 修改 Hosts』中也有使用过，实际上，我们同样可以使用之前提到过的 vi 命令做修改： ➜ adb shell ➜ vi /system/etc/hosts 也是相同的命令，使用 i 进行插入修改，点击 Esc 退出编辑，再键入 :wq 并回车执行保存退出。 我尝试了一下『macOS 修改 Hosts』中使用过的 nano 命令，发现并不支持。 对于判断 Hosts 文件是否生效，我们还可以直接在 Shell 中用 ping 命令查看，比通过浏览器或者网络请求要方便一些。 ","link":"https://LiarrDev.github.io/post/How-to-Edit-Hosts-in-Android/"},{"title":"『Android Studio』如何导入 AAR 包","content":"在『「Android Studio」如何导入 JAR 包』和『「Android Studio」如何导入 SO 库』之后，终于迎来了最重要的 AAR 包了。自从 Android 摆脱『Eclipse』步入『Android Studio』新纪元之后，ARR 包才是更加完美的第三方库方案。 为什么这么说？ 『「Android Studio」如何导入 JAR 包』一文中提到，JAR 的全称是 Java Archive，而 AAR 的全称则是 Android Archive，高下立判有没有？ AAR 是一个 Android 库项目的二进制归档文件，但文件本身是一个简单 ZIP 文件。 相比 JAR，AAR 包含了更多的资源，因为它是以『Android Studio』中的 Module 为基础建立的。通过解压 AAR，你可以看到有「AndroidManifest.xml」、「classes.jar」、「R.txt」等文件以及「res」等文件夹，同时它也能够包含 SO 库，这也就意味着 AAR 能够比 JAR 和 SO 提供更加强大的能力，比如 UI 库等，可以说是 Android 库的万金油封装方式。 既然如此，AAR 的导入方式就与 JAR 的导入有些许差异了。 首先，当然是要将 AAR 文件放到项目中，这里以开源库 Glide 为例，与 JAR 相似，都是放在 Module 的「libs」目录下。 接着是添加依赖，同样也有很多种方式。 第一种，指定依赖。在 Module 的「build.gradle」文件中加入以下内容： android { ... repositories { flatDir { dirs 'libs' // 声明添加libs文件夹为库 } } } dependencies { ... implementation(name: 'glide-4.12.0', ext: 'aar') // 添加 aar_file_name.aar 文件为依赖 } 其中，implementation 的 name 属性为该 ARR 的文件名。 需要注意的是，关于 repositories 的配置在网上很多文章都讲得不明不白，说在项目的「build.gradle」文件中做修改，这种博主大概率没有搞清楚『Android Studio』中 Project 和 Module 的概念就出来误人子弟，所以一定要记住是在 Module 的「build.gradle」文件中做修改，否则将会导致 ARR 不能正常使用。 第二种方法，也是指定依赖，和 JAR 类似，我们可以使用如下方式直接依赖 AAR： dependencies { ... implementation files('libs/glide-4.12.0.aar') } 第三种，全部依赖。也和 JAR 类似，同样是在 Module 的「build.gradle」文件中加入以下内容： dependencies { implementation fileTree(dir: 'libs', include: ['*.jar','*.aar']) ... } 可以看到这种方式更加简洁，直接扩充 dependencies 中的 fileTree 使其 include 原有的 JAR 文件并加入 AAR 文件。 第四种，作为 Module 导入，这种方法步骤稍复杂一些。 首先新建一个 Module： 选择「Import .JAR/.AAR Package」： 填入 AAR 文件路径： 完成后『Android Studio』会生成一个 Module 文件夹： 最后，在需要引用的 Module 中将该 Module 导入： dependencies { ... implementation project(':glide-4.12.0') } 但使用该方法无法直接从调用处点击查看源码，个人感觉不太方便。 最后，还要介绍一种非常规的使用方式，这种方式在我做游戏渠道打包的时候也比较常用。 上文提到 AAR 在解压之后也有一个 JAR 文件，实际上 AAR 就是 JAR 加上其他资源的扩充。所以当我们拿到一个 AAR 包时，可以将其解压，然后使用『「Android Studio」如何导入 JAR 包』中的方法将 JAR 包导入，并将其他资源文件复制到 Module 中的各个对应的目录下即可，遵循无则复制有则追加的原则，如 AAR 中的「AndroidManifest.xml」中包含的声明，就要追加到 Module 的「AndroidManifest.xml」中去；如 AAR 中的 Layout 文件，一般直接复制到 Module 相同的文件夹。 这种方法其实在『Eclipse』上使用较多，因为『Eclipse』仅支持导入 JAR 而不支持 AAR，所以才会用到这种方式，这种方式是根据 Android 的打包合并原理得出的。 至于这几种方法的使用时机，可以参考之前的『Android Gradle Plugin 依赖项配置』一文，以及自己项目的实际情况，合理使用。 ","link":"https://LiarrDev.github.io/post/How-to-Import-AAR-in-Android-Studio/"},{"title":"macOS 修改 Hosts","content":"之前『Windows 修改 Hosts』介绍了如何在 Windows 平台修改 Hosts，今天来聊聊如何在 macOS 平台修改 Hosts。 首先依然是找到 Hosts，macOS 系统的 Hosts 文件路径为 Macintosh HD/private/etc/hosts： 由于系统文件管理器『Finder』并不会像 Windows 一样方便地从『此电脑』进入，所以我们其实还能通过『Finder』菜单「前往文件夹」功能直接进入。 在「前往文件夹」中输入 /etc/hosts 并点击「前往」即可直达。 找到 Hosts 后依然可以通过任何文本编辑器对其进行修改，但需要注意，etc 文件夹的默认权限为「只读」： 当你尝试修改 Hosts 文件时，系统会弹出如下提示： 我们可以将 Hosts 文件复制到桌面进行修改，修改完成后再复制到原目录下覆盖即可，覆盖时会要求输入密码或触控 ID，都是为了防止用户误操作。 既然是 etc 文件夹权限原因，我们还可以通过修改该文件夹的权限来直接编辑 Hosts 文件。 将 etc 文件夹中「everyone」的权限设置为「读与写」便可直接编辑 Hosts 文件，编辑完成后记得要将该权限改回来。 既然都用上 Mac 了，那就再介绍一个比较 Geek 的修改方式，用命令来修改。 打开『Terminal』，输入命令： ➜ sudo vi /etc/hosts 其中 sudo 表示以系统管理者的身份执行指令，由于默认情况下用户对 etc 目录的权限为「只读」，而「系统」的权限为「读与写」，所以通过该命令可以得到写权限，vi 则表示要编辑，后面就是 Hosts 文件路径。 执行该命令后，会要求输入本机密码，输入完成并回车就可以直接在『Terminal』中对 Hosts 文件进行编辑。 编辑需要用到 vi 命令，也不是很复杂，通过方向键移动光标，键入 i 代表插入（INSERT），随即进入编辑模式，编辑完成后，点击 Esc 退出编辑，再键入 :wq 并回车执行保存退出，Hosts 文件即修改完成。 除了 vi，我们也可以用 nano 来修改，同样在『Terminal』中输入命令： ➜ sudo nano /etc/hosts 执行完后同样要求输入密码进入编辑模式，同时『Terminal』底部还会展示快捷键介绍，似乎比 vi 要方便一些。 进入后不再需要其他命令，可直接编辑模式，编辑完成后点击 Control + O 保存，提示「File Name to Write: /etc/hosts」，回车确认，再按 Control + X 退出。 当你有大量的 Hosts 内容需要添加时，用上面这两个命令似乎并不是怎么方便，而修改文件夹权限或者文件副本却又一点都不 Geek，那可以考虑另一种方式。 先将需要追加的 Hosts 内容写到一个文件中，比如「hosts.txt」，然后执行命令： ➜ sudo -s ➜ cat ~/hosts.txt&gt;&gt;/etc/hosts cat 命令用于在末尾追加，&gt;&gt; 前面的是我们需要追加的 Hosts 内容文件路径，比如我这里就放在当前用户目录中，&gt;&gt; 后面的是源 Hosts 文件的路径，这样就能够将 Hosts 从一个文本文件中追加到系统 Hosts 文件中。 以上就是 macOS 修改 Hosts 的五种方法，同 Windows 一样，修改了 Hosts 文件后也有可能会出现不立马生效的情况，同样是需要刷新 DNS 缓存： ➜ sudo killall -HUP mDNSResponder 与 Windows 平台的命令是不一样的，由于使用了 sudo 所以同样要输入本机密码。 最后附上 macOS 平台下原始的 Hosts 文件内容： ## # Host Database # # localhost is used to configure the loopback interface # when the system is booting. Do not change this entry. ## 127.0.0.1 localhost 255.255.255.255 broadcasthost ::1 localhost 基本与 Windows 平台下一致，只不过将几个 localhost 取消了注释罢了，如果怀疑你的 Hosts 文件被病毒或木马修改，可复制以上内容修复 Hosts 文件。 ","link":"https://LiarrDev.github.io/post/How-to-Edit-Hosts-in-macOS/"},{"title":"写个脚本给 Windows 自动添加 Hosts","content":"之前聊到『Windows 修改 Hosts』的步骤，相信已经能够帮助很多普通用户学会如何在自己的电脑上修改 Hosts 了，但是修改 Hosts 毕竟不是一个基本技能，即使我们再努力的科普，总有人不会。 而作为网站管理员经常收到的反馈是，一些内部网站切换了网络环境之后打不开等等，针对这些对互联网认知都只停留在社交看剧游戏等开箱即用的小白，我们真的很难跟他们解释什么是 Hosts，为什么网站突然打不开，他们满脑子只有一个想法：你的网站出问题了。 为了让这群非技术人员闭嘴，最好的方法就是能够简化操作流程，减少操作步骤。嗯没错，技术人员马上就能脱口而出：写个脚本。 考虑到大多数普通用户都是使用 Windows 系统的，那就写一个针对 Windows 平台的脚本呗，添加 Hosts 是一个非常简单的操作，打开文件追加文本即可，所以我决定直接写批处理脚本。 @echo off set &quot;raw=185.199.108.133 raw.githubusercontent.com&quot; set &quot;gist=140.82.112.4 gist.github.com&quot; set &quot;api=140.82.112.6 api.github.com&quot; call :add call :add call :add &quot;%raw%&quot; call :add &quot;%gist%&quot; call :add &quot;%api%&quot; goto :eof :add findstr /i /c:&quot;%~1&quot; C:\\Windows\\System32\\Drivers\\etc\\hosts if errorlevel 1 ( &gt;&gt;C:\\Windows\\System32\\Drivers\\etc\\hosts echo,%~1 ) 这段代码可以分为三个部分。 首先定义了 3 个变量，分别对应 3 条 Hosts 内容，这里我以 Github 的部分域名举例。 然后将其按顺序追加，我在这里先追加两个换行，再追加 Hosts 内容，其实换行并不是必要的，因为默认情况下，Hosts 文件在末尾留一个空行，而追加换行的原因是为了避免由于用户个人操作文件末尾空行不在了导致直接追加到原 Hosts 末行造成的 Hosts 失效的问题。 最后就是根据路径找到文件进行操作。 脚本编写完成后，保存并修改文件格式为 .bat 后缀，即批处理（Batch）文件类型。将这个文件挂到网站上，当检测到用户无法正常访问某些域名时，提示下载并双击运行这个脚本，即可自动帮用户完成添加 Hosts 的操作。 ","link":"https://LiarrDev.github.io/post/Auto-Adding-Hosts-in-Windows-with-Batch-Script/"},{"title":"『Android Studio』如何导入 SO 库","content":"之前的文章『「Android Studio」如何导入 JAR 包』介绍了传统 JAR 包的导入方式，其实 Android 开发中还有一种相对来说用得比较少但却依然十分重要的库类型：SO 文件。 什么是 SO 库 SO 文件（Shared Object）是 Linux 下共享库文件，它的文件格式被称为 ELF 文件格式。由于 Android 操作系统的底层基于 Linux 系统，所以 SO 文件可以运行在 Android 平台上。 一般来说，SO 文件就类似于常说的动态链接库（DLL，即 Dynamic Link Library）, 都是 C 或 C++ 编译出来的。 Android 系统也同样开放了 C/C++ 接口供开发者开发 Native 程序。由于基于虚拟机的编程语言 Java 更容易被人反编译，因此越来越多的应用将其中的核心代码以 C/C++ 为编程语言，并且以 SO 文件的形式供上层 Java 代码调用，以保证安全性。 Android ABI 不同于 Java 利用虚拟机实现「Compile Once, Run AnyWhere」的跨平台的特性，C/C++ 是「Write Once, Compile EveryWhere」的，这就导致了其需要针对不同的平台进行编译。 由于 Android 的开源，不同的厂家可以根据自己的需求在不同的硬件上接入 AOSP，因此不同的 Android 设备使用不同的 CPU，而不同的 CPU 支持不同的指令集。CPU 与指令集的每种组合都有专属的 ABI（Application Binary Interface，应用二进制接口）。 目前常见的 ABI 有如下几种： armeabi：第 5 代 ARM v5TE，使用软件浮点运算，兼容所有 ARM 设备，通用性强，速度慢（只支持 armeabi）。 armeabi-v7a：第 7 代 ARM v7，使用硬件浮点运算，具有高级扩展功能（支持 armeabi 和 armeabi-v7a）。 arm64-v8a：第 8 代，64 位，包含 AArch32、AArch64 两个执行状态对应 32-bit 和 64-bit（支持 armeabi-v7a、armeabi 和 arm64-v8a）。 x86：Intel 32 位，一般用于平板（支持 x86 和 armeabi 但性能有所损耗）。 x86_64：Intel 64 位，一般用于平板（支持 x86 和 x86_64）。 mips：32 位，支持 RISC。 mips64：64 位，支持 RISC。 项目导入 SO 库 因为 SO 库是针对不同 CPU 架构编译出来的，所以其往往不会像 JAR 一样只会编译一份，而是会针对不同的 ABI 生成多个 SO 库，所以我们在使用时也需要往项目中导入多个 SO 文件。 由于包含 SO 文件的开源框架并不十分常见，我在这里就以 vivo 网游联运 SDK 为例进行介绍。 首先将其提供的 SDK 压缩文件下载到本地，并对其解压，得到如下目录： 可以看到，vivo 网游联运 SDK 提供了 armeabi、armeabi-v7a、arm64-v8a、x86 和 x86_64 共五种架构的支持，SO 文件分别以同名的方式位于这五个文件夹下，这与我们的 res 类型同名文件存放方式是相似的。 接下来就可以导入了，『Android Studio』中 SO 库的导入有三种方式。 通过 libs 目录导入 理论上，『Android Studio』中所有的库文件都可以扔进「libs」目录，正如之前介绍过的『「Android Studio」如何导入 JAR 包』一般。 将 SO 文件及上层文件夹复制到 Module 的「libs」目录下： 由于 Java 代码调用 SO 库涉及到跨语言交互，所以必须通过 JNI（Java Native Interface）进行，同时，通过 JNI 交互的文件也必须通过标识才能被『Android Studio』处理，因此还需要在 Module 的「build.gradle」中加入如下代码： android { ... sourceSets { main { jniLibs.srcDirs = ['libs'] } } } 同步之后即可在项目中使用了。 切换至「Android」视图下，你还可以发现『Android Studio』将其识别为「jniLibs」文件夹： 通过 jniLibs 目录导入 除了将「libs」目录指定为「jniLibs」文件夹，我们还可以为 SO 库创建专门的「jniLibs」目录。 在 /src/main 目录下新建一个名为「jniLibs」的文件夹，将 SO 文件及上层文件夹复制到该目录即可： 由于文件夹的名称已经做了标识，所以我们无需添加代码告知『Android Studio』去处理。 以 JAR 包的方式导入 这种方式比较少见。 我们可以将 SO 库按照如下目录结构压缩成 JAR，之前『「Android Studio」如何导入 JAR 包』一文也提到，JAR 是以 ZIP 格式构建的，所以可以使用任何压缩工具甚至是命令来压缩。 然后按照『「Android Studio」如何导入 JAR 包』一文所提到的方法，跟导入普通 JAR 包一样导入即可。 当不同库兼容的 ABI 不一致 由于系统会根据 CPU 架构去运行不同的 SO 库，在实际开发项目中，假如我们引用了其他第三库，而这个库可能兼容的 ABI 与已有的不一致，就会产生问题。 举个例子，比如上方举例的 vivo 网游联运 SDK 兼容了 armeabi、armeabi-v7a、arm64-v8a、x86 和 x86_64 五种架构，我现在引入微信语音识别 SDK，发现其支持 armeabi-v7a、armeabi、mips 和 x86 四种架构，导入后每个文件夹中的 SO 文件并不对等，运行到某些设备上就会崩溃。 因为当应用运行时，设备会有先查看与 CPU 匹配的最优 ABI，如果没有，才会去查找其他 ABI，当 CPU 与 ABI 匹配上后，应用仅会读取该 ABI 下的 SO 库，其他 ABI 会直接被无视，假若该 ABI 缺失了对应的 SO 库，运行到对应代码时就会崩溃。 所以，遇到这种情况时，我们需要对 ABI 做处理。 仅保留交集 ABI 这种解决方法非常简单粗暴，就是取交集，仅保留所有库都支持的 ABI，其他文件夹都删除。 比如上方举例提到的两个第三方 SDK，取交集后可以保留 armeabi、armeabi-v7a 和 x86 三种 ABI。 当然，考虑到市面上设备占比以及目标用户分布，你甚至可以仅保留 armeabi-v7a 一种 ABI。 将已有的 SO 文件复制到其他 ABI 目录 前面提到，arm64-v8a 是兼容 armeabi-v7a 和 armeabi 的，所以，你还可以将其复制到空缺的文件夹。 比如将微信语音识别 SDK 中 armeabi 下的 SO 文件复制到 arm64-v8a 下，就可以使其支持 arm64-v8a 了。 ABI Filters 部分第三方库你还可能是通过远程依赖的，这时候对不同 SDK 的 ABI 处理就会变得复杂，但我们其实可以通过 Gradle 来操作。 在 Module 的「build.gradle」中加入如下代码： android { ... defaultConfig { ... ndk { abiFilters 'armeabi', 'arm64-v8a', 'x86' } } } 这样，『Android Studio』就可以针对我们指定的 ABI 进行构建了。 参考内容 Android ABIs | Android NDK | Android Developers ","link":"https://LiarrDev.github.io/post/How-to-Import-SO-in-Android-Studio/"},{"title":"Windows 修改 Hosts","content":"之前『一文带你简单了解 Hosts』科普了 Hosts 相关内容，这次就教大家如何修改 Hosts。 考虑到大多数用户最常用的都是 Windows 系统，所以就先来介绍 Windows 下修改 Hosts 的方法，别担心，其他系统后面有机会也会介绍。 要修改 Hosts，那首先得找到 Hosts 文件。大多数情况下，Hosts 文件的路径为：C:\\Windows\\System32\\drivers\\etc\\hosts。 Hosts 文件可以用任何文本编辑工具打开，如记事本等。 Windows 平台下原始的 Hosts 文件内容如下： # Copyright (c) 1993-2009 Microsoft Corp. # # This is a sample HOSTS file used by Microsoft TCP/IP for Windows. # # This file contains the mappings of IP addresses to host names. Each # entry should be kept on an individual line. The IP address should # be placed in the first column followed by the corresponding host name. # The IP address and the host name should be separated by at least one # space. # # Additionally, comments (such as these) may be inserted on individual # lines or following the machine name denoted by a '#' symbol. # # For example: # # 102.54.94.97 rhino.acme.com # source server # 38.25.63.10 x.acme.com # x client host # # localhost name resolution is handled within DNS itself. # 127.0.0.1 localhost # ::1 localhost 如果你怀疑你的 Hosts 文件被病毒或木马修改，可复制以上内容修复 Hosts 文件。 值得一提的是，每行 # 后面的内容都是注释，所以实际上清空 Hosts 内容对系统正常运行并没有什么影响。 Hosts 一般由网站的管理员提供，当然也有一些特殊途径，Hosts 的获取不在本文的介绍范围，一些公共的网站 IP 你可以尝试使用『IPAddress.com』等第三方工具查询。 当你需要添加 Hosts 的时候只需要在文件的末尾追加即可，Hosts 由 IP 和域名共同组成，如： 172.217.8.249 developer.android.com 修改完成后保存即可。 有时候你会遇到无法直接修改系统 Hosts 文件的情况，可以通过将 Hosts 文件复制到桌面，修改完成后再覆盖来解决。 还有可能会出现不能覆盖的情况，这可能涉及到权限问题，应检查当前登录账号的权限，以及文件的读写权限等。 需要注意，Hosts 文件配置的映射是静态的，如果网络上的计算机更改了请及时更新 IP 地址，否则将不能访问。 最后，相信有些朋友会遇到修改 Hosts 后不生效的情况，一般是由于 DNS 缓存的原因导致的。 系统为了加快用户打开网站的速度，在首次访问网站成功之后，会把 DNS 解析的结果暂时性地保存在本地缓存（称为 DNS 缓存）里一小段时间，如果浏览器在这段时间里再次打开同一个网址，则会自动从 DNS 缓存里取出结果，而不会请求远程的 DNS 服务器，也不会查询 Hosts 文件，从而节省时间提高打开速度。 因此如果遇到修改了 Hosts 文件但并不生效的情况，就刷新一下系统的 DNS 缓存即可。 Windows 平台只需打开任一命令行终端，如『CMD』或『Windows PowerShell』等，执行命令： ➜ ipconfig /flushdns 可以看到返回“已成功刷新 DNS 解析缓存”，代表刷新成功，如果还是不行，就重启大法好吧。 ","link":"https://LiarrDev.github.io/post/How-to-Edit-Hosts-in-Windows/"},{"title":"『Android Studio』如何导入 JAR 包","content":"开发中我们常常会需要用到第三方库来实现某些功能，可以避免重复造轮子，提高开发效率。 在 Android 中，JAR 包可以说是一代元老了，因为在 2017 Google IO 大会以前，Java 作为唯一的 Android 原生开发语言，以及在『Eclipse』的统治下，JAR 包是最通用的第三方库流通方式。 JAR 是一种归档文件，以 ZIP 格式构建，全称是 Java Archive。与 ZIP 不同的是，JAR 不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被像编译器和 JVM 这样的工具直接使用。在 JAR 中包含特殊的文件，如 Manifest 和部署描述符，用来指示工具如何处理特定的 JAR。 正是由于过去十几年『Eclipse』的影响，在『Android Studio』中导入 JAR 包也非常简单。 首先，当然要将 JAR 文件放到项目中，置于 Module 的「libs」目录下，我这里以开源库 Gson 为例。 在「Android」视图下，「libs」目录是默认不显示的： 我们无需新建该文件夹，只需切至「Project」视图即可： 接着是添加依赖，将 JAR 复制到「libs」目录后，鼠标对该 JAR 包右键菜单，点击「Add As Library...」： 并选择导入的 Module： 确定后，Gradle 会自动帮我们同步依赖。 你可以看到 Module 的「build.gradle」文件中自动添加了对应的内容： dependencies { ... implementation files('libs/gson-2.8.6.jar') } 当你有多个 JAR 包需要导入时，其实并不需要对每个 JAR 包都进行上述操作，你可以使用一行代码导入该 Module 下所有 JAR 包： dependencies { implementation fileTree(dir: 'libs', include: ['*.jar']) ... } 这行代码的意思就是将「libs」目录下所有的 JAR 文件添加依赖，只需在添加 JAR 包后同步 Gradle 即可。 你可能会想，那直接用第二种方法不就好了吗，多方便是不是？ 这就要考虑 Module 的依赖传递关系了，可以参考『Android Gradle Plugin 依赖项配置』一文，当有多个 JAR 包需要导入，但需要使用不同的依赖项配置时，就需要分别导入。 所以应当根据合适的场景使用合适的导入方式。 ","link":"https://LiarrDev.github.io/post/How-to-Import-JAR-in-Android-Studio/"},{"title":"Android Gradle Plugin 依赖项配置","content":"做 Android 开发必定会依赖第三方库，比如常用的如网络请求框架 OkHttp、图片加载框架 Glide 等，即使你完全采用原生 API 来开发，也会依赖 AppCompat 或者 Support 之类的官方库。 以前 Android 开发是在『Eclipse』上进行的，开发者使用第三方库往往需要手动下载 Jar 包再到『Eclipse』内引用，在『Android Studio』推出后，得益于 Gradle 构建工具，我们只需在 Gradle 文件中用使用一行代码即可将第三方库从远程站点依赖到项目中，十分方便。 我们引用依赖一般都是使用 implementation 配置依赖项，的确大多数第三方库文档的 Usage 都是这么写的，大多数情况下我们这么用也没问题，但是我们依然需要了解其他的依赖项配置。 implementation 首先我们从最熟悉的 implementation 开始，为什么 implementation 是绝大多数第三方库文档所介绍的配置方式，同时也是『Android Studio』的默认配置方式？ 原因其实很简单，与其他配置方式相比，此依赖项配置可以显著缩短构建时间，因为这样可以减少构建系统需要重新编译的 Module 数。 当 implementation 依赖项更改了其 API，Gradle 只会重新编译该依赖项以及直接依赖于它的 Module。同时，该 Module 在编译时不会将该依赖项泄露给其他 Module，也就是说，其他 Module 只有在运行时才能使用该依赖项。 api 当一个 Module 包含 api 依赖项时，该 Module 会以传递方式将该依赖项导出到其他 Module，以便这些 Module 在运行时和编译时都可以使用该依赖项。 此配置的行为类似于 compile（现已弃用），会以传递方式导出到其他上游消费者。 其与 implementation 的最大区别在于能否被上游消费者调用，如下图所示： 假设 Module X 同时依赖 Library A 和 Library B，而 Library A 通过 implementation 引用 Library C，而 Library B 则使用 api 引用 Library D。 这时候，Module X 是不能够直接使用 Library C 的，但却能够直接使用 Library D。因为 implementation 可以让 Module 在编译时“隐藏”自己使用的依赖，而 api 则会“传递”自己的依赖。 同时，如果 api 依赖项更改了其外部 API，Gradle 会在编译时重新编译所有有权访问该依赖项的 Module，因此，拥有大量的 api 依赖项会显著增加构建时间。 除非要将依赖项的 API 公开给单独的 Module，否则应使用 implementation 依赖项。 compileOnly Gradle 只会将依赖项添加到编译类路径，也就是说，不会将其添加到构建输出。 如果您创建 Module 时在编译期间需要相应依赖项，但它在运行时可有可无，此配置会很有用。 如果您使用 compileOnly，那么您的 Module 必须包含一个运行时条件，用于检查是否提供了相应依赖项，然后适当地改变该 Module 的行为，以使该 Module 在未提供相应依赖项的情况下仍可正常运行。 这样做不会添加不重要的暂时依赖项，因而有助于减小最终 APK 的大小。此配置的行为类似于 provided（现已弃用）。 runtimeOnly Gradle 只会将依赖项添加到构建输出，以便在运行时使用。也就是说，不会将其添加到编译类路径。 此配置的行为类似于 apk（现已弃用）。 annotationProcessor 我们在使用一些包含注解的第三方库时经常可以见到它，比如 Dagger 等。 如需添加对作为注解处理器的库的依赖，可以使用 annotationProcessor 配置将其添加到注解处理器的类路径。 使用此配置可以将编译类路径与注释处理器类路径分开，从而提高构建性能。 lintChecks 使用此配置可以添加您希望 Gradle 在构建项目时执行的 lint 检查。 需要注意，使用 Android Gradle Plugin 3.4.0 及更高版本时，此依赖项配置不再将 lint 检查打包在 AAR 项目中。 lintPublish 在 AAR 项目中使用此配置可以添加您希望 Gradle 编译成 lint.jar 文件并打包在 AAR 中的 lint 检查。这会使得使用 AAR 的项目也应用这些 lint 检查。 testImplementation 只在单元测试代码的编译以及最终打包测试 APK 时有效。 默认新建项目中 JUnit 就是以此配置依赖的，同时可以看到默认项目目录中除了我们一般写业务代码的 /src/main 目录外，还有 /src/test 目录供我们写本地单元测试，testImplementation 就可以为其 Source Set 添加依赖。 androidTestImplementation 只在单元测试代码的编译以及最终打包测试 APK 时有效。 默认新建项目中 Espresso 就是以此配置依赖的，同时可以看到默认项目目录中除了我们一般写业务代码的 /src/main 目录外，还有 /src/androidTest 目录供我们写仪器化单元测试、UI 测试等，androidTestImplementation 就可以为其 Source Set 添加依赖。 releaseImplementation / debugImplementation 仅仅针对 Release 或 Debug 模式的编译和最终的 Release / Debug Apk 打包。 DiDi 团队著名框架 DoKit 就是以此配置依赖的，可以针对 Release 和 Debug 采用不同的处理。 compile 该配置已弃用。 与 api 类似，Gradle 会将依赖项添加到编译类路径和构建输出，并将依赖项导出到其他 Module。 apk 该配置已弃用。 与 runtimeOnly 类似，Gradle 只会将依赖项添加到构建输出，以便在运行时使用，不会将其添加到编译类路径。 provided 该配置已弃用。 与 compileOnly 类似，Gradle 只会将依赖项添加到编译类路径，不会将其添加到构建输出。 参考 添加构建依赖项 | Android 开发者 | Android Developers ","link":"https://LiarrDev.github.io/post/Android-Gradle-Plugin-Dependency-Configurations/"},{"title":"『Android Studio』用 Gradle 实现自动签名","content":"当我们需要接入一些三方授权功能时，提供授权的平台往往需要校验我们 App 的合法性，而应用签名，就是校验应用是否合法的手段，国内像是 QQ 和微信提供的第三方登录能力，就是通过校验签名和包名来提供授权的。 在开发调试时，我们总是习惯于修改完代码后直接 Run 项目到设备上，因为打出一个 Release 包再签名这个步骤一旦重复操作，会降低我们的效率，但调试，又免不了频繁的运行。 既然无法避免，那我们能不能像平常 Debug 一样，一键把签名和 Run 都执行了呢？ 首先要明确，虽然平常 Debug 我们只需要点击工具栏的「Run」按钮，项目就会编译并运行到我们的设备上，但实际上它也是进行了签名操作的。 『Android Studio』默认为我们生成了一个用于调试的签名，目录为 ~/Users/&lt;User&gt;/.android/debug.keystore，这样即使我们不为项目配置任何签名，项目仍能够使用这个调试签名运行到设备中。 根据我们对应用签名的经验，除了签名文件，我们还需要另外三个参数，分别是 Key store password、Key alias 和 Key password。 当然，这个用于调试的签名文件也有。其中 Key store password 和 Key password 的值都为 android，Key alias 的值为 androiddebugkey。 下面，我就使用这个用于调试的签名，来实现自动签名的操作。 首先打开「Project Structure」，选择「Modules」中选择对应的 Module 配置签名，新建一个签名配置： 然后填写对应的参数： 确认后，『Android Studio』就会在对应 Module 的「build.gradle」文件中为我们生成签名信息： android { ... signingConfigs { release { storeFile file('/Users/liarr/.android/debug.keystore') storePassword 'android' keyAlias 'androiddebugkey' keyPassword 'android' } } } 这里我使用的是调试的签名，实际项目中一般不会配置此签名，所以相应的参数也不会一致。 最后我们还需配置： android { ... buildTypes { release { ... signingConfig signingConfigs.release } debug { ... signingConfig signingConfigs.release } } } 这样，当我们运行项目时，它就会通过 Gradle 配置对我们的应用签名了。 实际上，你完全可以手动在 Gradle 文件中输入以上代码进行配置而无需使用「Project Structure」。 配置完成后，你甚至可以直接使用 Gradle Task 来快速生成 Debug 和 Release 的安装包。 另外，假如我们的项目存储在代码托管平台或选择开源的话，将签名信息直接明文写在 Gradle 文件中并不是一个好主意，应当创建一个单独的属性文件来存储安全信息并在编译文件中引用该文件。 比如在项目的根目录下创建一个名为「keystore.properties」的文件。此文件应当包含您的签名信息： storePassword=android keyPassword=android keyAlias=androiddebugkey storeFile=/Users/liarr/.android/debug.keystore 然后在 Gradle 文件中配置： def keystorePropertiesFile = rootProject.file(&quot;keystore.properties&quot;) def keystoreProperties = new Properties() keystoreProperties.load(new FileInputStream(keystorePropertiesFile)) android { ... signingConfigs { config { keyAlias keystoreProperties['keyAlias'] keyPassword keystoreProperties['keyPassword'] storeFile file(keystoreProperties['storeFile']) storePassword keystoreProperties['storePassword'] } } buildTypes { release { ... signingConfig signingConfigs.config } debug { ... signingConfig signingConfigs.config } } } 不要忘了将签名信息加入忽略清单： # Ignore Signing Config /keystore.properties 这样我们的签名信息就更安全了。 参考内容 为应用签名 | Android 开发者 | Android Developers ","link":"https://LiarrDev.github.io/post/Auto-Signing-with-Gradle-in-Android-Studio/"},{"title":"一文带你简单了解 Hosts","content":"在日常上网中我经常需要跟 Hosts 打交道，比如访问部分海外网站，或者是在外面访问公司内网，又或者日常开发测试，都需要修改 Hosts。 不要觉得 Hosts 很高深，说不定你在平时的网上冲浪中也会接触到。 今天就来简单科普一下 Hosts，让小白也能够轻松了解它。 Hosts 是什么 Hosts 是一个没有扩展名的系统文件，其作用就是将一些常用的网址域名与其对应的 IP 地址建立一个关联数据库，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从 Hosts 文件中寻找对应的 IP 地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交 DNS 域名解析服务器进行 IP 地址的解析。 如果这段话讲得很懵逼，那我举个例子，比如说百度的 IP 是 14.215.177.38，这一串没有任何意义和规律的东西很难记对吧，所以百度就搞了一个域名叫 www.baidu.com，那么你在浏览器中只需要输入这个域名就能够访问到百度的首页。 但是实际上浏览器是通过 IP 地址才能找到该网站所在的服务器并进行访问的。在 Hosts 文件中没有添加这个映射的情况下，系统会先将这个域名告诉 DNS 域名解析服务器，然后等解析出 IP 后再进行访问；而如果在 Hosts 中添加了这个映射，那么就可以跳过解析 IP 这一步，因为它可以直接从 Hosts 中获取到 IP，因此访问速度就会变得快很多。 访问一些受限制的网站也是同理，DNS 域名解析服务器解析不到对应的 IP，所以你也就无法正常访问了。 可以说，操作系统的 Hosts 文件则是有着类似本地 DNS 服务器的作用，而且比网络上的 DNS 具有更高的优先级。 如果这样解释还是不明白，那我再打个比方： 有一个地点，域名就相当于这个地址，比如广州塔，挺好记的对吧，而 IP 就相当于经纬度，比如我告诉你东经 113.32°，北纬 23.11°，相信你是崩溃的，而 Hosts 的作用就是你有个小本本记录地址和经纬度的映射关系，那么只要我告诉你地址，你不需要再去用专业的工具查，而是马上打开你的小本本，然后就可以根据经纬度立刻在地图上找到定位，这就是效率。 而限制访问就相当于，存在一个军事基地，但是由于军事基地是保密的，所以你在地图上不一定能找到它，这时候 Hosts 的作用就是，有一个内部人员告诉你这个军事基地的经纬度，那你就记在了小本本上，下次你想找这个军事基地的时候，马上打开你的小本本，就有答案了。 Hosts 的作用 根据上述这样的特点，Hosts 文件可以应用在很多场景，包括但不限于以下几种： 加快域名解析 上面也提到，对于要经常访问的网站，我们可以通过在 Hosts 中配置域名和 IP 的映射关系，提高域名解析速度。由于有了映射关系，当我们输入域名计算机就能很快解析出 IP，而不用请求网络上的 DNS 服务器，同时也能绕过 DNS 污染与劫持。 方便局域网用户 在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设 DNS 服务器，访问这些服务器时，要输入难记的 IP 地址，这对不少人来说相当麻烦。 可以分别给这些服务器取个容易记住的名字，然后在 Hosts 中建立 IP 映射，这样以后访问的时候，只要输入这个服务器的名字就行了。 屏蔽网站 有很多网站不经过用户同意就将各种各样的插件安装到你的计算机中，其中有些说不定就是木马或病毒。对于这些网站我们可以利用 Hosts 把该网站的域名映射到错误的 IP 或本地计算机的 IP，这样就达到屏蔽访问的效果，同样也可以用于屏蔽不健康网站、屏蔽垃圾广告网址等。 虚拟域名 很多时候，网站建设者需要把软环境搭建好，再进行上传调试。但类似于邮件服务，则需要使用域名来辅助调试，这时就可以将本地 IP 地址与一个虚拟域名做地址指向，就可以达到要求的效果，且无需花费。 域名重定向 开发或测试应用时，利用 Hosts 将域名临时指向到测试服务器 IP，可以方便自己测试，同时又不影响他人和线上的应用。 总结 说了那么多，其实 Hosts 并不神秘，简单理解它就是个电脑本机的「IP 地址 ↔ 域名」的对应表，系统或任何软件都会优先先检查 Hosts 里面有没对应的配置，之后才会去查询网上的 DNS 服务器。 因此你可以利用 Hosts 做很多有趣、有用的事情。 当然，本文只是一个简单的科普，追根溯源其实还有很多东西并没有详细聊到，比如 DNS 等，有兴趣的朋友可以自行深挖。 ","link":"https://LiarrDev.github.io/post/A-Brief-Overview-of-Hosts/"},{"title":"Android 对 TextView 和 EditText 的 Drawable 监听点击","content":"之前在『Android 为 TextView 和 EditText 添加 ICON』一文中介绍了如何为 TextView 和 EditText 添加 Drawable 作为指示，使交互更加友好，开发更方便，但仍遗留了一个问题，我们能否监听该 Drawable 的点击事件？ 这是一个很常见的需求，比如在密码输入框中添加一个用于切换是否显示明文的按钮： 你当然可以使用 EditText 加 ImageButton 组合的方式，这不在本文的讨论范围内。 那么 TextView 或者是继承自 TextView 的 EditText 有没有提供监听 Drawable 点击事件的方法呢？ 很遗憾，并没有。 因此，我们需要自己去实现对应的点击逻辑。 如果你上网搜索对应的内容，介绍的文章真不少，你复制下来到自己的项目上运行，效果或许也的确能够达到你的预期，但我这里要泼个冷水，你拷贝的这份代码很可能是错的——这是我踩过的坑。 其实原理大家都懂，就是实现上可能会忽略一些细节。 我简单先说下原理： 假如我们能够测量出 Drawable 在控件内的区域，就可以对该区域内的触摸事件作监听，也就能够实现监听点击事件的效果。 而难点，恰好就在于如何测量出 Drawable 所在区域，这也是网上很多文章犯错的地方。 由几何知识可以知道，在二维平面中，只要确定了 2 个顶点的坐标，以这两个顶点分别向两坐标轴作垂线就可以绘制出一个矩形区域。需要明确的是，在 Android 中坐标点的计算和我们在数学上不太相同，Android 中坐标原点为左上角顶点，往右为 X 轴正方向，往下为 Y 轴正方向。 接下来只需画个图就能清楚明了。 以 DrawableLeft 为例： DrawableLeft 在 X 轴方向上的距离很容易计算，其左侧与 Y 轴的距离实际上就是该 View 的 PaddingLeft，其右侧与 Y 轴的距离就是 PaddingLeft 和该 Drawable 的宽度之和。 但 DrawableLeft 在 Y 轴方向上的距离要稍微复杂一些，因为它会受到 DrawableTop 以及文字区域高度的影响，所以我们不能够直接获取。 这里解释一下，DrawableTop 的影响应该很好理解，也很好处理；文字区域高度的影响，是指不包含 Drawable 的实际文字区域，当文字区域的高度高于 DrawableLeft 的高度时，我们如果不进行计算，获取到的高度可能会比实际上要高，这会造成我们测量出来的区域比实际区域要大。 计算的方法也不难，我们只需要获取到 DrawableLeft 中心在 Y 轴方向上的位置，再增减 Drawable 本身一半的高度，即可得到其上下边界到 X 轴的距离。 这样我们就把 DrawableLeft 所在区域计算出来了，同理 DrawableTop 也能够使用相同的方法计算。 接下来就是 DrawableRight： DrawableRight 右侧在 X 轴方向上的距离实际上就是该 View 的总宽度与 PaddingRight 之差，其左侧在 X 轴方向上的距离就是其右侧在 X 轴方向的距离与该 Drawable 的宽度之差。 DrawableRight 在 Y 轴方向上的距离与 DrawableLeft 的计算方式无异，不再赘述。 用同样的方法，我们也能够计算出 DrawableBottom 的区域。 原理介绍完了，就该上代码了，为了更好的封装，我们可以自定义 View 来实现，以 TextView 为例： public class DrawableTextView extends AppCompatTextView { final int DRAWABLE_LEFT = 0; final int DRAWABLE_TOP = 1; final int DRAWABLE_RIGHT = 2; final int DRAWABLE_BOTTOM = 3; Drawable mDrawableLeft, mDrawableTop, mDrawableRight, mDrawableBottom; public DrawableTextView(@NonNull Context context) { super(context); } public DrawableTextView(@NonNull Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public DrawableTextView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override public boolean onTouchEvent(MotionEvent event) { if (event.getAction() == MotionEvent.ACTION_DOWN) { if (onDrawableClickListener != null) { mDrawableLeft = getCompoundDrawables()[DRAWABLE_LEFT]; mDrawableTop = getCompoundDrawables()[DRAWABLE_TOP]; mDrawableRight = getCompoundDrawables()[DRAWABLE_RIGHT]; mDrawableBottom = getCompoundDrawables()[DRAWABLE_BOTTOM]; if (touchDrawableLeft(event)) { onDrawableClickListener.onDrawableLeftClick(); } if (touchDrawableTop(event)) { onDrawableClickListener.onDrawableTopClick(); } if (touchDrawableRight(event)) { onDrawableClickListener.onDrawableRightClick(); } if (touchDrawableBottom(event)) { onDrawableClickListener.onDrawableBottomClick(); } } } return super.onTouchEvent(event); } private boolean touchDrawableLeft(MotionEvent event) { if (mDrawableLeft == null) { return false; } int drawableHeight = mDrawableLeft.getIntrinsicHeight(); int drawableWidth = mDrawableLeft.getIntrinsicWidth(); int topOfDrawable = getCompoundPaddingTop(); int bottomOfDrawable = getHeight() - getCompoundPaddingBottom(); double drawableCenterY = 0.5 * (bottomOfDrawable - topOfDrawable) + topOfDrawable; Rect bounds = new Rect(getPaddingLeft(), (int) (drawableCenterY - 0.5 * drawableHeight), getPaddingLeft() + drawableWidth, (int) (drawableCenterY + 0.5 * drawableHeight) ); return bounds.contains((int) event.getX(), (int) event.getY()); } private boolean touchDrawableTop(MotionEvent event) { if (mDrawableTop == null) { return false; } int drawableHeight = mDrawableTop.getIntrinsicHeight(); int drawableWidth = mDrawableTop.getIntrinsicWidth(); int leftOfDrawable = getCompoundPaddingLeft(); int rightOfDrawable = getWidth() - getCompoundPaddingRight(); double drawableCenterX = 0.5 * (rightOfDrawable - leftOfDrawable) + leftOfDrawable; Rect bounds = new Rect((int) (drawableCenterX - 0.5 * drawableWidth), getPaddingTop(), (int) (drawableCenterX + 0.5 * drawableWidth), getPaddingTop() + drawableHeight); return bounds.contains((int) event.getX(), (int) event.getY()); } private boolean touchDrawableRight(MotionEvent event) { if (mDrawableRight == null) { return false; } int drawableHeight = mDrawableRight.getIntrinsicHeight(); int drawableWidth = mDrawableRight.getIntrinsicWidth(); int topOfDrawable = getCompoundPaddingTop(); int bottomOfDrawable = getHeight() - getCompoundPaddingBottom(); double drawableCenterY = 0.5 * (bottomOfDrawable - topOfDrawable) + topOfDrawable; Rect bounds = new Rect(getWidth() - getPaddingRight() - drawableWidth, (int) (drawableCenterY - 0.5 * drawableHeight), getWidth() - getPaddingRight(), (int) (drawableCenterY + 0.5 * drawableHeight)); return bounds.contains((int) event.getX(), (int) event.getY()); } private boolean touchDrawableBottom(MotionEvent event) { if (mDrawableBottom == null) { return false; } int drawHeight = mDrawableBottom.getIntrinsicHeight(); int drawWidth = mDrawableBottom.getIntrinsicWidth(); int leftOfDrawable = getCompoundPaddingLeft(); int rightOfDrawable = getWidth() - getCompoundPaddingRight(); double drawableCenterX = 0.5 * (rightOfDrawable - leftOfDrawable) + leftOfDrawable; Rect bounds = new Rect((int) (drawableCenterX - 0.5 * drawWidth), getHeight() - getPaddingBottom() - drawHeight, (int) (drawableCenterX + 0.5 * drawWidth), getHeight() - getPaddingBottom()); return bounds.contains((int) event.getX(), (int) event.getY()); } public interface OnDrawableClickListener { void onDrawableLeftClick(); void onDrawableTopClick(); void onDrawableRightClick(); void onDrawableBottomClick(); } private OnDrawableClickListener onDrawableClickListener; public void setOnDrawableClickListener(OnDrawableClickListener listener) { this.onDrawableClickListener = listener; } } 代码不短，但我们理解了上面的原理之后也很容易看懂。 我在这里定义了一个 OnDrawableClickListener 接口，用于分别回调 TextView 四个方向上的点击事件。 重点内容在重写的 onTouchEvent() 方法内，这个方法用于监听 TextView 的触摸事件。在该方法内，首先通过 getCompoundDrawables() 方法获取到 Drawable 数组，并通过下标分别拿到四个方向上的 Drawable 对象。紧接着判断触摸事件是否落在对应的 Drawable 区域内，然后回调给 OnDrawableClickListener。 触摸区域的判断就根据上面原理写就可以了，解释下几个方法。 getIntrinsicWidth() 和 getIntrinsicHeight() 分别用于获取当前 Drawable 对象的宽高。 getCompoundPaddingLeft() 获取的则是 TextView 左边界到文字实际显示区域的距离，我们可以看下源码： /** * Returns the left padding of the view, plus space for the left Drawable if any. */ public int getCompoundPaddingLeft() { final Drawables dr = mDrawables; if (dr == null || dr.mShowing[Drawables.LEFT] == null) { return mPaddingLeft; } else { return mPaddingLeft + dr.mDrawablePadding + dr.mDrawableSizeLeft; } } 也就是说，当 DrawableLeft 不存在时，它取得的值是 PaddingLeft，而当 DrawableLeft 存在时，它取得的值是 PaddingLeft、DrawableLeft 的宽度、DrawablePadding 三者之和。其他方向也同理。 回到刚刚还没解释的问题，当我们知道了文字显示区域距离坐标轴的距离时，Drawable 的中心点也就可以计算出来了。 你可能会有疑问，『Android 为 TextView 和 EditText 添加 ICON』一文不是提到可以通过设置 Gravity 来指定内部元素的对齐方式，那会不会影响到 Drawable 位置的计算？ 并不会，因为 Gravity 实际上指定的是文字在文字区域内的显示位置，而不是 Drawable 的位置，即 Drawable 的位置相对于文字区域来说，依然是居中的，所以我们通过文字区域来计算 Drawable 的中心点仍旧可行。 最后，我们将 Drawable 所在的矩形区域计算出来，并判断触摸事件在该 View 上的落点是否在 Drawable 的矩形区域内，就能够判断该 Drawable 是否被点击。 这个自定义的控件写完后，只需替换原来的 TextView 即可，属性与原来无异。 对于继承自 TextView 的 EditText 也同理，使用上面的自定义方法同样适用。 我这里就使用自定义的 EditText 来写一下文章开头的密码显隐功能。 首先替换布局文件中原来的 EditText 控件： &lt;com.example.DrawableEditText android:id=&quot;@+id/password&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:drawableRight=&quot;@drawable/ic_eye_off&quot; android:inputType=&quot;textPassword&quot; /&gt; 在逻辑代码中响应其点击事件： private boolean passwordVisible = false; void switchPasswordVisibility(final DrawableEditText editText) { editText.setOnDrawableClickListener(new DrawableEditText.OnDrawableClickListener() { @Override public void onDrawableLeftClick() {} @Override public void onDrawableTopClick() {} @Override public void onDrawableRightClick() { Drawable drawable; if (passwordVisible) { drawable = getResources().getDrawable(R.drawable.ic_eye_off); // editText.setInputType(InputType.TYPE_TEXT_VARIATION_PASSWORD | InputType.TYPE_CLASS_TEXT); editText.setTransformationMethod(PasswordTransformationMethod.getInstance()); } else { drawable = getResources().getDrawable(R.drawable.ic_eye_on); // editText.setInputType(InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD); editText.setTransformationMethod(HideReturnsTransformationMethod.getInstance()); } passwordVisible = !passwordVisible; drawable.setBounds(0, 0, drawable.getMinimumWidth(), drawable.getMinimumHeight()); editText.setCompoundDrawables(null, null, drawable, null); } @Override public void onDrawableBottomClick() {} }); } 因为只设置了 DrawableRight，所以这里只需要写入 DrawableRight 的事件即可。 效果如下： 虽然我们在 EditText 的控件属性中常用 android:inputType 属性来设置其为密码的样式，但在这里并不建议使用 setInputType() 方法来作更改，而是使用 setTransformationMethod() 方法，主要是因为 setInputType() 方法有两个坑。 其一，密码从可见状态切回密文状态时，我们以在控件属性中使用的经验，一般会将其设置为： editText.setInputType(InputType.TYPE_TEXT_VARIATION_PASSWORD); 但是运行之后你会发现，并不会生效： 可以看我上方注释掉的代码中需要同时设置两个属性才能生效： editText.setInputType(InputType.TYPE_TEXT_VARIATION_PASSWORD | InputType.TYPE_CLASS_TEXT); 对应控件属性中的： &lt;EditText ... android:inputType=&quot;textPassword&quot; /&gt; 因为 textPassword 对应的 InputType 的值为 129，而 InputType.TYPE_TEXT_VARIATION_PASSWORD 对应的值是 128，所以很明显需要和值为 1 的 InputType.TYPE_CLASS_TEXT 做按位或运算。 其二，使用 setInputType() 方法转换后会出现样式不一的情况： 可以见到，当切换为密文状态时，点和点之间的距离增大了，与默认样式不统一，会造成用户困扰。 而使用 setTransformationMethod() 就可以避免上面的情况。 ","link":"https://LiarrDev.github.io/post/Listening-Clicks-on-Drawables-of-TextView-or-EditText/"},{"title":"Android 为 TextView 或 EditText 添加 ICON","content":"在应用开发中，为了友好的用户体验，我们常常需要在文字旁边添加 ICON，因为用户对图形的感知往往要强于文字，比如这样子： 大多数新手看一眼觉得很简单，使用 ImageView 和 TextView 组合即可。 的确，这是一种很简单的方法，但如上图中使用 GridLayout 来展示多个子项，明明 ICON 和文字属于同一项，组合写法会导致代码成倍增加，再加上需要用一个父容器（如 LinearLayout）来包裹这两个子项，布局文件就如老太太的裹脚布——又长又臭。 当然，你也可以把这个组合抽取出来，做成 Adapter 通用，尽管布局清晰了，但逻辑代码也增加不少。 实际上，Android 本身就为 TextView 提供了此功能，我们只需一行代码就可以使用： &lt;TextView ... android:drawableTop=&quot;@drawable/ic_drawable&quot; /&gt; 该属性可以为 TextView 在某一方向上添加对应的 Drawable，其他方向只需修改属性中的方向名称即可。 AppCompat 提供了一些 Compat 属性，所以你也可以这样写： &lt;TextView ... app:drawableTopCompat=&quot;@drawable/ic_drawable&quot; /&gt; 如果你想调整 Drawable 和文字的间隔，可以使用这个属性： &lt;TextView ... android:drawablePadding=&quot;16dp&quot; app:drawableTopCompat=&quot;@drawable/ic_drawable&quot; /&gt; 当 Drawable 尺寸过大时，你可能会注意到 Drawable 和文字并不是居中的，这时你要牢记，这个 Drawable 也是 TextView 的一部分： 对于 View 或 ViewGroup 内部元素的对齐方式，我们通常可以使用： &lt;TextView ... android:gravity=&quot;center&quot; app:drawableTopCompat=&quot;@drawable/ic_drawable&quot; /&gt; 假如你需要在逻辑代码中动态修改该 Drawable，同样提供支持： textView.setCompoundDrawablesWithIntrinsicBounds(getResources().getDrawable(R.drawable.ic_drawable), null, null, null); setCompoundDrawablesWithIntrinsicBounds() 方法接收四个参数，分别是四个方向上的 Drawable 资源，在对应方向传入所需的 Drawable 即可。 该方法同时也支持以资源 ID 的方式传入 Drawable，所以也可以这样写： textView.setCompoundDrawablesWithIntrinsicBounds(R.drawable.ic_drawable, 0, 0, 0); 当你觉得这个功能挺好用时，假如美工让你调整一下 Drawable 的大小，你可能一下子就懵了，似乎找不到这个属性，还不如 ImageView 和 TextView 组合来得方便呀。 的确，在布局文件中没有调整 Drawable 尺寸的属性，但你要记得，这是一个 Drawable，既然是 Drawable，我们就可以通过逻辑代码控制它的尺寸： Drawable drawable = getResources().getDrawable(R.drawable.ic_account); drawable.setBounds(0, 0, 180, 180); // 设置图片的大小 textView.setCompoundDrawables(drawable, null, null, null); // 设置图片的位置 Drawable 的 setBounds() 方法接收四个参数，四个坐标形成一个矩形，Drawable 将在被绘制在这个矩形区域内。 接着调用的 setCompoundDrawables() 和上面提到的 setCompoundDrawablesWithIntrinsicBounds() 类似，将 Drawable 传入到对应位置即可。 另外我们知道，EditText 实际上是继承于 TextView 的，那么 EditText 也会有相同的属性，所以我们可以轻而易举的实现类似的功能： 属性和方法基本和 TextView 一致，不再重复贴代码。 ","link":"https://LiarrDev.github.io/post/Add-Icons-for-TextView-or-EditText-in-Android/"},{"title":"用『Hexo』搭建个人博客","content":"其实很多人都想过有一个属于自己的网站，无奈因为技术门槛，大多数人都没能实现这个小小的心愿。 说实话，对于技术人或者是互联网从业者来说，一个属于自己的个人网站是很常见的，由于我们通常会将其用于记录我们的一些笔记、知识、生活等等，因此也会将其称为博客。 “博客”这个词，说起来也有点儿久远了，甚至现在很多人都已经不知道这个词，它其实是一个音译词，英文叫“Blog”，而这个词也是一个混成词，源自“Web Log”，即网络日志，更早期的音译其实叫“部落格”，是一种通常由个人管理、不定期张贴新文章的网站。 国内也有很多博客写作平台，比如偏技术向的『CSDN』和『掘金』，偏大众向的『简书』等等，注册个账号就能开始写作，那为什么还要自己动手去搭建一个博客呢？ 从我个人看来，有三个原因： 广告。商业平台需要盈利，广告是重要的来源，平台往往会向作者的博客插入广告而不需要经过作者的同意。 样式。商业平台通常对于所有的博客，都只会提供单一的页面展示样式，没有个性化定制。 监管。文章发表在商业平台，就必须受到平台的监管。以微信公众平台为例，微信每年清理的微信文章不计其数，除掉绝大部分造谣、抄袭的垃圾文章外，还有极小部分揭露社会黑暗的文章因为某些不可描述的原因而被删除。 如果你也有同样的顾虑，可以尝试跟随我的脚步，搭建一个属于自己的个人博客。 Hexo 在开源社区各路大神的努力下，已经诞生了不少博客框架，我按照我个人的喜好，选择了『Hexo』，你也可以选择其他框架搭建。 『Hexo』官网对于这个框架的描述是： A fast, simple &amp; powerful blog framework 快速、简洁且高效的博客框架 同时，还介绍了几个优点： 超快速度。Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持 Markdown。Hexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署。只需一条指令即可部署到 GitHub Pages, Heroku 或其他平台。 插件和可扩展性。强大的 API 带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具（Babel，PostCSS，Less/Sass）轻易集成。 尽管我认同『Hexo』的确是一个优秀的博客框架，但在这里我必须要泼一下冷水： 网页的加载速度还依赖于实际网络情况。 不支持 Markdown 的博客框架算不上博客框架。 绝大多数的优秀博客框架都支持一键部署。 拥有插件扩展的博客框架才算优秀框架。 总之，『Hexo』满足了优秀博客框架的条件，接下来我就带你利用『Hexo』一步一步搭建自己的博客。 工具 Node.js 上面也提到，『Hexo』是基于 Node.js 的，它是一个基于 Chrome V8 引擎 的 JavaScript 运行时，不懂没有关系，你只需要下载安装即可。 其实 Node.js 在之前『Windows 平台 React Native 开发环境搭建笔记』中也有介绍过，如果感觉使用过程中网速不理想可以参考切换国内镜像源。 建议使用 LTS 版本。 Git Git 也是我们程序员的老朋友了，它可以帮助我们拉取相关文件以及将博客部署到网上去，也只需要下载安装即可。 新版本的 Git 已经默认勾选「Run Git from Windows Command Prompt」了，也就是说可以自动添加到环境变量。 macOS 中安装 Git 则更为方便，直接在『Terminal』中输入 git 命令就会自动提示安装。 环境 只需安装以上两个软件，我们就已经准备好工具啦，接下来在任意终端（你可以使用刚刚下载的『Git Bash』，或者系统自带的『CMD』、『Windows PowerShell』、『Terminal』等）输入以下命令： ➜ npm install -g hexo-cli 该命令会安装『Hexo』及其相关命令，等待一小会环境就安装完成啦。 建站 你可能会觉得前面的准备工作太过简单，或许这正是『Hexo』的优点，但接下来才是我们的重点工作。 『Hexo』环境安装完成后，我们在终端执行： ➜ hexo init &lt;folder&gt; &lt;folder&gt; 是我们想要将整个博客环境存放的目录路径，这个命令会加载对应的文件到该文件夹下，你可能会好奇这些文件是从哪里来的，『Hexo』的 Github 项目中有一个叫「hexo-starter」的 Repo，所有的包文件都在其中。 执行完上述命令之后很可能会有相关错误，比如无法安装相应的包扩展文件等，我们可以进入刚刚生成的该文件夹把没有安装上的包再安装一遍： ➜ cd &lt;folder&gt; ➜ npm install 这样就把所需要的包和文件安装完成，指定文件夹的目录结构如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 「_config.yml」是网站的配置信息，可以在此配置大部分的参数。 「package.json」是应用程序的信息，EJS、Stylus 和 Markdown renderer 皆已默认安装。 「scaffolds」是模版文件夹。当您新建文章时，『Hexo』会根据「scaffolds」来建立文件。『Hexo』的模板是指在新建的 Markdown 文件中默认填充的内容。 「source」是资源文件夹，存放用户资源的地方。除「_posts」文件夹之外，开头命名为 _（下划线）的文件、文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到「public」文件夹，而其他文件会被拷贝过去。 「themes」是主题文件夹，『Hexo』会根据主题来生成静态页面。 接下来就可以生成我们的网站页面了，在创建的项目文件夹根目录下，执行命令： ➜ hexo generate 因为单词比较长容易输错，『Hexo』支持用简写的方式执行命令，上面这条命令可以简写成： ➜ hexo g 如果你使用『Windows PowerShell』的话可能会遇到输出信息缺失的情况： 不用太担心，这只是『Hexo』命令显示不兼容『Windows PowerShell』的缘故，所以我还是比较习惯用『Git Bash』，不过『Git Bash』省略了比较多的信息，你也可以使用『CMD』，它会显示完整的信息。无论你使用哪个终端，只要它没有报错，我们的命令都是正常执行的。 该命令执行完成后，可以发现目录下多了一个名为「public」的文件夹，该目录就是生成的网站。 这时候再执行命令： ➜ hexo server 或者简写： ➜ hexo s 在浏览器中访问网址：http://localhost:4000，就可以查看刚刚生成的网站。 我们的网站就建立起来了！ 写作 虽然网站搭建好了，但里面除了一个「Hello World」还是空空如也，既然作为我们的个人博客，那么就需要用自己的内容来把它充实起来。 执行以下命令来创建一篇新文章： ➜ hexo new [layout] &lt;title&gt; 你可以在命令中指定文章的布局（layout），默认为 post，可通过修改「_config.yml」中的 default_layout 参数来指定默认布局。 post 相当于发布的文章，你也可以选择 draft 生成一个草稿，草稿页面不会被『Hexo』渲染生成但也可以预览其效果。 如果你担心命令太长太多你记不住，你可以把这个参数省略掉，记住如下写法即可： ➜ hexo new &quot;文章标题&quot; 执行完命令后你可以看到『Hexo』帮我们生成了一个与 &lt;title&gt; 名字相对应的 Markdown 文件，默认情况下 &lt;title&gt; 即文章的标题。 打开该文件，可以看到『Hexo』已经帮我们初始化了一些基本信息： --- title: &lt;title&gt; date: 2019-06-03 20:49:47 tags: --- 文件最上方以 --- 分隔的这一部分区域叫作「Front-matter」，用于指定个别文件的变量，简单来说就是这个文章的一些属性。 「Front-matter」通常使用 YAML 语法，当然你也可以使用 JSON 来编写，不过个人觉得虽然大部分程序员都比较熟悉 JSON 但在这里无疑使用 YAML 要更加方便易读，况且 YAML 学起来跟 JSON 一样无成本不是么。 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 「config.default_layout」中设置的默认值 title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 我一般还会使用 subtitle 指定副标题，使用 cover 指定文章封面图等，不过这并不是『Hexo』预先定义的参数，而是跟当前使用的主题相关，我使用这两个参数还是来源于在『微信公众平台』上写推文的习惯。 接下来只需要在「Front-matter」下方使用 Markdown 语法进行文章写作即可，任意文本编辑器都可以对其进行编辑，为了方便也可以使用专门的 Markdown 编辑器。 需要注意的是，『Hexo』中的 Markdown 语法使用的是 GFM（GitHub Flavored Markdown）而不是标准的 Markdown 语法，两者有点区别但总体区别不大，对于我日常使用来说，GFM 要相对严格一些（客观上来说并不是，因为 GFM 也有比标准 Markdown 自由的地方）。 写作完成后，再次运行上一小节生成网站以及启动服务器的两条命令： ➜ hexo g ➜ hexo s 访问 http://localhost:4000 即可查看刚刚生成的文章了。 这两条命令应当牢牢记住，因为在对博客做任何更新后都要用这两条命令来启动预览。 配置 对于新手其实只需要了解几个常用的配置项即可，但如果想要定制更加个性的网站，就需要了解如何玩转配置文件了。 首先，配置文件指的是「_config.yml」，它可以分为网站配置文件和主题配置文件，分别存放于项目根目录以及对应主题目录。 正如它的文件名后缀所示，配置文件也是遵循 YAML 语法的，同样，凡是支持 YAML 的地方都是可以使用 JSON 来替代。 最主要的配置有几个地方，第一是网站基础配置。 比如你打开网站后你可以看到网站的标题是「Hexo」： 我们的个人博客当然要自己起一个名字，所以可以修改： # Site title: &quot;Liarr's Studio&quot; subtitle: description: keywords: author: Liarr language: timezone: title 就是网站的标题，我这里把它命名为「Liarr's Studio」，意为我的工作台。重新生成并重启服务器，就可以看到网站的标题改为了我定义的名字了。 第二个需要修改的是部署的配置。 上文虽然你看到的是你生成的网站，但这也仅限于本地查看，他人还无法在公网上访问你的博客，所以你还需要把它部署到服务器上，具体部署的步骤下文会详细说，在配置这里需要填写你部署的方式以及地址，如我这里填写的是： # Deployment deploy: type: git repo: https://github.com/LiarrDev/LiarrDev.github.io.git 也就是说，我使用 Git 的方式来部署，并且存放在『Github』对应的仓库中。 第三个需要修改的是主题的配置。 你一定会认为默认的主题「Landscape」丑死了，我们可以通过修改主题来美化自己的网站，配置上只需要填写主题的名字即可，比如我这里填写： # Extensions theme: hexo-theme-clean-blog 就是使用这款名为「CleanBlog」的主题，具体设置主题的步骤下文也会有详细的介绍。 由于配置门槛较高，所以建议还是参考官方文档，官方文档上有更详细的介绍，且英文文档要比中文文档更加详细。 部署 『Hexo』支持多种部署方式，比如 Git、Heroku、Netlify、Rsync 等，这里主要介绍流行的 Git 部署方式。 正如前文所提到，我的博客是部署在『Github』上的，没错，我使用的正是 GitHub Pages，这是『Github』给开发者建立一个私人页面，用来分享新颖的想法和自己写的代码。 不过由于『Github』的服务器在海外，我们在国内访问有时候会不稳定，再加上时不时会遇上 DNS 污染，对于国内的非专业用户，我个人更加建议选用国内的代码托管平台，比如『Gitee』和『CODING』，部署流程和我在『Github』上部署基本没有太大差别。 注册的流程就不赘述了，直接讲部署流程。 首先得新建一个代码仓库，我们一般叫 Repo。 创建的信息必须得严格按照标准来填写。 首先是「Repository name」，也就是仓库的名称，使用 Github Pages 必须按照 &lt;Username&gt;.github.io 的方式填写，Username 一般跟左边的 Owner 是相同的，就是你注册的时候填写的用户名。由于我已经创建好我的个人网站了，所以这里它会提示该仓库已存在。 如果你使用其他代码托管平台则参照对应平台的命名规范，国内的代码托管平台一般都有中文文档，可以轻松参考。 其他内容可以根据自己的需要进行改动，比如「Description」是对这个仓库的描述，它是一个选填项，所以你可以在以后对它进行修改，比如我的仓库描述为： 可以让别人直接通过点击跳转至我的博客主页。 对于仓库的权限一般不修改，即默认的「Public」即可。 『Github』之前对于「Private」私人仓库是要收费的，被 Microsoft 收购之后个人也可以免费创建私有仓库了，并且数量无限制。设立私有仓库的目的主要是使代码仅为内部人员使用防止被竞争对手拿到核心代码，而我们搭建个人博客这种基于开源项目上的代码，也没必要设为私有。 创建完成后，打开仓库，点击「Clone」菜单的的复制按钮把仓库的地址复制下来。 填写到配置文件当中，如上文提到的部署配置所示。 # Deployment deploy: type: git repo: https://github.com/LiarrDev/LiarrDev.github.io.git 这样，『Hexo』就知道应该部署到哪个仓库中去了。 写作完成并在本地预览无误后，就可以通过命令部署到『GitHub Pages』中去： ➜ hexo deploy 也可以简写： ➜ hexo d 这条命令同样非常重要，当你本地预览网站觉得没有问题后，通过这条命令就能将网站部署到线上。 然后你就可以在公网上访问你的个人博客网站了。 地址为：https://&lt;Username&gt;.github.io。 如果你初次执行命令后有关于 Github 方面的报错，也可以尝试通过把仓库 Clone 下来并把里面的文件复制到你的 Hexo 博客项目目录下进行解决。 假若有时候修改内容后网站依旧无法正常展示，可以尝试通过清除缓存的命令来解决： ➜ hexo clean 清除缓存后再部署就能够看到修改后的效果，如果依然不行，有可能是其他地方的问题，可以参考文档或相关教程一一排查。 主题 默认的「Landscape」主题虽然比『CSDN』之类的广告流要好很多，甚至比很多国内你见到的博客都要好看，但依然无法满足我们对美观的追求，开源的『Hexo』有一个好处就是大家都可以为其打造主题。 截止至文章发表时，官网上登记的已经有 331 个主题，其他未被『Hexo』官方收录的主题应该也是不少的，所以你可以根据自己的喜好来选择合适的主题，当然，如果你能够自己制作一款主题供大家使用那就再好不过了。 打开『Hexo』官方的主题页，这里展示了各种各样的主题，可以花些时间慢慢挑选。 鼠标移动到主题的封面图上，会有一只小眼睛，点进去可以对不同主题的效果进行预览。 其实大多都是开发者的个人博客，也刚好看看效果和内容。 选到合适的主题后，回到官方的主题页，点击该主题的名字（我觉得这种交互方式十分不好，因为用户更加习惯点击图片，而且鼠标移动到名字时仅鼠标手势改变了，名字也没有进行高亮或者动效提示），就可以进入到该主题的项目主页。 接着把对应的主题 Clone 至博客项目的「themes」目录下即可。 然后再在项目配置文件中如上文所述载入主题。 # Extensions theme: hexo-theme-clean-blog 如我这里载入的就是名为「CleanBlog」的主题。 不同的主题也有不同的配置项，如这款「CleanBlog」主题我可以配置 Header： # Header menu: Home: / Archives: /archives Tags: /tags Categories: /categories Github: url: https://github.com/LiarrDev icon: github 首页的封面图我暂时还是使用其默认图片： # URL of the Home page image index_cover: http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg 上面可以看到，网站的 Favicon 默认是一个空白页的 ICON： 这样看起来就会觉得很 Low，你看看各大网站，哪个没有自己专属的 LOGO？ 那我们也应该给自己的网站设定一个 Favicon，为了方便，我就直接把我个人公众号的头像拿过来了，先把它转成 ICO 格式，然后再存放在该主题目录下的 /source/img/ 目录下，然后在主题配置中引入： # set your own favicon favicon: /img/favicon.ico 就可以把网站的 Favicon 改为我自己设计的 LOGO 了。 另外，「CleanBlog」这款主题还支持加上自己的社交账号，这里我仅设定我的 Github 账号： # Social Accounts twitter_url: twitter_handle: facebook_url: github_url: https://github.com/LiarrDev gitlab_url: linkedin_url: mailto: 我的博客最终成品大致如下： 其实每一款主题都有不同的参数配置，具体根据选定的主题进行配置即可。 至此，属于自己的个人博客就基本搭建完成了，有空也可以来我的技术博客中交流一下。 关于『Hexo』更详细的玩法可以参考官方文档。 在快餐式互联网时代，个人 Blog 实际上也越来越少见，大众娱乐化使得创作者更加愿意使用碎片化的记录方式，也几乎没有多少人愿意读长篇大论的文章，但无论是对写博客的作者，还是读博客的读者来说，都是一种沉淀。 参考内容 Hexo ","link":"https://LiarrDev.github.io/post/Build-a-Blog-with-Hexo/"},{"title":"NestedScrollView 解决 Android 嵌套滚动问题","content":"滚动是所有客户端都很常用的交互，毕竟屏幕就这么大，显示的内容往往非常多。 Android 开发中，新手常常会使用 ScrollView 来实现滚动的效果 —— Which is not wrong。 随着需求的增加，可能会需要做一个能滚动的列表，你马上就能反应过来，RecyclerView 或者 ListView —— Which is also correct。 需求再增加，需要做一个如同各电商平台一样，上半部分是某种固定形式的布局，下方是列表的可滚动的效果： 新手的直觉是：ScrollView 内嵌套 RecyclerView 或者 ListView —— Which might be able to work —— But definitely not right。 我用 ScrollView 和 RecyclerView 简单写一下上面这个布局： &lt;ScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!-- 网格布局 --&gt; &lt;GridLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:columnCount=&quot;3&quot; android:rowCount=&quot;2&quot;&gt; ... &lt;/GridLayout&gt; &lt;!-- 展示列表 --&gt; &lt;androidx.recyclerview.widget.RecyclerView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/LinearLayout&gt; &lt;/ScrollView&gt; 实际上会得到下面这种效果： 不难看出，RecyclerView 上方的网格布局在跟随 ScrollView 滚动，但 RecyclerView 却由于自身能够滚动的特性，只能在自己所处的位置滚动，而不能跟随 ScrollView 一起滚动。 这其实是一个滚动冲突的问题，解决办法也有很多，初学者遇到这个问题的时候往往是因为不知应如何描述问题而找不到答案。 其实关于 ScrollView 的 Android 官方文档中有专门提到这个问题： Never add a RecyclerView or ListView to a scroll view. Doing so results in poor user interface performance and a poor user experience. 同时，文档还提供了解决方案： For vertical scrolling, consider NestedScrollView instead of scroll view which offers greater user interface flexibility and support for the material design scrolling patterns. NestedScrollView 是 Android 提供的专门解决嵌套滚动的容器，「Nested」其实就是嵌套的意思，它的使用方式和 ScrollView 基本没什么差别，但它能够支持嵌套滚动的父 View 或子 View。 因此，我们只要简单替换，就可以解决上面的问题： &lt;androidx.core.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fillViewport=&quot;true&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;!-- 网格布局 --&gt; &lt;GridLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:columnCount=&quot;3&quot; android:rowCount=&quot;2&quot;&gt; ... &lt;/GridLayout&gt; &lt;!-- 展示列表 --&gt; &lt;androidx.recyclerview.widget.RecyclerView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/LinearLayout&gt; &lt;/androidx.core.widget.NestedScrollView&gt; 效果如下： 虽然本文使用 RecyclerView 作为讲解，但如同文档中所说，这种方法同时还支持解决 ListView 的嵌套滚动问题。 ","link":"https://LiarrDev.github.io/post/Solve-the-Android-Nested-Scrolling-Problem-with-NestedScrollView/"},{"title":"Java 去除 List 中的重复元素","content":"List 是我们在开发中常用的数据结构，是有序且可重复的集合，既然是可重复的集合，开发中我们也常常需要对其做去重操作，在 Java 中，我们可以使用多种方式完成 List 的去重。 遍历 List 删重 public static List&lt;?&gt; removeDuplicate(List&lt;?&gt; list) { for (int i = 0; i &lt; list.size() - 1; i++) { for (int j = list.size() - 1; j &gt; i; j--) { if (list.get(j).equals(list.get(i))) { list.remove(j); } } } return list; } 该方法通过循环 List 中的所有元素然后删除重复项达到去重。 遍历把未重复的元素存入另一个 List public static List&lt;?&gt; removeDuplicate(List&lt;?&gt; list) { List tempList = new ArrayList(); for (int i = 0; i &lt; list.size(); i++) { if (!tempList.contains(list.get(i))) { tempList.add(list.get(i)); } } return tempList; } 增加了另一个 List 来作存储，把原 List 的元素和新 List 的元素比较，如新 List 中没有该元素，则将该元素存入新 List。 通过 HashSet 剔除重复元素 public static List&lt;?&gt; removeDuplicate(List&lt;?&gt; list) { Set h = new HashSet(list); list.clear(); list.addAll(h); return list; } Set 是无序、不可重复的集合，正是其不允许重复元素的特点，通过 List 和 Set 互转，可以去掉重复元素。 保持顺序删除 ArrayList 中重复元素 public static List&lt;?&gt; removeDuplicateWithOrder(List&lt;?&gt; list) { Set&lt;Object&gt; set = new HashSet&lt;&gt;(); List tempList = new ArrayList&lt;&gt;(); for (Object element : list) { if (set.add(element)) tempList.add(element); } return tempList; } 虽然同样用到了 HashSet，但加入了逻辑使其保持顺序。 LinkedHashSet 高效去重 public static List&lt;?&gt; removeDuplicate(List&lt;?&gt; list) { Set set = new LinkedHashSet(list); list.clear(); list.addAll(set); return list; } 利用 LinkedHashSet 不能添加重复数据并能保证添加顺序的特性，该方法效率非常高。 Java 8 的 Stream 去重 public static List&lt;?&gt; removeDuplicate(List&lt;?&gt; list) { return list.stream().distinct().collect(Collectors.toList()); } Java 8 支持 Stream 流操作，因此集合去重可以简单地实现。 上面的部分代码我为了方便演示就直接在传入的 List 上做去重了，在实际使用中，应根据项目实际情况来判断，假如原 List 在去重后仍会继续使用，就应该创建一个新的 List 来存储去重后的元素，避免项目出现意想不到的 Bug。 另外，为了可复用性，我没有指定 List 的类型，而是使用泛型无界通配符 ?，在 IDE 中可能会报警告，按需修复即可。 ","link":"https://LiarrDev.github.io/post/Java-Remove-Duplicate-Objects-in-List/"},{"title":"Android 用 Dialog 轻松实现单选菜单","content":"移动应用的交互中常常会用到单选菜单，单选菜单的实现方式也有很多种，比如『WeChat』中就可以见到多种样式的单选菜单： 上面这两种样式，我没有去了解它的实际代码，单从交互来看，我猜应该是使用了 PopupWindow 和 BottomSheetDialog。 除了这两种方式，我们还可以使用更加简单的 Dialog 来实现。 用 Dialog 来做的话，很容易就想到了『Android 自定义 Dialog 布局』中引入自定义布局的方式，然后使用 RadioButton 或其他控件来做单选。 这种方式当然可以，但我们有更加简单的实现方式： public static void showMenuDialog(Context context, String[] options) { AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setItems(options, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { // Do Something... } }).show(); } AlertDialog.Builder 提供了 setItems() 方法来创建简单的列表对话框，从传入的字符串数组中获取各选项的名字，同时还需要传入响应事件，使用时我们可以根据数组的索引来绑定对应选项的点击事件。 当然，为了封装复用，我们应该将响应事件的逻辑交由函数的上层调用者来实现，所以可以封装成： public static void showMenuDialog(Context context, String[] options, DialogInterface.OnClickListener listener) { new AlertDialog.Builder(context) .setItems(options, listener) .show(); } 效果如下： ","link":"https://LiarrDev.github.io/post/Android-Build-an-Single-Selection-Menu-with-Dialog-Easily/"},{"title":"Android 不可编辑的 EditText","content":"项目中有时会需要用到一个不可编辑的 EditText，用于展示，很奇怪的需求对吧，明明就应该使用 TextView 来做展示，使用 EditText 来做输入，但现实就是可能为了 UI 统一，又或者是其他乱七八糟的原因，就得这么实现。 比如在之前的『PassBox』和『HacppleStore』，我就是这么干的。 那么在 Android 中应如何将 EditText 设置为不可编辑状态呢？ 我总结了几种方法： android:editable &lt;EditText ... android:editable=&quot;false&quot; /&gt; 效果如下： 可以看到，默认情况下，EditText 并没有获取到焦点，但点击 EditText 后，尽管焦点马上被激活，但输入法并没有弹出。 需要提醒的是，该属性已经被标记为 @Deprecated： &lt;!-- If set, specifies that this TextView has an input method. It will be a textual one unless it has otherwise been specified. For TextView, this is false by default. For EditText, it is true by default. {@deprecated Use inputType instead.} --&gt; &lt;attr name=&quot;editable&quot; format=&quot;boolean&quot; /&gt; 虽然上面提到使用 android:inputType 来代替，但我暂时没找到该属性的替代方法。 setKeyListener() 在逻辑中使用： editText.setKeyListener(false); 效果与 android:editable 相同，默认情况下没有获取到焦点，点击后焦点被激活，输入法没有弹出。 setKeyListener() 实际上是继承自 TextView 的一个方法，传入 null 即为禁止用户输入。 android:focusable / setFocusable() 在布局文件中： &lt;EditText ... android:focusable=&quot;false&quot; /&gt; 或使用逻辑控制： editText.setFocusable(false) // boolean editText.setFocusable(View.NOT_FOCUSABLE); // int 效果如下： 这其实是继承自 View 的一个属性，用于控制对应的 View 能否获取焦点。 可以看到，默认情况下，EditText 并没有获取到焦点，触摸时 EditText 获取到焦点，并在触摸结束后失去焦点，而通过长按可以将剪贴板的内容粘贴至 EditText 内。 需要注意的是，setFocusable() 做了方法重载，使用 int 类型参数则需要到 API 26 才支持。 android:focusableInTouchMode / setFocusableInTouchMode() 在布局文件中： &lt;EditText ... android:focusableInTouchMode=&quot;false&quot; /&gt; 或使用逻辑控制： editText.setFocusableInTouchMode(false); 该方法效果和 android:focusable 也一样，同样是继承自 View 的一个属性，用于控制对应的 View 在触摸时能否获取焦点。 android:enabled / setEnabled() 在布局文件中： &lt;EditText ... android:enabled=&quot;false&quot; /&gt; 或使用逻辑控制： editText.setEnabled(false); 效果如下： 编辑框完全失去焦点，即无法通过粘贴的方法修改输入内容，但是整个编辑框变成了暗色状态，不易于阅读。 android:longClickable / setLongClickable() 为了可以清晰显示，并且不可以通过粘贴的方式编辑，我们可以考虑引入一些其他的解决方法。 通过粘贴方式编辑，实际操作过程是通过长按 EditText 以弹出对应的操作浮窗，才得以完成粘贴操作，那么我们就可以禁用长按操作，来避免用户进行粘贴。 在布局中： &lt;EditText ... android:focusable=&quot;false&quot; android:longClickable=&quot;false&quot; /&gt; 或使用逻辑控制： editText.setFocusable(false); editText.setLongClickable(false); 效果如下： 可以看到，文字能够清晰显示，长按 EditText 时也无法呼出操作浮窗，使用 android:focusable 或 setFocusable() 来搭配使用，因此同时也具备了相同的缺点，就是触摸时 EditText 仍然会获取焦点，但因为已经禁用了长按，所以不会产生功能上的问题。 如果还是不想存在焦点效果，添加个背景即可。 自定义 EditText 没有什么效果是自定义 View 解决不了的。 public class NonEditableEditText extends AppCompatEditText { public NonEditableEditText(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean onTouchEvent(MotionEvent event) { return true; } } 其实不需要多复杂，只需要重写 onTouchEvent() 方法即可，这里涉及到 View 的事件分发机制，简单来说，返回 true 代表当前 View 已经完整地处理了该事件，且不希望上层 ViewGroup 其他回调方法再次处理。 我们只需要在布局中使用该自定义控件： &lt;com.custom.widget.NonEditableEditText ... /&gt; 效果如下： 可以看到，无论是点击还是长按，该自定义的 EditText 都不会获取焦点，因为它并不会对我们的触摸事件做任何处理。 ","link":"https://LiarrDev.github.io/post/Android-Non-Editable-EditText/"},{"title":"Android 利用 Glide 获取图片的实际尺寸","content":"最近有个群友提了一个挺有意思的问题，当使用 Glide 加载图片时，假如不设置 ImageView 的宽高，会出现显示不可控的情况。 什么意思呢？我们来复现一下他的情况。 这位群友为我们提供了一张表情包图片： 要不是我们是正儿八经的学术讨论群，可能这位群友已经被锤死了… 当然，这个表情包是使用一个 URL 提供的，实际上只是相当于模拟从后端获取图片时的场景，因为一般这种情况后端是不会特意将图片尺寸提供给我们的，其实你也可以将图片放在 Assets Folder 中，同样能够复现，但别放在 /res/drawable 或者 /res/mipmap 文件夹内，因为系统会根据屏幕分辨率对其进行缩放。 我先把这张图片下载下来，看一下它的实际尺寸： 可以看到这张图片的尺寸为 100 × 97 像素，并不大，我们在项目中实际加载看看。 首先随便写一个简单的布局用于加载这张图片： &lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;@android:color/background_dark&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;ImageView android:id=&quot;@+id/image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 因为『Android Studio』新建项目时默认就采用了约束布局，那我这里就不做修改了，让 ImageView 置于屏幕的中央，因为群友提到不设置宽高，所以这里宽高我都定为 wrap_content，另外由于表情包是白底的，所以我给了一个深色的背景以更好的看出其显示边界。 为了对比，我要采用两种加载方式，一种是原生 API 的加载，另一种就是 Glide。 原生加载方式不复杂，通过 URL 获取流并将其解码为 Bitmap 即可： public class MainActivity extends AppCompatActivity { String url = &quot;http://wx4.sinaimg.cn/bmiddle/b64da6adly1gjbwvv4es7j202s02p0sk.jpg&quot;; @Override protected void onCreate(Bundle savedInstanceState) { ... final ImageView imageView = findViewById(R.id.sticker); new Thread(() -&gt; { try { final Bitmap bitmap = BitmapFactory.decodeStream(new URL(url).openStream()); runOnUiThread(() -&gt; imageView.setImageBitmap(bitmap)); } catch (IOException e) { e.printStackTrace(); } }).start(); } } 需要注意的是由于我们是加载网络图片，尽管我们并没有显式的写出网络请求的代码，它实际上是做了网络请求的，所以我们不能在主线程中执行，而将图片加载到 ImageView 时是 UI 操作，又需要切回到主线程。 Glide 的加载方式更加简单，之前『一次实战爱上「Glide」』一文也做了详细的介绍，而且因为 Glide 内部已经帮我们做了处理，所以我们不再需要关心线程的问题了，一行代码搞定： public class MainActivity extends AppCompatActivity { String url = &quot;http://wx4.sinaimg.cn/bmiddle/b64da6adly1gjbwvv4es7j202s02p0sk.jpg&quot;; @Override protected void onCreate(Bundle savedInstanceState) { ... final ImageView imageView = findViewById(R.id.sticker); Glide.with(this).load(url).into(imageView); } } 结果的确如群友所说，Glide 加载的图片显示的并不是实际尺寸： 图片实际大小 Glide 加载出来的大小 我们监听一下 Glide 加载出来的尺寸： Glide.with(this) .asBitmap() .load(url) .listener(new RequestListener&lt;Bitmap&gt;() { @Override public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Bitmap&gt; target, boolean isFirstResource) { return false; } @Override public boolean onResourceReady(Bitmap resource, Object model, Target&lt;Bitmap&gt; target, DataSource dataSource, boolean isFirstResource) { int width = resource.getWidth(); int height = resource.getHeight(); Log.d(TAG, &quot;Width: &quot; + width); Log.d(TAG, &quot;Height: &quot; + height); return false; } }) .into(imageView); 好家伙，加载的尺寸为 2139 × 2075 像素，这明显不对劲呀。其实这并不是图片的尺寸大小，而是加载图片后的 ImageView 的大小，也就是图片显示时的大小。 那我们能否获取到图片的实际尺寸呢？ 当然可以。 Glide.with(this) .asBitmap() .load(url) .into(new SimpleTarget&lt;Bitmap&gt;() { @Override public void onResourceReady(@NonNull Bitmap resource, @Nullable Transition&lt;? super Bitmap&gt; transition) { int realWidth = resource.getWidth(); int realHeight = resource.getHeight(); Log.d(TAG, &quot;Real Width: &quot; + realWidth); Log.d(TAG, &quot;Real Height: &quot; + realHeight); } }); 这里获取到的尺寸就是实际的 100 × 97 像素了。 然后你可能会发现，这个获取实际尺寸的方法是在 into() 里面的，那没有把 ImageView 实例传进去，它不能够加载我们的图片啊。 其实我们只需要用回最原始的方法即可： Glide.with(this) .asBitmap() .load(url) .into(new SimpleTarget&lt;Bitmap&gt;() { @Override public void onResourceReady(@NonNull Bitmap resource, @Nullable Transition&lt;? super Bitmap&gt; transition) { imageView.setImageBitmap(resource); } }); 当然你不嫌麻烦的话也可以用 Glide 重新加载一遍： Glide.with(this) .asBitmap() .load(url) .into(new SimpleTarget&lt;Bitmap&gt;() { @Override public void onResourceReady(@NonNull Bitmap resource, @Nullable Transition&lt;? super Bitmap&gt; transition) { Glide.with(imageView) .load(resource) .override(resource.getWidth(), resource.getHeight()) .into(imageView); } }); 说实话这种应用场景我至今还没有遇到过，总感觉 ImageView 不确定尺寸的话很容易会产生屏幕适配问题。 但转念一想，在微信聊天界面的表情包似乎是可以根据图片尺寸显示的，应该存在一个阈值，当表情包的尺寸大于等于这个阈值时，按照这个阈值缩放显示，当表情包的尺寸小于这个阈值时，就按照实际大小显示。 由于上面的场景我们只处理了小图加载的问题，因此上面的方法不能够直接应用到项目中，否则加载大图的时候也会产生不可控，更甚的是大图还容易造成 OOM。 而另一种场景，一些 App 有省流模式的功能，可以只显示文字而不加载图片，但是其显示的占位图和实际图片的宽高是一致的，这种就不能使用上面的方法来处理了，因为使用了上面的方法就会去请求图片，也就达不到省流的目的，理论上应由后端将图片的尺寸返回，再由客户端生成占位图。 ","link":"https://LiarrDev.github.io/post/Get-the-Actual-Size-of-Image-with-Glide-in-Android/"},{"title":"Android 星级评分条","content":"项目中需要用到一个类似淘宝评论的星级评分条，既作为评价时的评分，也用于用户个人评分展示。 一想，这还不简单，从图标库中载入满星、半星和空星三个图标，设计判断逻辑，当获取分数的值时，点亮相应的星星数量，完成。 写完该逻辑后，却发现代码量十分巨大，虽说简单，但冗余。 查了文档发现，Android 早已内置了该功能，别再傻傻的判断分数了，你可以使用 RatingBar 或 AppCompatRatingBar 简单便捷地实现相同的功能。 基本用法 AppCompatRatingBar 继承自 RatingBar，而 RatingBar 继承自 AbsSeekBar，AbsSeekBar 又继承自 ProgressBar，也就是说它同样有 ProgressBar 的相关属性。 下面我使用 AppCompatRatingBar 进行演示。 看看相关属性： android:isIndicator：是否用作指示，默认为 false android:numStars：星星总数，整型，默认为 5 android:rating：默认评分值，浮点型，默认为 0 android:stepSize：评分每次增加的值，浮点型，默认为 0.5 五星评分条就可以做成如下的效果： 不难看出用作指示的星星条点击无法修改其数值。 其还内置了几种常用的 Style 供你选择，如偏小些的： &lt;androidx.appcompat.widget.AppCompatRatingBar ... style=&quot;?attr/ratingBarStyleIndicator&quot; /&gt; 如其名，该 Style 适用于展示。 还有更小的： &lt;androidx.appcompat.widget.AppCompatRatingBar ... style=&quot;?attr/ratingBarStyleSmall&quot; /&gt; 默认使用最大的： &lt;androidx.appcompat.widget.AppCompatRatingBar ... style=&quot;?attr/ratingBarStyle&quot; /&gt; 三种 Style 比较如下： 自定义 Style 如果不想使用默认的星星，其也支持自定义。 这里需要用到 layer-list，简单解释一下，layer 是层，list 是列表，那么 layer-list 就是层列表的意思，原理是图层一层层的叠加，后添加的会覆盖先添加的，也就是可以将多个 Drawable 按照顺序层叠在一起显示，所以 layer-list 实际上也是个 Drawable 资源。 先找来两个笑脸素材： 在「drawable」文件夹下创建「ratingbar_layerlist.xml」文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@android:id/background&quot; android:drawable=&quot;@drawable/ic_rating_off&quot; /&gt; &lt;item android:id=&quot;@android:id/progress&quot; android:drawable=&quot;@drawable/ic_rating_on&quot; /&gt; &lt;/layer-list&gt; 这里需要设置为指定的 ID 名称，才可以实现 RatingBar 的效果。 紧接着在「values」文件夹下的「styles.xml」文件中增加自定义的 Style： &lt;resources&gt; ... &lt;style name=&quot;smileRatingBar&quot; parent=&quot;Widget.AppCompat.RatingBar&quot;&gt; &lt;item name=&quot;android:progressDrawable&quot;&gt;@drawable/ratingbar_layerlist&lt;/item&gt; &lt;item name=&quot;android:minHeight&quot;&gt;24dp&lt;/item&gt; &lt;item name=&quot;android:maxHeight&quot;&gt;24dp&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; 然后就可以在 AppCompatRatingBar 中使用了： &lt;androidx.appcompat.widget.AppCompatRatingBar ... style=&quot;@style/smileRatingBar&quot; /&gt; 效果如下： 监听 RatingBar 提供了一些方法让我们能够方便地监听状态。 比如监听其 rating 值的变化： ratingBar.setOnRatingBarChangeListener(new RatingBar.OnRatingBarChangeListener() { @Override public void onRatingChanged(RatingBar ratingBar, float rating, boolean fromUser) { Toast.makeText(MainActivity.this, &quot;Rating: &quot; + rating, Toast.LENGTH_LONG).show(); } }); 其实监听事件我一般使用得比较少，因为没有太多必要时刻监听其动态变化，比如评价的时候，我只需在用户提交的时候获取其最终的结果值即可： float rating = ratingBar.getRating(); 既然有 Get 方法，那同样也有 Set 方法，一般作为指示的时候使用： ratingBar.setRating(rating); 可以看到，所有关于分值的参数都是 float 类型，在开发过程中要注意不要弄错，避免不必要的麻烦。 ","link":"https://LiarrDev.github.io/post/Android-Rating-Bar/"},{"title":"Android 日期选择器","content":"项目需要实现预约功能，那么就需要获取用户预约的日期，让用户填写是不明智的选择，因为每个人的写法不一致，如有人喜欢写成“2019.01.01”，而有人喜欢写成“2019-01-01”，还有人喜欢写“2019 年 1 月 1 日”，这样混乱的格式存储在后台中会不方便检索。 那么使用日期选择器来统一格式无论是对用户还是对开发者而言都是更加友好的。 通常情况下我们会使用弹窗来展示日期选择器，我们利用 Android 中内置的控件就可以实现。 DatePicker DatePicker 实际上就是一个单纯的日期选择器控件，为了使用弹窗展示，我们需要自定义一个 Dialog 来实现，可参考『Android 自定义 Dialog 布局』。 在布局中加入 DatePicker： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:padding=&quot;8dp&quot;&gt; &lt;DatePicker android:id=&quot;@+id/date_picker&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/LinearLayout&gt; 再设计其响应逻辑： public static void showDatePicker(Context context) { final Calendar calendar = Calendar.getInstance(); View datePickerView = LayoutInflater.from(context).inflate(R.layout.date_picker_dialog, null); DatePicker datePicker = datePickerView.findViewById(R.id.date_picker); datePicker.setMinDate(calendar.getTimeInMillis()); datePicker.init(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH), calendar.get(Calendar.DAY_OF_MONTH), new DatePicker.OnDateChangedListener() { @Override public void onDateChanged(DatePicker view, int year, int monthOfYear, int dayOfMonth) { calendar.set(year, monthOfYear, dayOfMonth); SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); textView.setText(format.format(calendar.getTime())); // textView.setText(year + &quot;-&quot; + (monthOfYear + 1) + &quot;-&quot; + dayOfMonth); } }); final AlertDialog dialog = new AlertDialog.Builder(context).create(); dialog.setCanceledOnTouchOutside(false); dialog.setCancelable(false); dialog.setView(datePickerView); dialog.setButton(DialogInterface.BUTTON_POSITIVE, &quot;OK&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }); dialog.show(); } 载入自定义布局后，调用 DatePicker.setMinDate() 方法来设置最小可选择的日期，同理，调用 DatePicker.setMaxDate() 方法来设置最大可选择的日期，另外还有如 DatePicker.setFirstDayOfWeek() 设置每周的第一天等各种配置，需要的时候查查文档即可。 接着就是对 DatePicker 的初始化操作，DatePicker.init() 接收 4 个参数，分别是默认的年月日和 DatePicker 被修改时响应的事件，默认的年月日一般设定为当前时间，响应事件为了方便演示我就用 TextView 来展示这个日期，这里需要注意，建议使用 SimpleDateFormat 来格式化日期，因为月份的计数是从 0 开始的，所以如果直接使用的话要记得加 1。 DatePicker 虽然有单独的 setOnDateChangedListener() 方法，但其要求 API 26 才能够使用： if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { datePicker.setOnDateChangedListener(new DatePicker.OnDateChangedListener() { @Override public void onDateChanged(DatePicker view, int year, int monthOfYear, int dayOfMonth) { calendar.set(year, monthOfYear, dayOfMonth); SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); textView.setText(format.format(calendar.getTime())); } }); } 如果仅设定了响应事件而没有初始化默认日期，DatePicker 会把当前日期设为默认日期。 然后是关于 AlertDialog 的一些设置，我设置为不可以任何方式取消，并加入一个 PositiveButton 关闭这个 AlertDialog，原因是当用户点击日期的时候 DatePicker 就已响应，而当响应结束之后，没有任何提示告诉用户已经处理完该事件，除非用户点击返回或其他地方关闭该 AlertDialog，所以禁用取消以及使用该 PositiveButton 关闭 AlertDialog 是为了更加友好的交互，当然你也可以在用户点击日期后立即关闭，但我认为这样假如用户误触后的修正步骤变长了。 效果如下： 另外，使用 DatePicker 时建议先在需要用到的地方设定一个默认日期，一般也就是 DatePicker.init() 中设定的日期，因为 DatePicker 仅在日期改变时才会作出响应，如果用户打开 DatePicker 日期选择器后没有点击操作而是直接关闭日期选择器（因为有选择器上默认日期）时，响应事件内的逻辑将得不到执行，也就无法获取到选中的日期（即默认的日期）。如图： 除了默认的日历卡样式外，DatePicker 还提供了常见的滚轮样式： 只需在控件中加入两行属性代码即可： &lt;DatePicker ... android:calendarViewShown=&quot;false&quot; android:datePickerMode=&quot;spinner&quot; /&gt; 意思就是指定选择器样式为滚轮样式并隐藏日历卡，如果仅设置滚轮样式而不隐藏日历卡样式的话默认是会两个同时存在的： 一来没有必要，二来也太丑，特别在竖屏时控件就挤到变形，影响体验。 DatePickerDialog 再来看看 DatePickerDialog，望文生义，DatePickerDialog 就是一个包含了 DatePicker 的对话框，也就是说 Android 帮我们把上面的封装完成了，实际上 DatePickerDialog 在 API 24 才被加进来，使用它有一个好处，就是不需要写布局文件。 public static void showDatePickerDialog(Context context) { if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.N) { final Calendar calendar = Calendar.getInstance(); DatePickerDialog dialog = new DatePickerDialog(context); dialog.setOnDateSetListener(new DatePickerDialog.OnDateSetListener() { @Override public void onDateSet(DatePicker view, int year, int month, int dayOfMonth) { calendar.set(year, month, dayOfMonth); SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); textView.setText(format.format(calendar.getTime())); // textView.setText(year + &quot;-&quot; + (monthOfYear + 1) + &quot;-&quot; + dayOfMonth); } }); DatePicker datePicker = dialog.getDatePicker(); datePicker.setMinDate(calendar.getTimeInMillis()); dialog.show(); } } 与 DatePicker 不同，DatePickerDialog 有多个构造方法，可以不设定默认的日期，当不设定时，DatePickerDialog 会把当前时间设为默认日期。 且 DatePickerDialog 继承自 AlertDialog，所以会有 PositiveButton 和 NegativeButton，因此响应事件回调不再是 onDateChanged() 而是 onDateSet()，即用户点击 PositiveButton 时才会响应事件，把选中的日期回传，这样就不会遇到像 DatePicker 未点击所以获取不到日期的尴尬情况。 但 DatePickerDialog 比较不方便的是不能够直接设置最小可选日期，所以需要借助 DatePicker 来实现，通过 DatePickerDialog.getDatePicker() 就可以获得 DatePick 实例，再调用 DatePicker 的方法就可以进行相关的操作。 效果如下： DatePickerDialog 因为不需要布局文件来构建，所以没有像 DatePicker 一样可以切换为滚轮样式的选项。 最后需要提醒的是，由于兼容性问题原生的日期选择器在不同的 Android 版本中样式不一，在 Android 4.x、Android 5.x 以及 Android 6.0 以上的版本中有很大的出入： 而且原生的日期选择器本身可定制的 API 也较少，如果介意的话请慎用。 ","link":"https://LiarrDev.github.io/post/Android-Date-Picker/"},{"title":"Android 判断网络是否连通","content":"在 Android 开发中，如果涉及到网络请求，而网络未连通的情况下，应用就会崩溃闪退，在 DEBUG 的时候出现该情况还好，但如果在用户的手机中，用户就会认为是你的应用出 Bug 了。 另外还会有一种情况，有时候当手机显示网络连接成功时，并不一定表示可以真的上网，比如肯德基或者一些酒店的无线网络时常需要登录验证才能使用，又比如刚启动路由器时虽然手机上会显示连接到路由器但实际上路由器还未初始化完成所以未能上网，甚至是网络欠费了而你依然能够连接到路由器，都会出现上面的情况。 因此在进行网络通讯前，就需要确认网络是否真正联通。 PING 在 PC 上，我们可以通过 ping 命令来判断网络是否联通，PING 全称为 Packet Internet Groper，即因特网包探索器，可以将它作为网络诊断工具，ping 命令在 Windows、macOS 和 Linux 下都是可以直接使用的，那 Android 当然也不例外： public static boolean isNetPingUsable() { Runtime runtime = Runtime.getRuntime(); try { Process process = runtime.exec(&quot;ping -c 3 www.baidu.com&quot;); int ret = process.waitFor(); if (ret == 0) { return true; } else { return false; } } catch (Exception e) { e.printStackTrace(); } return false; } 使用 ping 命令可以获得不同网络状态下的结果，如下： 连通的移动数据网络下：0 需要网页认证的 Wi-Fi 下：1 Wi-Fi 打开但没有网络连接，数据也不可用的状态下：2 在不可用的 Wi-Fi 下：2 在可用的 Wi-Fi 下：0 所以只要判断结果为 0 即表示网络已连通。 但该方法有个致命的缺点，当网络未连通时，它可以马上返回 false，但是当网络连通时，它需要耗费约 10 秒的时间才能返回结果。『广东移动』的 Android App 早期版本在登录页面获取短信验证码的时候也出现过该情况，点击「获取验证码」按钮后会出现一个 ProgressDialog 等待约 10 秒后才进行获取请求，估计也是使用上面的这个方法。 NetworkCapabilities NetworkCapabilities 是 API 21 新增加的一个工具类，这类本身没有太多内容，主要是用来描述网络状态和传输类型，它提供了相应的方法用来判断当前网络是否可用，并且不会出现上方的耗时操作。代码如下： public static boolean isNetworkAvailable(Context context) { ConnectivityManager connectivity = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); if (connectivity != null) { NetworkInfo info = connectivity.getActiveNetworkInfo(); if (info != null &amp;&amp; info.isConnected()) { // 当前网络是连接的 return info.getState() == NetworkInfo.State.CONNECTED; // 当前所连接的网络可用 } } return false; } 这样，当网络未连通的情况下，就可以马上获得结果，配合 ProgressDialog 和 Toast 提醒可以使交互更加友好。 建议在封装网络请求工具时加入联网判断，以防止 App 因网络问题崩溃。当然，现在很多第三方网络框架也已经封装了联网判断，可以直接使用。 ","link":"https://LiarrDev.github.io/post/Determines-the-Network-is-Available-in-Android/"},{"title":"定制 Android 日志工具","content":"在 Android 开发或是其他任何程序开发中，日志对我们来说是一个非常重要的工具，伴随我们整个开发过程的利器，它可以帮助我们调试代码，了解程序逻辑，以更好的定位问题。 虽然 Android 中自带的日志工具功能已经能够满足我们的开发需要，但是作为客户端，用于调试的日志信息在项目正式上线后仍然会照常打印，不仅会降低程序的运行效率，而且还有可能将一些机密性的数据泄漏出去。 难道要一行一行地把所有打印日志的代码删除或者注释掉？显然这不是什么好点子，不仅费时费力，而且以后继续维护这个项目的时候可能还会需要这些日志。 因此最理想的情况是能够自由地控制日志的打印，当程序处于开发阶段时就让日志打印出来，当程序上线了之后就把日志屏蔽掉。 看起来好像是挺高级的功能，其实并不复杂，只需要对系统提供的日志工具做简单的封装即可。 public class LogUtil { private static final int VERBOSE = 1; private static final int DEBUG = 2; private static final int INFO = 3; private static final int WARN = 4; private static final int ERROR = 5; private static final int NOTHING = 6; private static final String TAG = &quot;TAG_NAME&quot;; private static int level = VERBOSE; public static void v(String msg) { v(TAG, msg); } public static void v(String tag, String msg) { if (level &lt;= VERBOSE) { Log.v(tag, msg); } } public static void d(String msg) { d(TAG, msg); } public static void d(String tag, String msg) { if (level &lt;= DEBUG) { Log.d(tag, msg); } } public static void i(String msg) { i(TAG, msg); } public static void i(String tag, String msg) { if (level &lt;= INFO) { Log.i(tag, msg); } } public static void w(String msg) { w(TAG, msg); } public static void w(String tag, String msg) { if (level &lt;= WARN) { Log.w(tag, msg); } } public static void e(String msg) { e(TAG, msg); } public static void e(String tag, String msg) { if (level &lt;= ERROR) { Log.e(tag, msg); } } } 可以看到，在 LogUtil 中先是定义了 VERBOSE、DEBUG、INFO、WARN、ERROR、NOTHING 这 6 个整型常量，并且它们对应的值都是递增的。然后又定义了一个静态变量 level，可以将它的值指定为上面 6 个常量中的任意一个。 接下来提供 5 个自定义的日志方法，在其内部分别调用原生的日志工具来打印日志，只不过在这些自定义的方法中都加入来一个判断，只有当 level 的值小于或等于对应日志级别值的时候，才会将日志打印出来。 同时，还对这 5 个自定义的日志方法做了方法重载，参数省略了 TAG，并用一个统一的 TAG 来代替，这样在调用的时候，就可以避免重复输入 TAG 的麻烦。 在使用该日志工具时我们只需修改 level 变量的值，就可以自由地控制日志的打印行为，比如让 level 等于 WARN 就可以只打印警告以上级别的日志，让 level 等于 NOTHING 就可以把所有日志都屏蔽掉。 使用这种方法之后，刚才所说的那个问题就不复存在了。只需要在开发阶段将 level 指定成 VERBOSE，当项目正式上线的时候将 level 指定成 NOTHING 即可。 ","link":"https://LiarrDev.github.io/post/Customize-a-Android-LogUtil/"},{"title":"Android 改变 TextView 内局部样式","content":"Android 开发中经常会有对 TextView 的局部文字样式做单独处理的需求，比如针对某些文字进行加粗或是改变颜色等等。 这种处理在 Web 开发中十分简单，HTML 的标签能够很方便的进行调整。但是在 Android 开发中，却要稍微麻烦一些，我们来看几种处理方式。 多 TextView 拼接 利用多个 TextView 拼接的方式，我们可以针对不同的 TextView 样式进行调整，这种方法似乎跟 HTML 标签有点类似，但实际上却相去甚远。 当你有多个不连续的文字需要使用同一种样式的时候，你就需要建立多个具有相同样式的 TextView，从而对同一个句子或段落形成割裂感。 另一方面，你甚至还需要处理好每一个 TextView 的 Padding 以及 Margin 边距属性以及适当的换行等，否则 UI 就会乱得惨不忍睹。 总体来说，多 TextView 拼接来处理同一段文字是非常不推荐的方法。 利用 HTML 标签设置样式 既然 HTML 在处理这种需求有极大的优势，那么我们能不能使用类似的处理方式呢？ Android SDK 中其实为我们提供了直接解析 HTML 的方法，所以只要将字符串包装成 HTML 代码即可实现局部样式修改，比如： TextView textView = findViewById(R.id.sign_up_link); textView.setText(Html.fromHtml(&quot;No account yet? &lt;font color='#FFFFFF'&gt;&lt;big&gt;Create one&lt;/big&gt;&lt;/font&gt;.&quot;)); 利用 Html.fromHtml() 方法可以将字符串解析成 HTML 样式，再像平时一样使用的 setText() 方法即可把文字加载到 TextView 中去。 效果如下： 可以看到，底部的那行小字对后半句做了加粗以及颜色调整。 利用 HTML 设置样式十分方便，解决了多 TextView 拼接的割裂感，但它依然存在问题。 你可以看到我的示例代码中使用了 &lt;big&gt; 标签来设置字体的大小，其实在常规的 HTML 代码中，我更加倾向于使用 &lt;font&gt; 标签的 size 属性来进行调整，因为可以减少标签嵌套。 但是我在这里使用 &lt;big&gt; 标签的原因是，Html.fromHtml() 方法无法解析 size 属性，我们可以看看源码： public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException { handleStartTag(localName, attributes); } private void handleStartTag(String tag, Attributes attributes) { if (...) { ... } else if (...) { ... } else if (tag.equalsIgnoreCase(&quot;font&quot;)) { startFont(mSpannableStringBuilder, attributes); } else if (...) { ... } } private void startFont(Editable text, Attributes attributes) { String color = attributes.getValue(&quot;&quot;, &quot;color&quot;); String face = attributes.getValue(&quot;&quot;, &quot;face&quot;); if (!TextUtils.isEmpty(color)) { int c = getHtmlColor(color); if (c != -1) { start(text, new Foreground(c | 0xFF000000)); } } if (!TextUtils.isEmpty(face)) { start(text, new Font(face)); } } 可以看到，对于 &lt;font&gt; 标签，只解析 color 和 face 两个属性，其他属性比如刚提到的 size 并没有进行解析，自然也就不可以通过其设置字体大小了。 这里仅仅拿了 &lt;font&gt; 标签进行举例，其他标签也有类似的情况，也就是说 Android 的 Html.fromHtml() 方法并没有办法对所有的 HTML 样式进行解析。 利用 SpannableString 设置样式 其实 Android SDK 也为我们提供了修改 TextView 局部样式的方法，利用 SpannableString 也可以实现类似的功能： SpannableString spannableString = new SpannableString(&quot;Hello World!&quot;); BackgroundColorSpan backgroundColorSpan = new BackgroundColorSpan(Color.RED); spannableString.setSpan(backgroundColorSpan, 0, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); TextView textView = findViewById(R.id.tv); textView.setText(spannableString); 这是 TextView 的 Span 样式类，首先在 SpannableString 对象中传入要显示的内容，调用 setSpan() 方法实现字符串各种风格的显示。 setSpan() 方法有 4 个参数。第一个参数表示格式，可以是前景色、背景色等，这里指定其背景色为红色；第二个参数是格式开始的 Index；第三个参数是格式结束的 Index；第四个参数是一个常量，有以下 4 个值： Spannable.SPAN_INCLUSIVE_EXCLUSIVE：前面包括，后面不包括。即在文本前插入新文本会应用该样式，而在文本后插入新文本不会应用该样式。 Spannable.SPAN_INCLUSIVE_INCLUSIVE：前面包括，后面包括。即在文本前插入新文本会应用该样式，在文本后插入新文本也会应用该样式。 Spannable.SPAN_EXCLUSIVE_EXCLUSIVE：前面不包括，后面不包括。即在文本前插入新文本不会应用该样式，在文本后插入新文本也不会应用该样式。 Spannable.SPAN_EXCLUSIVE_INCLUSIVE：前面不包括，后面包括。即在文本前插入新文本不会应用该样式，而在文本后插入新文本会应用该样式。 最后也是调用 TextView 的 setText() 方法把这个 SpannableString 对象设置进去，效果如下： 使用 SpannableString 不仅可以设置局部样式，还支持设置局部点击事件，这点比利用 HTML 标签设置样式更加灵活。 ","link":"https://LiarrDev.github.io/post/Change-the-Partial-Style-within-Android-TextView/"},{"title":"@任振铭 的 DownloadModel","content":"最近在做一个类似应用商店的项目，需要做大文件下载。 一开始我基于 OkHttp 和 AsyncTask 实现了一个下载器，并且爬取其他应用商店内的应用下载链接测试成功了，但是当接入到我们自己的后台时，却发现并不能下载成功，会出现下载到某一个不确定的进度后，网速骤降，下载停止，并等待一个超时的时间后，下载失败。OkHttp 抛出一个异常： W/System.err: java.net.ProtocolException: unexpected end of stream W/System.err: at okhttp3.internal.http1.Http1ExchangeCodec$FixedLengthSource.read(Http1ExchangeCodec.kt:371) W/System.err: at okhttp3.internal.connection.Exchange$ResponseBodySource.read(Exchange.kt:276) W/System.err: at okio.RealBufferedSource$inputStream$1.read(RealBufferedSource.kt:158) W/System.err: at java.io.InputStream.read(InputStream.java:101) W/System.err: at ... 这里看样子是 Okio 的异常，因为 OkHttp 底层网络连接是使用 Socket，连接成功后则通过 Okio 库与远程 Socket 建立了 I/O 连接。 我在国内的技术论坛上找了一圈，能尝试的方法都用遍了，依然不行，于是上『Github』和『Stack Overflow』寻求答案，发现这个问题依然没有个最终的解决方法，甚至『Github』的 OkHttp 和 Okio 项目下已经有数个这样的 Issue 了，但在以 PHP 为后台的项目中复现率较高，且很有可能是服务端的问题。 不信邪的我拿了其他测试机过来测试后发现，在华为手机上失败率极高，其他手机则基本正常，这样看来应该是 EMUI 对 ROM 做了魔改的问题了，但是，当我使用华为手机切换至数据流量进行下载时，下载却成功了，连接网速快的 Wi-Fi 也能下载成功，因为公司的网络有做限速处理，当下载到某一进度后，下载停止，等待一个超时的时间即下载失败。 我个人猜测是服务器有一个定时断开连接的设置，当到达这个时间点时，客户端与服务端的连接断开了，然后客户端继续等待，直至超时，抛出异常，而使用数据流量或者网速快的 Wi-Fi 时，由于下载时间短了，那么就相对没有这么容易到达断开连接的时间点，所以就能够下载成功。 于是去找我们的 PHP 大佬聊聊，大佬也没头绪，无奈，只能先更换我这边的下载方式了。重新调整了下载模块，改用 Android SDK 中的 DownloadManager，这就相当于把下载的实现交给了系统，我这边就不需要管这么多了。 测试发现该方式更加不稳定，经常下着下着用于显示进度的 Notification 就不见了，然后过一段时间后又弹出继续下载，我猜测这种情况可能跟我自己实现的类似，但是 DownloadManager 可能默认有断线重连的机制，所以就会出现这种情况。 尽管有了断线重连，不过 Notification 的消失对用户来说这并不是好的交互，最终放弃该方案，转而寻找网上开源的下载器方案。 Android 开源的下载器似乎并不多，我只知道 LAIX（流利说，没错，就是那个『英语流利说』App 的公司）开源的 OkDownload，OkDownload 的前身其实是 FileDownloader，至于改名 OkDownload，是跟 Square 叫板还是…… 但 OkDownload 对于我的项目似乎又太过笨重，于是我又开始寻找别的替代方案，无意中就发现了 @任振铭 的 DownloadModel。 不得不说的是，@任振铭 的 DownloadModel 的 README 文档真是太烂了，我使用的时候，已经更新到了 V1.0.5，但文档却还是基于 V1.0.2，而且还涉及到了 API 的变更，因此我不得不把源码扒下来才搞懂使用的方法。 先基于 V1.0.5 简单说一下用法吧。 首先在 Project 的「build.gradle」中配置 JitPack 仓库： allprojects { repositories { ... maven { url 'https://www.jitpack.io' } } } 然后在 Module 的「build.gradle」中添加依赖： dependencies { ... implementation 'com.github.renzhenming:DownloadModel:(insert latest version)' } 启动下载任务时： DownloadManager.getInstance(context).download(new DownloadInfo.Builder() .setDownloadUrl(url) .setUniqueKey(uniqueKey) .setName(name) .build()); 获取单例后调用 download() 方法进行下载，接收一个封装了下载信息的 DownloadInfo 参数，且会根据 DownloadInfo 中的 uniqueKey 来判断下载任务，由于库内有 MD5 的工具类，所以我一般将其设置为下载地址的 MD5 值。 如需暂停下载任务： DownloadManager.getInstance(context).pause(uniqueKey); 根据 uniqueKey 来暂停相应的下载任务即可。 除了我们封装的下载信息外，DownloadInfo 中还会包含一些下载时的其他信息，比如下载状态和下载进度等，我们也可以根据 uniqueKey 来获取： DownloadInfo downloadInfo = DownloadManager.getInstance(context).getDownloadInfo(uniqueKey); if (downloadInfo != null) { float progress = downloadInfo.getProgress(); int currentState = downloadInfo.getCurrentState(); ... } 最重要的，我们需要监听下载进度，就注册一个 Observer： DownloadManager.getInstance(context).registerObserver(new DownloadManager.DownloadObserver() { @Override public void onDownloadStateChanged(DownloadInfo info) { if (info.getDownloadUrl().equals(downloadUrl)) { ... } } }); 但是一般不会采取匿名类的方式，而是在最外层的类中 implements 这个 DownloadManager.DownloadObserver 接口： public class ClassName implements DownloadManager.DownloadObserver { ... @Override public void onDownloadStateChanged(DownloadInfo info) { if (info.getDownloadUrl().equals(downloadUrl)) { ... } } } 并在需要注册监听的位置调用： DownloadManager.getInstance(context).registerObserver(this); 这样我们如果需要移除监听，就可以直接调用： DownloadManager.getInstance(context).unregisterObserver(this); 下载的文件位置为 /内部存储/download_asset/ 目录下。 假如使用它来下载 Apk 文件，我们还可以使用其提供的 API 来跳转安装： DownloadManager.getInstance(context).install(context, uniqueKey); 跳转安装应用需要配置以下权限： &lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt; 为了适配 Android 7.0（Nougat，API Level 24）的应用间文件共享，还需要配置在「AndroidManifest.xml」中配置： &lt;application ...&gt; ... &lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; android:authorities=&quot;${applicationId}.download.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/filepath&quot; /&gt; &lt;/provider&gt; &lt;/application&gt; 并新建 /res/xml/filepath.xml 文件： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;paths&gt; &lt;external-path name=&quot;external_storage_root&quot; path=&quot;.&quot; /&gt; &lt;files-path name=&quot;.&quot; path=&quot;.&quot; /&gt; &lt;/paths&gt; &lt;/resources&gt; 但是目前项目还没有兼容 Android Q（Quince Tart，Android 10，API Level 29）的分区存储，所以我也给项目提了个 Issue（还是这个项目的第一个 Issue 呢），希望 @任振铭 后续会支持。 那么目前来说，我们可以通过如下方式兼容 Android Q 的分区存储： &lt;application ... android:requestLegacyExternalStorage=&quot;true&quot; tools:targetApi=&quot;q&quot;&gt; ... &lt;/application&gt; @任振铭 的 DownloadModel 的基本用法就是这些，其实支持的功能也是不少的： 多线程下载：有些大文件下载的需求中，单线程下载无法满足对效率的追求，此时想尽可能多的利用硬件资源提高下载速度，那可以选择开启 2 个线程或 3 个线程甚至 10 个线程（只要你内核足够）来下载这一个文件，虽然效率不能说成倍提高，但是作用还是很明显的。 多文件下载：使用者不需要关心这么多情况，只需把每个下载链接都丢给下载器即可，下载器会告知下载状态，使用者根据状态来更新界面显示即可，其他的一切交给下载器来处理。使用者也可以自定义线程池来管理每一个下载任务，设置下载器的产能，这些接口都通过 IThreadPool 接口开放出来，自主性很高。 断点下载：断点下载算是一个基本的功能了。下载过程中用户可能主动停止下载，也可能是系统原因导致下载被迫中断，但是这些也不需要开发者去关心，需要做的依然是丢一个链接进去，其他的不用考虑。 自定义下载路径：每个项目下载的存储路径都是不同的，所以必须将下载路径的设置接口开放给使用者，不然这就不能称之为一个通用的框架，IPath 接口已经提供了支持。 自定义缓存管理：下载过程中的状态信息需要保存起来，以备后边使用，比如从缓存中拿到上次的下载节点来更新当前的下载进度，ICache 把缓存的读取和写入的能力提供给使用者，只需要实现这个接口，来处理自己的逻辑即可，当然如果图省事，也可以直接使用我默认的缓存工具。 线程池管理：每个项目选用的线程池策略也是各有不同的，有的需要单线程顺序下载，有的需要多线程并列执行，所以作者把线程池的接口也开放出来，给使用者自定义的能力，就是上文提到的 IThreadPool 接口。 开放的网络接口：项目里网络请求是直接通过 HttpUrlConnection 实现的，使用者可能希望通过其他第三方的开源网络框架实现，那么就可以自定义一个类实现 IConnection 接口来实现自己的网络。 尽管上面已经做了介绍，但实际的使用我强烈建议参照 @任振铭 提供的 Demo，否则不一定能把这个框架使用得合理，尤其是在 RecyclerView 的列表中去下载，当然归根结底我认为是 API 的设计不够简单合理以及文档的不完善。 还需要提个醒，假如在项目中想使用 Notification 来显示进度的话，建议做一层过滤，可以参照我的代码： private void refreshNotification(float progress, int downloadState, String downloadUrl) { ... switch (downloadState) { case DownloadInfo.STATE_DOWNLOAD: if ((int) (progress * 100) &gt; mProgress) { mProgress = (int) (progress * 100); // 刷新 Notification 更新 Progress } break; ... } } 因为监听的进度更新极快，几毫秒就能收到一次进度的回调，进度精确到小数点后 7 位，当文件较大时，有可能几秒钟内进度的前两位小数基本不会有变化，而频繁的无用更新会导致整个 App 卡顿，所以我们可以做过滤，只有在前两位小数有变更时才去刷新 Notification。 想了解更多关于该库的实现可以前往其项目主页。 ","link":"https://LiarrDev.github.io/post/DownloadModel-Designed-by-renzhenming/"},{"title":"在 Android P 上使用 HttpClient","content":"在过去，Android 上发送 HTTP 请求一般有两种方式，一种是 HttpURLConnection，另一种是 HttpClient。 不过由于 HttpClient 存在 API 数量过多、扩展困难等特点，Android 团队越来越不建议我们使用这种方式，从 Android 2.3（Gingerbread，API Level 9）开始，效率更高的 HttpURLConnection 便成了主流，HttpURLConnection 可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。 终于在 Android M（Marshmallow，Android 6.0，API Level 23）中，HttpClient 的功能被完全移除，标志着此功能被正式弃用，所以现在 HttpURLConnection 便是 Android SDK 中你能见到的唯一网络请求 API。 而到了 Android P（Pie，Android 9，API Level 28），Android 官方再下重手，将 HttpClient 从 bootclasspath 中移除且默认情况下应用无法使用它。 但现实情况是，仍然有许多老项目依然在运行着 HttpClient，维护这些老项目的开发人员往往因为各种原因而没有对其进行重构，甚至无法对其进行重构，因此这台破旧的老爷车依然在吭呲吭呲地行驶着。 如果你尝试将使用 HttpClient 的老项目的 targetSdkVersion 指定到 28 或以上，那么你在进行网络请求时，很可能会遇到卡死的情况，项目会抛出类似如下异常： E/AndroidRuntime: FATAL EXCEPTION: main java.lang.RuntimeException: Unable to start activity ComponentInfo{&lt;packageName&gt;/&lt;classpath&gt;}: java.lang.RuntimeException: Stub! at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3782) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3961) at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:91) at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:149) at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:103) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2386) at android.os.Handler.dispatchMessage(Handler.java:107) at android.os.Looper.loop(Looper.java:213) at android.app.ActivityThread.main(ActivityThread.java:8178) at java.lang.reflect.Method.invoke(Native Method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:513) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1101) Caused by: java.lang.RuntimeException: Stub! at org.apache.http.conn.scheme.SchemeRegistry.&lt;init&gt;(SchemeRegistry.java:5) at ... 其实这个堆栈信息很具迷惑性，会让你误以为是逻辑问题、混淆错误、类库错用等等的问题，但实际上只是因为 Android P 将 HttpClient 从 bootclasspath 中移除所产生的错误罢了。 跟之前『Android P 解除 HTTP 明文通信限制』类似，Android 官方依然给我们留了后门，只需在 AndroidManifest.xml 添加以下内容即可： &lt;manifest ...&gt; &lt;application ...&gt; ... &lt;uses-library android:name=&quot;org.apache.http.legacy&quot; android:required=&quot;false&quot; /&gt; &lt;/application&gt; &lt;/manifest&gt; 接下来你就可以继续开着这台老爷车吭呲吭呲地上路了。 参考内容 Android 6.0 Changes | Android Developers Behavior changes: apps targeting API level 28+ | Android Developers ","link":"https://LiarrDev.github.io/post/Using-HttpClient-above-Android-P/"},{"title":"Android P 解除 HTTP 明文通信限制","content":"随着国内应用市场的逐步规范，上架各应用市场的要求也越来越高，就目前来看，国内应用市场平台上架普遍要求应用的 targetSdkVersion 不得低于 26，也算是紧跟『Google Play』（targetSdkVersion 不得低于 28）的步伐了。 当然，为了让用户有更加舒适的体验，我们开发应用的时候理应将 targetSdkVersion 设置得越高越好，尽管这意味着开发者将面临更加严格的权限管控和繁琐的适配。 其中就包括了 Android M（Marshmallow，Android 6.0，API Levle 23）的动态权限、Android O（Oreo，Android 8.0，API Level 26）的渠道通知等。 而在 Android P（Pie，Android 9，API Level 28）中，则对 HTTP 明文通信做出了限制。 Starting with Android 9 (API level 28), cleartext support is disabled by default. 从 Android 9（API Level 28）开始，系统默认情况下已停用明文支持。 如果你使用『OkHttp』进行明文的 HTTP 网络请求，会抛出如下异常： W/System.err: java.net.UnknownServiceException: CLEARTEXT communication to &lt;HOST&gt; not permitted by network security policy 触发源码如下： if (!Platform.get().isCleartextTrafficPermitted(host)) { throw new RouteException(new UnknownServiceException( &quot;CLEARTEXT communication to &quot; + host + &quot; not permitted by network security policy&quot;)); } 使用 Android 中标准 Java 接口 HttpURLConnection 来进行 HTTP 请求，也同样会抛出异常： W/System.err: java.io.IOException: Cleartext HTTP traffic to &lt;HOST&gt; not permitted 而使用 HTTPS 请求则不会出现问题。 Android P 之后系统限制了明文的网络请求，非加密请求会被系统禁止掉，也就是说如果当前应用的请求是 HTTP 请求而非 HTTPS，就会导系统禁止当前应用进行该请求。 既然是 Android P 的问题，也就是说只要指定了 targetSdkVersion 为 28，就必定会执行这段代码，那么我只要把其修改为低版本就可以避免了。 但是，在各大应用平台都在逐渐提高应用上架门槛的情况下，这必定不是长久之计，这与浏览器对 HTTPS 的要求是吻合的，不过在 Android 中我们依然可以通过一些简单的配置让应用支持 HTTP 请求。 最简单的方法，直接在 AndroidManifest 中设置明文开启： &lt;application ... android:usesCleartextTraffic=&quot;true&quot;&gt; ... &lt;/application&gt; 复杂一点儿的方法，设置单独的网络安全配置文件，需在「res」目录下新建一个「xml」文件夹，并在该文件夹中创建一个「network_security_config.xml」文件，内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot; /&gt; &lt;/network-security-config&gt; 然后在 AndroidManifest 中引用该网络安全配置文件： &lt;application ... android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&gt; ... &lt;/application&gt; 尽管这样看来使用单独的网络安全配置文件似乎有点儿繁琐，但有个好处是可以针对特定网域和特定应用配置自定义信任锚、配置用于调试的 CA 等，拥有更大的配置权限。 最后，还是建议督促下后端和运维人员赶紧上 HTTPS 吧。 参考内容： Network security configuration | Android Developers ","link":"https://LiarrDev.github.io/post/Remove-Cleartext-Restrictions-above-Android-P/"},{"title":"用脚本批量删除自己发过的微博","content":"事隔经年，今天终于“狠下心”给自己的微博账号解除账号异常限制了，然后心血来潮想清空之前发的所有微博，可是没想到当年年少无知，转发了一大堆乱七八糟的东西，微博已有千余条，手动一条条删除都不知道要删到猴年马月。 作为一个开发者我知道肯定是可以借助脚本来帮助我完成批量删除操作的，开搞。 当然，为了我的账号安全，不想使用第三方的工具，以避免因为授权所产生的信息泄漏。在手机上使用脚本又不够方便，幸好有网页版，浏览器可以很轻松地帮我执行脚本。 好了，大方向确定了，就开始找轮子了。 是的，你没看错，的确是「找」，而不是「造」，这种小问题肯定有无数人遇到过，何必自己动手呢？ 普遍看来，网上使用比较多的是如下代码： var s = document.createElement('script'); s.setAttribute( 'src', 'https://lib.sinaapp.com/js/jquery/2.0.3/jquery-2.0.3.min.js' ); s.onload = function() { setInterval(function() { if (!$('a[action-type=&quot;feed_list_delete&quot;]')) { $('a.next').click(); } else { $('a[action-type=&quot;feed_list_delete&quot;]')[0].click(); $('a[action-type=&quot;ok&quot;]')[0].click(); } // scroll bottom let auto load $('html, body').animate({ scrollTop: $(document).height() }, 'slow'); var len = $('div[action-type=&quot;feed_list_item&quot;]').length; if (len &lt; 5) { $('a[class=&quot;page next S_txt1 S_line1&quot;]')[0].click(); } }, 800); }; document.head.appendChild(s); 在浏览器中打开微博并登录，进入到个人主页的页面，打开浏览器的「开发者工具」并切换至「Console」的 Tab，把上方代码复制进去回车执行即可。 脚本执行过程中可能会遇到系统繁忙的弹窗，只要脚本还在执行中可以暂时不理会，待脚本执行结束时刷新页面即可。 该弹窗的原因是由于请求太过频繁导致的，其实脚本所做的工作就是模拟滚动点击等操作，每一次删除或者加载都是一次网络请求，由于脚本的速度远远快于人手操作的速度，在短时间内进行高频的请求就会触发微博的防御。 那如何判断脚本是否还在执行中呢，只要你看到页面有闪动就代表脚本还在执行，如果页面停止闪动了，且你的微博仍未删除完成，可以刷新一次页面再执行脚本，如此反复，直至微博完全删除为止。 实测下来，脚本执行一次最少可以删除三四十条微博内容，我估计应该是一页的微博数，最多的情况下，我没有测试到上限，但是几百条也是没有问题的，只是微博官方可能会有单日删除上限控制，网上有人说是 2000 条左右，我没有考证。 参考内容： 新浪微博如何批量删除以前发过的微博 ？ - 知乎 ","link":"https://LiarrDev.github.io/post/Delete-Weibos-with-a-Script/"},{"title":"Android 为 WebView 添加进度条","content":"之前『Android Toolbar 显示 WebView Title』等文章中提到现在很多 App 都使用内嵌网页的方式来提高迭代效率，而『WeChat』便是其一，最大的体现就是在公众号文章中，不过其使用的不是原生的 WebView，而是定制的腾讯 X5 内核 TBS。 其中比较有用的是，在加载网页时，上方会有一个进度条用于展示当前网页的加载进度： 这是一个很好的交互控件，能够让用户知晓当前的加载状态，来作出对应的操作。 那么原生 WebView 能否加上一个进度条呢？当然可以。 首先需要在「drawable」文件夹下创建一个进度条 ProgressBar 的背景样式，这里我把它命名为「progress_bar.xml」： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;item android:id=&quot;@android:id/background&quot;&gt; &lt;shape&gt; &lt;corners android:radius=&quot;2dp&quot; /&gt; &lt;gradient android:angle=&quot;270&quot; android:centerColor=&quot;#E3E3E3&quot; android:endColor=&quot;#E6E6E6&quot; android:startColor=&quot;#C8C8C8&quot; /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:id=&quot;@android:id/progress&quot;&gt; &lt;clip&gt; &lt;shape&gt; &lt;corners android:radius=&quot;2dp&quot; /&gt; &lt;gradient android:centerColor=&quot;#999999&quot; android:endColor=&quot;#999999&quot; android:startColor=&quot;#999999&quot; /&gt; &lt;/shape&gt; &lt;/clip&gt; &lt;/item&gt; &lt;/layer-list&gt; 在布局文件内加入 ProgressBar 控件： &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; /&gt; &lt;ProgressBar android:id=&quot;@+id/progress_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;3dp&quot; android:progressDrawable=&quot;@drawable/progress_bar&quot; android:visibility=&quot;gone&quot; style=&quot;?android:attr/progressBarStyleHorizontal&quot; /&gt; &lt;WebView android:id=&quot;@+id/web_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/LinearLayout&gt; ProgressBar 控件导入了刚才的背景样式，并指定了其 style。 最后写出其显示逻辑： ProgressBar progressBar = (ProgressBar) findViewById(R.id.progress_bar); WebView webView = (WebView) findViewById(R.id.web_view); webView.setWebChromeClient(new WebChromeClient() { @Override public void onProgressChanged(WebView view, int newProgress) { if (newProgress == 100) { progressBar.setVisibility(View.GONE); } else { progressBar.setVisibility(View.VISIBLE); progressBar.setProgress(newProgress); } } }); WebChromeClient 的 onProgressChanged() 方法会回调 WebView 的加载进度，我们在这里获取到进度值并设置到 ProgressBar 中去，并且在进度为 100% 也就是加载完成时消失，即可实现如同『WeChat』般加载网页的进度条效果了。 ","link":"https://LiarrDev.github.io/post/Progress-Bar-for-Android-WebView/"},{"title":"Android Activity 转场动画","content":"在 Android 开发中，Activity 的跳转是有默认的转场动画的，比如在国内的大多数 ROM 中，默认的 Activity 切换方式是从右往左进入，从左往右退出，这也是大多数 App 所使用的切换方式。 但是，当有时候原型设计出来之后，会发现这种方式并不那么合理，比如在『「ZXing」实现 Android 扫描二维码』一文中可以看到，我把扫描按钮放在了底部导航栏的中央，那么左右切换的方式就有些违和了，所以我改成了从底部向上弹入。 那么该如何实现这种切换的方式呢？ 编写动画文件 虽然这个 Demo 是用 React Native 写的，但是由于扫描二维码的功能是使用原生 Android，所以这也是原生 Android 的实现方式。 首先在「res」目录下新建一个文件夹「anim」，不难看出这是一个用于存放动画文件的文件夹，也就是「Animation」的缩写，在「anim」文件夹下新建 Animation Resource File，每一个动画都要匹配一个动画文件。 比如我想要一个 Activity 的入场动画，我可以新建一个名为「anim_activity_open.xml」的动画文件，然后再在该文件内指定动画的效果。 先来看从底部弹入 Activity 的实现： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;@android:integer/config_mediumAnimTime&quot; android:fromYDelta=&quot;100%p&quot; android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; android:toYDelta=&quot;0&quot; /&gt; &lt;/set&gt; 解释一下这几个属性的作用： android:duration：动画运行的时间，单位是毫秒。 android:fromYDelta：动画起始时，Y 坐标上的位置。 android:toYDelta：动画结束时，Y 坐标上的位置。 android:fromXDelta：动画起始时，X 坐标上的位置。 android:toYDelta：动画结束时，X 坐标上的位置。 android:interpolator：用来修饰动画效果，定义动画的变化率，可以使动画效果 accelerated（加速）、decelerated（减速）、repeated（重复）、bounced（弹跳）等。 不难理解，该动画实现的效果就是从 Y 轴 100%p 的位置开始，到 Y 轴 0 的位置结束，持续时间是 500 毫秒，并伴有加速效果。 解释一下轴，只需记住，以屏幕左上角为坐标原点，与之相连的两端屏幕则为坐标轴，往右是 X 轴，往下是 Y 轴。取值可以有多种写法： 数值（如 50）：表示 View 左上角坐标加上具体数值的像素。 百分数（如 50%）：表示在当前 View 左上角坐标加上 View 宽度的具体百分比。 父百分数（如 50%p）：表示在 View 左上角坐标加上父控件宽度的具体百分比。 同理，从底部退出： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;@android:integer/config_mediumAnimTime&quot; android:fromYDelta=&quot;0&quot; android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; android:toYDelta=&quot;100%p&quot; /&gt; &lt;/set&gt; 从右边进入： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;@android:integer/config_mediumAnimTime&quot; android:fromXDelta=&quot;100%p&quot; android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; android:toXDelta=&quot;0&quot; /&gt; &lt;/set&gt; 其他就不一一详述了，参照修改即可。 接下来就是调用，只需在启动和销毁 Activity 时调用相应的动画即可。 比如，在调用 startActivity() 启动新的 Activity 时在后面添加一句代码即可： startActivity(intent); overridePendingTransition(R.anim.anim_activity_open, 0); 其中，第一个参数是要启动的 Activity 的弹入动画，第二个参数是当前 Activity 的退出动画，当参数为 0 时表示无动画。 在 startActivityForResult() 中也是同理： startActivityForResult(intent, CODE); overridePendingTransition(R.anim.anim_activity_open, 0); 当销毁 Activity 时，则在重写的 finish() 方法中调用： @Override public void finish() { super.finish(); overridePendingTransition(0, R.anim.anim_activity_close); } 但是我在项目中偶尔会遇到退出 Activity 时短暂黑屏的情况，直至该 Activity 完全退出才会正常显示，比如我在上方设置了动画持续时长为 0.5 秒，那么就会有 0.5 秒的黑屏，这是很不好的体验。 而后我发现新建一个动画可以避免这种情况，于是就有了「anim_activity_stay.xml」这个动画文件，虽说是“动画”，但实际上如其名所述，是一个“不动画”： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:fromYDelta=&quot;0&quot; android:toYDelta=&quot;0&quot; android:duration=&quot;@android:integer/config_mediumAnimTime&quot; /&gt; &lt;/set&gt; 一目了然，起始位置与结束位置相同，即不产生移动。 在调用时，则使用： overridePendingTransition(R.anim.activity_stay, R.anim.activity_close); 这样就能够产生相同的效果。 对了，Android 本身也自带了一些切换 Activity 的动画文件，可以让你省下造轮子的时间，如从屏幕左边切入，可以直接调用： overridePendingTransition(android.R.anim.slide_in_left, android.R.anim.slide_out_right); 当然，官方自带的动画效果总是有限的，所以知道如何自定义也是十分重要的。 接下来看看还有哪些效果。 比如我们想实现 iOS 的缩放效果，进场动画可以这样写： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;&gt; &lt;scale android:duration=&quot;@android:integer/config_mediumAnimTime&quot; android:fromXScale=&quot;2.0&quot; android:fromYScale=&quot;2.0&quot; android:pivotX=&quot;50%p&quot; android:pivotY=&quot;50%p&quot; android:toXScale=&quot;1.0&quot; android:toYScale=&quot;1.0&quot; /&gt; &lt;/set&gt; &lt;scale&gt; 在这里就是用来实现缩放的，属性的作用如下： android:fromXScale：起始 X 尺寸比例。 android:fromYScale：起始 Y 尺寸比例。 android:pivotX：缩放起点 X 轴坐标。 android:pivotY：缩放起点 Y 轴坐标。 android:toXScale：最终 X 尺寸比例。 android:toYScale：最终 Y 尺寸比例。 再来写个退场动画： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@android:anim/decelerate_interpolator&quot; android:zAdjustment=&quot;top&quot;&gt; &lt;scale android:duration=&quot;@android:integer/config_mediumAnimTime&quot; android:fromXScale=&quot;1.0&quot; android:fromYScale=&quot;1.0&quot; android:pivotX=&quot;50%p&quot; android:pivotY=&quot;50%p&quot; android:toXScale=&quot;0.5&quot; android:toYScale=&quot;0.5&quot; /&gt; &lt;alpha android:duration=&quot;@android:integer/config_mediumAnimTime&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0&quot; /&gt; &lt;/set&gt; 相比进场动画，这里还增加了一个 &lt;alpha&gt; 标签，用于改变透明度，属性作用如下： android:fromAlpha：动画开始的透明度。 android:toAlpha：动画结束的透明度。 这两个属性的取值为 0.0 ~ 1.0，0.0 表示完全透明，1.0 表示保持原有状态不变。 最外层的 &lt;set&gt; 标签我还增加了一个属性： android:zAdjustment：允许在动画播放期间，调整播放内容在 Z 轴方向的顺序。 取值有三： normal（0）：正在播放的动画内容保持当前的 Z 轴顺序。 top（1）：在动画播放期间，强制把当前播放的内容放到其他内容的上面。 bottom（-1）：在动画播放期间，强制把当前播放的内容放到其他内容之下。 调用也是相同： overridePendingTransition(R.anim.anim_zoom_in, R.anim.anim_zoom_out); 效果如下： Android L 的过渡效果 上面的切换动画基本上可以满足日常中对 Activity 跳转的需求了，但是总体来说还是相对比较平淡，符合用户习惯，但不惊艳。 Android 5.0 之后，Material Design 为 Android 注入了更加炫酷的过渡，通过其可以实现更加优秀的动画效果。 Explode 首先在「res」目录下新建一个文件夹「transition」，然后建一个 Transition Resource File，如「explode.xml」： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;explode xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; /&gt; 太简单了就不多解释了，接下来在要启动的 Activity 中加入如下代码： @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_explode); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { Transition explode = TransitionInflater.from(this).inflateTransition(R.transition.explode); getWindow().setEnterTransition(explode); } } 用 Transition 类初始化动画文件后调用 Window 的 setEnterTransition() 方法设置进去即可。 启动 Activity 的方式稍微有点区别，如下： if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(activityContext).toBundle()); } else { startActivity(intent); } startActivity() 的第二参数是用 makeSceneTransitionAnimation() 方法创建的 ActivityOptions 转成的 Bundle 对象，且 makeSceneTransitionAnimation() 方法的参数必须为 Activity，不能是其他 Context。 另外，由于该过渡动画是从 API 21 引入的，所以如果项目的 minSdkVersion 小于 21 的话要加入上方的判断逻辑。 效果如下： Slide 使用方法相似，建一个 Transition Resource File，如「slide.xml」： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;slide xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; android:interpolator=&quot;@android:interpolator/decelerate_cubic&quot; android:slideEdge=&quot;end&quot;&gt; &lt;targets&gt; &lt;target android:excludeId=&quot;@android:id/statusBarBackground&quot; /&gt; &lt;/targets&gt; &lt;/slide&gt; 解释一下属性： android:interpolator：属性设置插值器，用来控制滑动速度。 android:slideEdge：滑动方向。有 4 个值： end：根据地区使用习惯不同，中国一般在右侧。 start：根据地区使用习惯不同，中国一般在左侧。 top：顶部。 bottom：底部。 默认情况下顶部的状态栏也会执行动画，可以使用 &lt;target&gt; 标签忽略，android:excludeId 属性的值就是忽略的控件的 ID，如果需要忽略多个 View，则在 &lt;targets&gt; 组内继续添加即可。 调用方法也相似，不贴代码了，直接看效果： Fade 使用方法相似，建一个 Transition Resource File，如「fade.xml」： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;fade xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; /&gt; 属性仅指定了动画持续时间，即用 1000 毫秒的时间把 View 从无到有，透明度从 0 到 1。 调用方法也相似，不贴代码了，直接看效果： Shared Element 该效果与前三种不同，可以在切换的时候指定元素过渡，使用这种切换动画，用户可能感觉不到开启了一个新的 Activity，可以说是我最喜欢的交互方案了，先来看效果吧： 实现方法与前三种不同，不需要创建 Transition resource file，只需为两个 Activity 需要共享动画的元素指定同一个 android:transitionName 即可。 如我为原 Activity 的头像指定为 profile，登录按钮指定为 button： &lt;ImageView android:id=&quot;@+id/profile&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@mipmap/ic_launcher_round&quot; android:transitionName=&quot;profile&quot; /&gt; &lt;Button android:id=&quot;@+id/login_btn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;LOGIN&quot; android:transitionName=&quot;button&quot; /&gt; 那么在需要启动的 Activity 中选择需要共享的元素，也指定为相同的名称： &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;256dp&quot; android:scaleType=&quot;centerCrop&quot; android:transitionName=&quot;profile&quot; /&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/edit&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|end&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@drawable/ic_edit&quot; android:transitionName=&quot;button&quot; /&gt; 然后在原 Activity 中作如下配置： ImageView profile = findViewById(R.id.profile);; Button loginBtn = findViewById(R.id.login_btn); loginBtn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Pair profilePair = new Pair&lt;&gt;(profile, ViewCompat.getTransitionName(profile)); Pair btnPair = new Pair&lt;&gt;(loginBtn, ViewCompat.getTransitionName(loginBtn)); ActivityOptionsCompat transitionActivityOptions = ActivityOptionsCompat.makeSceneTransitionAnimation(this, profilePair, btnPair); Intent intent = new Intent(MainActivity.this, SharedElementActivity.class); ActivityCompat.startActivity(this, intent, transitionActivityOptions.toBundle()); } }); 将需要共享的元素构建成 Pair 对象，使用 ViewCompat.getTransitionName() 方法获取我们在布局文件中设置的 android:transitionName 的值。要注意，必须导入 android.support.v4.util.Pair 而不是 android.util.Pair，否则会出现问题。 通过 ActivityOptionsCompat.makeSceneTransitionAnimation() 静态方法得到 ActivityOptionsCompat 对象，该方法的第二个参数是一个数组，可以传入多个 Pair 对象。 最后再调用 ActivityCompat.startActivity() 启动 Intent 指定的 Activity，就可以看到上面的效果。 ","link":"https://LiarrDev.github.io/post/Transition-and-Animation-of-Android-Activity/"},{"title":"从哪里能找到 Android 源码","content":"不知你们有没有注意到，我最近发布的关于 Android 的文章都开始涉及到在源码里面找问题了，比如不久前的『Toolbar NavigationIcon &amp; Title 迷之间距』和『Android CountDownTimer 实现倒计时』等。 由于 Android 是开源的，所以我们开发者可以了解到其系统内部的实现原理，以帮助我们更好的设计逻辑代码。 Android 源码集成的项目称为 Android Open Source Project，我们一般简称 AOSP。那么从哪能找到 Android 的源码呢？ 其中最简单的方法就是通过『Android Studio』中的跳转，按住 Ctrl 键（Windows）或 Command 键（macOS）然后移动鼠标到相应的类或方法中点击即可跳转。 这种方式比较适合用来查看属性类型的源码文件，比如在『Toolbar NavigationIcon &amp; Title 迷之间距』一文中的「values.xml」文件。 而逻辑实现的文件通常不会使用这种方式打开，因为通过这种方法打开的是「.class」文件，即通过字节码文件反编译出来的代码，会有一些逻辑的缺失，你需要点击『Android Studio』上方的「Download Sources」来下载完整的源码。 由于 Android 项目的庞大，所以很多时候我也会使用一些在线的网站来查看、阅读与下载，今天就来推荐几个我常用的查看 Android 源码的网站。 Android Open Source Project 官网：https://source.android.com 中文官网：https://source.android.google.cn 最官方的途径总是最权威，因此我比较建议在 Android Source 中获取源码以及文档，且 Google 还特意为中国开发者搭建了一个中文站点，照顾墙外的人。 AOSP Mirror · Github 地址：https://github.com/aosp-mirror 从 AOSP 官网中提供的信息我们可以知道，Android 的源码存储在 Google 的 Gerrit 服务器上，如果你懒得配置，可以在『Github』上寻找对应的镜像 Repo。 Android OS 在线源代码 地址：https://www.androidos.net.cn/sourcecode 由于 Github 和 Google 的不稳定性，有时候从国内的站点获取 Android 源码反而更方便，『Android社区』提供了 Android 系统所有版本源码的查看与下载，十分方便。 AndroidXRef 地址：http://androidxref.com 『AndroidXRef』在国内的访问速度也是挺快的，只不过网站整体比较简陋，且就目前来看，更新不及时，不知是维护者弃了还是单纯的佛系更新，但其搜索功能还是挺不错的。 Opersys AOSP Portal 地址：http://aosp.opersys.com 『Opersys AOSP Portal』提供了类似『AndroidXRef』的交叉索引功能，且更新比较及时，还可以查看更新日志，是『AndroidXRef』的一个很好的替代品。 Android Code Search 地址：https://cs.android.com Android 官方推出的开源代码搜索工具，除了搜索 AOSP 的代码之外，它同时提供了 CameraX、Jetpack Compose 等 AndroidX 库的源码搜索，功能强大，但目前墙外无法访问，相信以后会逐步开放。 Git repositories on Android 地址：https://android.googlesource.com Android 的 Git 仓库，包含了一些库的文档和代码，但由于无检索能力，仅适合阅读。 清华大学开源软件镜像站 地址：https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ 清华大学为我们提供的开源软件镜像，更新速度比较快，仅支持下载，操作跟官方类似。 其实，在线查看 Android 源码的网站远远不止这些，几乎每隔一段时间都有一批类似的网站诞生，也有一批类似的网站死去，因此官方的途径总是相对稳定，如果条件允许，建议还是官方网站来获取。 ","link":"https://LiarrDev.github.io/post/Where-to-Find-Android-Source-Code/"},{"title":"为 EMUI 10 制作字体包","content":"从 MIUI 切换到 EMUI 后，其实用起来感觉并没有特别顺手，不过也罢，毕竟万物基于 MIUI，造 ROM 发家的小米这看家本事也不是盖的。 即便如此，搞机这么多年，花点儿时间我还是能定制出一套适合自己的软件系统的。 今天来唠唠如何更换 EMUI 的字体。 这几年用小米的朋友应该知道，MIUI 内置了一套小米兰亭字体，说实话，尽管还有一点儿瑕疵，但我还是非常喜欢。中文字体其实我倒是没有特别感冒，倒是英文字体的圆润感，让我看起来十分舒服。 但是看看 EMUI 系统预置的字体，三个预置的字体其实都并不怎么样，而主题商店里的免费字体也少得可怜，付费字体也大都花里胡哨。 那我何不上传一套自己喜欢的字体呢？ 由于国内 ROM 越来越强大，从 Android 5.0 开始我也不怎么折腾系统主题美化了，在手机里找了一下，竟没发现可以上传字体的地方，不知是 EMUI 的问题还是所有 ROM 都这样，是我太落后了。 既然手机不能直接搞，那就怼上电脑开干吧。 看看系统的目录，找找主题相关的文件夹，不难定位到 本地/内部存储/Huawei/Themes，但是里面只有主题缓存文件夹，并没有其他内容。 奇怪了，搜一下字体文件的扩展名「.ttf」，可以发现在主题的缓存文件夹中有相关的文件。 看来是不能直接丢一个字体文件进来就完事的，要把字体封装主题才行。 由于我对中文字体没有太高要求，所以我可以只选用一款只有英文的字体，这样还可以达到减小体积的目的。正好，Google 在几年前发布的一款字体 Google Sans 也很符合我的胃口，不过没有适配中文。 首先参考主题文件夹，我们可以建立这样的文件夹目录： |-- GoogleSans.hwt |-- fonts | |-- DroidSansChinese.ttf | |-- pic_font_default.jpg |-- preview | |-- preview_fonts_0_50.png |-- description.xml |-- icons 解释一下，HWT 是 EMUI 主题文件，必须要使用这样的扩展名才可以被系统识别；「fonts」是字体文件夹，里面有一个 TTF 字体文件，还有一张字体封面图；「preview」是预览文件夹，里面有一张字体预览图；「description.xml」是关于这款主题的一些描述信息；「icons」是一个无扩展名压缩文件，用于规定桌面软件图标。 以上就是给 EMUI 添加一款字体的最小组成，它去除了完整主题文件中其他无关的文件，如壁纸或锁屏等。 下面，就教大家如何一步一步完成这个字体主题包。 首先新建一个文件夹，可以使用任何你喜欢的名字命名，为了易于识别，我使用该字体名字命名，即「GoogleSans」。 然后按照上面的目录结构，建立好文件夹「fonts」和「preview」，以及文本文件「description.xml」，至于「icons」，如果你没有特别的需要，从其他主题文件夹复制过来即可，因为我们在修改字体的时候其实用不上，但是缺少该文件的话主题也是无法正常使用的，所以我们需要从其他主题文件中复制过来占位。 接着，就是把你喜欢的字体文件命名为「DroidSansChinese.ttf」，并放置在「fonts」文件夹内，还要做一张封面图，我这里就秉承简单的理念，随便做了一张： 还有一张字体预览图，同样按照规范命名，放置在「preview」文件夹下，这张图主要用于预览字体效果的，我贪图方便，用手机的『Notepad』来做： 最后就是主题的描述文件，参考下面的修改即可： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;HwTheme&gt; &lt;title&gt;GoogleSans&lt;/title&gt; &lt;!-- 主题英文名字 --&gt; &lt;title-cn&gt;GoogleSans&lt;/title-cn&gt; &lt;!-- 主题中文名字 --&gt; &lt;author&gt;Liarr&lt;/author&gt; &lt;!-- 主题制作者名字 --&gt; &lt;designer&gt;Google&lt;/designer&gt; &lt;!-- 主题设计者名字 --&gt; &lt;screen&gt;FHD+&lt;/screen&gt; &lt;!-- 主题分辨率 --&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;!-- 主题版本号 --&gt; &lt;font&gt;GoogleSans&lt;/font&gt; &lt;!-- 字体英文名称 --&gt; &lt;font-cn&gt;GoogleSans&lt;/font-cn&gt; &lt;!-- 字体中文名称 --&gt; &lt;transition&gt;None&lt;/transition&gt; &lt;type&gt;font&lt;/type&gt; &lt;/HwTheme&gt; 这样，就完成了上面目录结构中所需的所有文件了，将这个主题文件夹打包为「GoogleSans.zip」压缩文件，然后修改文件扩展名，得到「GoogleSans.hwt」，大功告成。 将这个主题压缩包放置在 本地/内部存储/Huawei/Themes 目录下，打开手机的主题商店，就可以看到我们刚刚的字体已经导入成功。 封面和预览图都在相应的地方展示好，只要点击应用就可以在手机系统中全局使用这套字体了。 参考内容： [字体分享] 小米兰亭PRO 优化适配 - 华为P30系列应用资源 花粉俱乐部 华为EMUI系统hwt主题文件修改及制作超详细教程 - 荣耀10分享交流 花粉俱乐部 华为EMUI系统hwt主题文件修改及制作超详细新手教学 - 荣耀10分享交流 花粉俱乐部 ","link":"https://LiarrDev.github.io/post/Pack-a-Font-for-EMUI-10/"},{"title":"@唯夜 的『WaveView』控件","content":"收到美工的需求，想要在主页背景中加入水的元素。 水其实不算一个很好表达的事物，因为静态的水比较难呈现，所以我们打算使用波纹来表示流动的水。 本着不自己造轮子（实际上是自己对 Canvas 的理解还不够透彻）以及敏捷开发的原则，上『GitHub』薅一个吧。 『GitHub』上这类型的开源控件并不少，一般都叫 WaveView，名字很贴切，对比了几个，还是决定选一个比较简单的 —— 由国内开发者 @唯夜（Github ID: @onlynight）开发的 WaveView 控件。 先来看看他提供的 Demo 效果： 首先在 Project 的「build.gradle」中添加远程仓库： allprojects { repositories { ... maven { url 'https://jitpack.io' } } } 然后在 Module 的「build.gradle」中添加依赖： dependencies { ... implementation 'com.github.onlynight:WaveView:(insert latest version)' } 这样就将 WaveView 引入到项目中了，接下来在布局文件中添加此控件： &lt;com.github.onlynight.waveview.WaveView android:id=&quot;@+id/wave_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;240dp&quot; app:isCircle=&quot;false&quot; app:period=&quot;1&quot; app:waveHeightPercent=&quot;0.9&quot; app:waveRange=&quot;15dp&quot; app:waveSpeed=&quot;4&quot; app:wave1Color=&quot;@color/waveBackColor&quot; app:wave2Color=&quot;@color/waveFrontColor&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; /&gt; 说一下其专有属性： &lt;declare-styleable name=&quot;WaveView&quot;&gt; &lt;!-- define wave speed, example value 10 --&gt; &lt;!-- 定义波速，类型为 Float --&gt; &lt;attr name=&quot;waveSpeed&quot; format=&quot;float&quot; /&gt; &lt;!-- define wave range, example value 15dp --&gt; &lt;!-- 定义波动范围，类型为 Dimension --&gt; &lt;attr name=&quot;waveRange&quot; format=&quot;dimension|reference&quot; /&gt; &lt;!-- define wave 1 color --&gt; &lt;!-- 定义背景波纹颜色，类型是 Color --&gt; &lt;attr name=&quot;wave1Color&quot; format=&quot;color|reference&quot; /&gt; &lt;!-- define wave 2 color --&gt; &lt;!-- 定义前景波纹颜色，类型是 Color --&gt; &lt;attr name=&quot;wave2Color&quot; format=&quot;color|reference&quot; /&gt; &lt;!-- define wave height percent, the value is between 0 to 1 --&gt; &lt;!-- 定义波高百分比，类型是 Float，取值范围为 0～1 --&gt; &lt;attr name=&quot;waveHeightPercent&quot; format=&quot;float&quot; /&gt; &lt;!-- define paint stroke width, if you want optimizing view, you should change the stroke width more --&gt; &lt;!-- 定义绘画笔划宽度，如果要优化视图，则应更改画笔宽度，类型为 Dimension --&gt; &lt;attr name=&quot;waveStrokeWidth&quot; format=&quot;dimension|reference&quot; /&gt; &lt;!-- if the view is circle --&gt; &lt;!-- 视图是否为圆形 --&gt; &lt;attr name=&quot;isCircle&quot; format=&quot;boolean&quot; /&gt; &lt;!-- the sine wave period, value range 0 to all --&gt; &lt;!-- 正弦波周期，类型是 Float，取值范围为 0～∞ --&gt; &lt;attr name=&quot;period&quot; format=&quot;float&quot; /&gt; &lt;/declare-styleable&gt; 可以看到我上方的代码只选取了其中一部分属性进行设置。 最后我们还需在 Activity 中启动动画： WaveView waveView = (WaveView) findViewById(R.id.wave_view); // When you want start wave you should call this method. waveView.start(); // When you want stop wave you should call this method. waveView.stop(); 尽管很多时候我们并没有必要停止波纹动画但它还是提供了相应的方法。 最后来看看我做的效果图： 不难看出控件的绘制并不这么平滑，我猜想应该使用的是矩形绘制，于是截了个图放大一看，果然如此。 其实数学几何和素描几何中也经常使用此方法进行绘制。 比如微积分中，使用容易计算的矩形面积来代替不规则图形的面积，而当矩形的宽足够小并趋近于零的时候，矩形代替的面积也就越趋近于不规则图形的面积了。 在立体几何素描中我们都不会使用圆规作圆，而是通过切圆法，即先画出一个矩形，再通过取半径中点切圆的方法逐渐把圆切出来，当切的次数越多，该多边形也就越接近于圆。 可以从 WaveView 的源码中看一下其实现的原理。 我们视觉上看到的是水波纹，实际上只是一个正弦波和余弦波向左位移，然后将三角函数的周期加长，在一个 View 中不显示整个三角函数的波形，这样从视觉上来说就实现了水波纹效果。 根据上面的分析，我们知道需要计算一个正弦波和一个余弦波，并且根据时间的推移将正弦波或者余弦波向左或者向右平移，最后每次计算完波形图的时候绘制下来就完成了。 来看下 WaveView 中的关键代码： private void drawWave(Canvas canvas, int width, int height) { setPaint(); double lineX = 0; double lineY1 = 0; double lineY2 = 0; for (int i = 0; i &lt; width; i += mStrokeWidth) { lineX = i; if (mIsRunning) { lineY1 = mWaveRange * Math.sin((mAngle + i) * Math.PI / 180 / mPeriod) + height * (1 - mWaveHeightPercent); lineY2 = mWaveRange * Math.cos((mAngle + i) * Math.PI / 180 / mPeriod) + height * (1 - mWaveHeightPercent); } else { lineY1 = 0; lineY2 = 0; } canvas.drawLine((int) lineX, (int) lineY1, (int) lineX + 1, height, mWavePaint1); canvas.drawLine((int) lineX, (int) lineY2, (int) lineX + 1, height, mWavePaint2); } } 可以看到，这里没有选择 Path 进行绘制，因为 @唯夜 认为 Path 绘制无法满足需求，所以通过画竖线，计算每个点起始的位置，然后从这个点画一条线到 View 的底部，然后循环多次直到 View 的边界处结束绘制，这样就看到正弦波了。这时候在每次绘制过程中给三角函数添加一个偏移量，每次计算的时候波形就会偏移，就完成了波纹。 这也就解释上方的矩形填充理论了，可以通过修改 waveStrokeWidth 属性来使其更平滑，我使用时发现大概使用 1dp 左右比较合适，同时也发现一个问题，当修改后虽然曲线更加平滑，但会出现少许卡顿的现象，这个平衡还是需要开发者自己来找。 顺便再说一个作者开发时遇到的一个坑，从上方的 Demo 图知道其可设置为圆形；常规的思路是画完以后再将其切成一个圆形，作者尝试了各种方法证明这种思路有问题。 最后发现需要先限定 Canvas 的绘制区域，然后再将图形绘制到 View 上去，这样才能实现效果。 @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); if (mIsRunning) { int height = getHeight(); int width = getWidth(); // 注意这里的执行顺序 clipContainer(canvas, width, height); drawWave(canvas, width, height); } } private void clipContainer(Canvas canvas, int width, int height) { if (mIsCircle) { mContainerPath.reset(); canvas.clipPath(mContainerPath); mContainerPath.addCircle(width / 2, height / 2, width / 2, Path.Direction.CCW); canvas.clipPath(mContainerPath, Region.Op.REPLACE); } } 其实看完源码之后发现实现该功能也不是特别复杂，但前提还是得搞懂自定义 View 的基本原理。 该控件的项目主页可 👉戳这里👈 跳转。 ","link":"https://LiarrDev.github.io/post/Waveview-Designed-by-onlynight/"},{"title":"Android Toolbar 显示 WebView Title","content":"因为所谓的敏捷开发，现在很多 App 都内嵌了网页，以此来满足快速迭代以及跨平台的需求，甚至大型 App 如『QQ』、『淘宝』、『支付宝』等等，除了最基础的功能外，大多数都交由网页来实现。 我们知道，在 Android 中想要加载网页，只需要嵌入 WebView 控件就可以了，但通常情况下，我们不会使 WebView 占满屏幕的整个空间，顶部还会加入一个 Toolbar 来与用户交互。比如，我们可以打开「开发者选项」中的「显示布局边界」功能来看看『QQ』的「会员中心」页面： Toolbar 在这里一般有两个作用，一是提供操作功能，比如左侧的回退按钮，以及右边的 Menu 菜单，可以在不占用界面太多空间的情况下为用户提供交互；二是展示 Title，让用户知晓当前页面的意义。 但是平时我们使用 Title 时大多数情况都是根据原生页面设置，即为每一个 Activity 或 Fragment 设定一个 Title，即我们在开发中知道每一个页面对应的 Title 是什么。 而如果使用 WebView 的话，就存在了不确定性，因为 WebView 所加载的页面往往不是由我们自己开发，而且跳转也会更加随意，所以我们不能够直接确定 Title。 不过不要慌，如果你写过 HTML 你就知道，HTML 中也是有一个叫 &lt;title&gt; 的标签的： &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; ... &lt;/html&gt; 如果你没有写过 HTML，那么你打开网站的时候也会在浏览器的标签中见到相应的名字： 我们打开网页的源码，就可以看到定义这个名字的地方： 既然如此，我们就可以通过 WebView 获取所加载的网页设置的 &lt;title&gt; 并将其配置到 Toolbar 中去。 方法一：在 WebViewClient 内获取 webView.setWebViewClient(new WebViewClient() { @Override public void onPageFinished(WebView view, String url) { super.onPageFinished(view, url); String title = view.getTitle(); if (!TextUtils.isEmpty(title)) { toolbar.setTitle(title); } } }); 我们知道 onPageFinished() 在网页加载完成的时候会调用，该方法中有两个参数，其中一个就是 WebView 实例，通过它的 getTitle() 方法即可获取到网页的 &lt;title&gt;，把它设置到 Toolbar 的 Title 中即可。 当然你也发现了其他几个接口如 shouldOverrideUrlLoading() 中也有 WebView 参数，那能否在其中使用上面的方式获取呢？理论上是可以的，但不建议，shouldOverrideUrlLoading() 的主要作用是给 WebView 提供时机，让其选择是否对 Url 进行拦截，如果拦截了就不加载对应的 Url 了，因此我们应该在网页加载完成后再获取。 方法二：在 WebChromeClient 内获取： webView.setWebChromeClient(new WebChromeClient() { @Override public void onReceivedTitle(WebView view, String title) { if (!TextUtils.isEmpty(title)) { toolbar.setTitle(title); } } }); WebChromeClient 内则提供了更加直截了当的接口 onReceivedTitle()，从函数命名就可以知道这个方法就是专门为了获取 &lt;title&gt; 而生的，直接设置到 Toolbar 中就可以。 ","link":"https://LiarrDev.github.io/post/Show-Webview-Title-at-Android-Toolbar/"},{"title":"Toolbar NavigationIcon & Title 迷之间距","content":"整理了一下之前的项目，发现一个关于 Toolbar 的问题，Toolbar 中的 NavigationIcon 与 Title 的距离似乎有点过大： 网上查了一下发现是从 Support 包 V23.0.0 之后才出现这种情况，而我的这个项目使用的是 V28.0.0 的包，看来这个问题历史悠久啊。 打开 Toolbar 的源码： public class Toolbar extends ViewGroup { private RtlSpacingHelper mContentInsets; // 对应的属性名称为 contentInsetStart private int mContentInsetStartWithNavigation; // 对应的属性名称为 contentInsetStartWithNavigation ... @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { final boolean isRtl = getLayoutDirection() == LAYOUT_DIRECTION_RTL; final int paddingLeft = getPaddingLeft(); // 获取系统的偏移量 int left = paddingLeft; ... // 计算 Navigation 的 Layout if (shouldLayout(mNavButtonView)) { if (isRtl) { ... } else { left = layoutChildLeft(mNavButtonView, left, collapsingMargins, alignmentHeight); } } ... final int contentInsetLeft = getCurrentContentInsetLeft(); left = Math.max(left, contentInsetLeft); ... if (layoutTitle || layoutSubtitle) { ... if (isRtl) { ... } else { ... int titleLeft = left; if (layoutTitle) { ... mTitleTextView.layout(titleLeft, titleTop, titleRight, titleBottom); } ... } } ... } ... private int layoutChildLeft(View child, int left, int[] collapsingMargins, int alignmentHeight) { final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int l = lp.leftMargin - collapsingMargins[0]; left += Math.max(0, l); collapsingMargins[0] = Math.max(0, -l); final int top = getChildTop(child, alignmentHeight); final int childWidth = child.getMeasuredWidth(); child.layout(left, top, left + childWidth, top + child.getMeasuredHeight()); left += childWidth + lp.rightMargin; return left; } /** * Gets the content inset that will be used on the left side of the bar in the current toolbar configuration. * * @return the current content inset left in pixels * @see #getContentInsetStartWithNavigation() * @see #getContentInsetEndWithActions() */ public int getCurrentContentInsetLeft() { return isLayoutRtl() ? getCurrentContentInsetEnd() : getCurrentContentInsetStart(); } /** * Gets the content inset that will be used on the starting side of the bar in the current toolbar configuration. * * @return the current content inset start in pixels * @see #getContentInsetStartWithNavigation() */ public int getCurrentContentInsetStart() { return getNavigationIcon() != null ? Math.max(getContentInsetStart(), Math.max(mContentInsetStartWithNavigation, 0)) : getContentInsetStart(); } } 看 onLayout() 里面，isRtl 这个变量用于判断是否从右往左显示，我们的 Toolbar 是从左往右显示的，所以只需要看值为 false 的情况即可。 在计算 Navigation 的 Layout 中，进到 layoutChildLeft() 方法里进行计算，计算完之后 left 的距离为 paddingLeft + mNavButtonView 的宽度 + mNavButtonView 自身的偏移量。 接下来就进到 getCurrentContentInsetLeft() 方法，因为是从左向右显示所以会调用 getCurrentContentInsetStart() 这个方法，由于有 NavigationIcon，所以就会走前面的分支。 其中 Math.max(mContentInsetStartWithNavigation, 0) 返回的就是 mContentInsetStartWithNavigation 这个值，mContentInsetStartWithNavigation 这个值就是从 contentInsetStartWithNavigation 这个属性中取得的；getContentInsetStart() 这个方法的返回值就是 contentInsetStart 这个属性对应的值。 所以最后就是比较 contentInsetStart 和 contentInsetStartWithNavigation 这两个属性的值。 接下来我们来看这两个属性的值在修改前后的版本中到底是多少，具体的文件应找到对应版本的 appcompact-v7 包的「arr」文件，然后解压找到 /res/values/values.xml，当然也可以通过『Android Studio』的跳转查找功能。 在 V22.2.0 的版本中，描述 Toolbar 属性的内容如下： &lt;style name=&quot;Base.Widget.AppCompat.Toolbar&quot; parent=&quot;android:Widget&quot;&gt; ... &lt;item name=&quot;contentInsetStart&quot;&gt;16dp&lt;/item&gt; &lt;/style&gt; 可以发现 contentInsetStart 的值是 16dp，但没有 contentInsetStartWithNavigation 这个属性，这是因为 contentInsetStartWithNavigation 这个属性是在之后的版本才加上的，而之前的版本 Toolbar 代码中只会根据 contentInsetStart 来计算 Title 的左边距。 再来看看在 V28.0.0 版本中的代码： &lt;style name=&quot;Base.V7.Widget.AppCompat.Toolbar&quot; parent=&quot;android:Widget&quot;&gt; ... &lt;item name=&quot;contentInsetStart&quot;&gt;16dp&lt;/item&gt; &lt;item name=&quot;contentInsetStartWithNavigation&quot;&gt;@dimen/abc_action_bar_content_inset_with_nav&lt;/item&gt; &lt;/style&gt; contentInsetStart 的值也还是 16dp，contentInsetStartWithNavigation 这个值定义在 &lt;dimen&gt; 中，我们去找找这个值： &lt;dimen name=&quot;abc_action_bar_content_inset_with_nav&quot;&gt;72dp&lt;/dimen&gt; 再回到一开始的那段代码： final int contentInsetLeft = getCurrentContentInsetLeft(); // 核心的方法，返回就是那个让距离错误的值 left = Math.max(left, contentInsetLeft); // left 会从之前的 left 值也就是计算过 Navigation 的距离之后，和 contentInsetLeft 比较，取最大值 left 的值一开始是 NavigationIcon 的宽度，一般为 56dp，而 contentInsetLeft 这个值是 72dp，取最大值之后 left 的值就变成了 72dp，就最后导致了距离显示异常。 了解了问题产生的原因，就该说说解决方法了，解决方法也很简单，在 Toolbar 控件属性中添加一句即可： &lt;android.support.v7.widget.Toolbar ... app:contentInsetStartWithNavigation=&quot;0dp&quot; /&gt; 也可以通过指定 &lt;style&gt; 的方法： &lt;style name=&quot;NoSpaceActionBarTheme&quot; parent=&quot;Base.Widget.AppCompat.Toolbar&quot;&gt; &lt;item name=&quot;contentInsetStart&quot;&gt;0dp&lt;/item&gt; &lt;item name=&quot;contentInsetStartWithNavigation&quot;&gt;0dp&lt;/item&gt; &lt;/style&gt; 再在 Toolbar 控件属性中指定： &lt;android.support.v7.widget.Toolbar ... style=&quot;@style/NoSpaceActionBarTheme&quot; /&gt; 完美解决，看看实际效果图： 不过一时半会真的想不通为什么 Android 要加一个这样的东西… ","link":"https://LiarrDev.github.io/post/Space-between-Navigationicon-and-Title-in-Toolbar/"},{"title":"Android Shape 的简单使用","content":"在原生 Android 开发中，许多控件默认都是方方正正的，而我个人也比较喜欢这种设计，因为 Google 的 Material Design 就是从纸片中提炼出来的。 但是近年来 Material Design 的发展，似乎更加往大圆角的方向靠拢了。 Android 的原生控件中是不支持直接设置类似 Radius 的属性，所以又得另辟蹊径了。 Shape Attr 可以通过一个 XML 资源文件来定义，属性参考如下： shape （形状） 最外层标签，用于定义控件的形状。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;ring&quot; android:dither=&quot;false&quot; android:innerRadius=&quot;16dp&quot; android:innerRadiusRatio=&quot;8&quot; android:thickness=&quot;8dp&quot; android:thicknessRatio=&quot;8&quot; android:tint=&quot;@color/colorAccent&quot; android:tintMode=&quot;add&quot; android:useLevel=&quot;false&quot;&gt; ... &lt;/shape&gt; 属性比较多，听我一一道来。 android:shape 是控件的形状，默认为矩形 rectangle，其他可选值还有椭圆 oval、线 line 和 环 ring。 android:dither 用于指定在位图的像素配置与屏幕不同时（例如：ARGB_8888 位图和 RGB_565 屏幕）是否启用位图的抖动，默认值 true，当值为 false 时则停用抖动。 android:innerRadius 是内环半径；android:innerRadius 是内环厚度比，即环的宽度比表示内环半径，默认为 3，可被 android:innerRadius 的值覆盖。android:thickness 是环的厚度，android:thicknessRatio 是环的厚度比，即环的宽度比表示环的厚度，默认为 9，可被 android:thicknessRatio 的值覆盖。这四个属性只有当形状为 ring 的时候才有效。 android:tint 用于着色，这个我们在其他控件也有用到。 android:tintMode 是着色类型，有 add、multiply、screen、src_atop、src_in 和 src_over 六个可选值，这里不细说。 android:useLevel 这个属性比较特殊，是个布尔类型，默认值为 false，一般情况下不需要修改它，为 true 时可在 LevelListDrawable 使用。 corners （圆角） Creates rounded corners for the shape. Applies only when the shape is a rectangle. 用于定义控件的圆角属性，仅可用于矩形 Shape。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;corners android:radius=&quot;8dp&quot; android:topLeftRadius=&quot;8dp&quot; android:topRightRadius=&quot;8dp&quot; android:bottomLeftRadius=&quot;8dp&quot; android:bottomRightRadius=&quot;8dp&quot; /&gt; &lt;/shape&gt; 这个比较简单，不过多解释。 solid （填充） A solid color to fill the shape. 用于定义控件的填充颜色。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;solid android:color=&quot;@color/colorAccent&quot; /&gt; &lt;/shape&gt; 有且仅有颜色这一属性。 gradient （渐变） Specifies a gradient color for the shape. 用于定义控件的渐变色及渐变样式等。 &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;gradient android:type=&quot;radial&quot; android:angle=&quot;90&quot; android:startColor=&quot;@color/colorPrimaryDark&quot; android:centerColor=&quot;@color/colorAccent&quot; android:endColor=&quot;@color/colorPrimary&quot; android:centerX=&quot;50%&quot; android:centerY=&quot;50%&quot; android:gradientRadius=&quot;8dp&quot; android:useLevel=&quot;false&quot; /&gt; &lt;/shape&gt; 这个相对比较复杂，分组来说。 android:type 是渐变的样式，有三个可选值，线性渐变 linear 是默认值，另外还有放射渐变 radial 和扫描渐变 sweep。 android:angle 是渐变角度，须为 45 的整倍数，其中 0 为从左到右，90 为从上到下。 android:startColor、android:centerColor 和 android:endColor 分别是渐变的起始点、中间点和结束点颜色，但你可以按需设置，因为其支持两色渐变和三色渐变，即当选择两色渐变时，android:centerColor 可以不用填写。 android:centerX 和 android:centerY 是渐变中心点 X 和 Y 的相对位置，取值范围为 0~1。 android:gradientRadius 是渐变的半径，只有当渐变类型为 radial 时才有效。 android:useLevel 这个属性比较特殊，是个布尔类型，默认值为 false，一般情况下不需要修改它，而使用 LevelListDrawable 时就要设置其为 true。 stroke （描边） A stroke line for the shape. 用于定义控件的描边属性。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;stroke android:width=&quot;8dp&quot; android:color=&quot;@color/colorAccent&quot; android:dashWidth=&quot;8dp&quot; android:dashGap=&quot;8dp&quot; /&gt; &lt;/shape&gt; android:width 是描边的宽度。android:color 是描边的颜色。 一般情况下描边为实线，如果想设置虚线，则需要另外两个属性，android:dashWidth 是指虚线段的长度，android:dashGap 是指虚线段间隔的长度。 padding （边距） Padding to apply to the containing View element (this pads the position of the View content, not the shape). 用于定义控件的边距属性。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;padding android:bottom=&quot;4dp&quot; android:left=&quot;4dp&quot; android:right=&quot;4dp&quot; android:top=&quot;4dp&quot; /&gt; &lt;/shape&gt; 这个也比较简单，不过多解释。 size （大小） The size of the shape. 用于定义控件的尺寸属性。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;size android:width=&quot;128dp&quot; android:height=&quot;128dp&quot; /&gt; &lt;/shape&gt; 同样比较简单，不过多解释。 Usage 用法也不复杂，在「drawable」文件夹中新建一个 XML 资源文件，将上面的属性按照需要进行组合即可。 比如，我建一个「button_shape.xml」，用来定义 Button 控件的形状。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;solid android:color=&quot;@color/colorAccent&quot; /&gt; &lt;corners android:topLeftRadius=&quot;5dp&quot; android:topRightRadius=&quot;10dp&quot; android:bottomLeftRadius=&quot;15dp&quot; android:bottomRightRadius=&quot;0dp&quot; /&gt; &lt;/shape&gt; 代码并不难理解，形状为矩形，颜色设定为主题色，为四个圆角半径设定为 不同的值。 然后使用其在控件属性中设置为 android:background： &lt;Button android:layout_width=&quot;128dp&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/button_shape&quot; android:text=&quot;Button&quot; /&gt; 效果如下： 其实 Shape 的可配置属性并没有很复杂，所以学起来也不会很难上手，但是却足够我们使用。 ","link":"https://LiarrDev.github.io/post/Simple-Use-of-Android-Shape/"},{"title":"Android CountDownTimer 实现倒计时","content":"在之前『Android 解码 Base64 图片』和『Android 自定义 Dialog 布局』中提到了图形验证码的相关内容，这期来聊聊短信验证码。 现在基本上所有的 App 都要求用手机号码注册了，而短信验证码是一个相对比较方便的验证方式，从大多数 App 的交互体验得知，获取短信验证码后，会设置一个计时器让用户在短时间内不能频繁获取验证码，这是因为服务器提供商有相应的限制，以缓解其服务器的压力，降低并发量。 比如我们使用阿里云的短信服务接口，就限定了每个手机号码每分钟只能获取 1 次，每小时内只能获取 5 次，每天内只能获取 40 次，但用户是不知道这些规则的，我们也没有必要去为用户介绍这些规则，所以我们在开发过程中就要用简单易懂的方式为用户规避这些因为规则而产生的不必要的麻烦。 于是也就有了大多数 App 的计时器按钮。 那么在 Android 开发中该如何实现这个倒计时呢，想了一下发现实现的方式还是挺多的，比如 TimerTask 或者 Handler，但自己实现的话就是重复造轮子了，我查了一下 API，发现有一个特别简单的方法，Android 为我们封装的 CountDownTimer 可以帮助我们轻松实现，而且其内部原理就是通过 Handler 机制实现的。 说实话这也是我第一次看到如此简单的官方接口，源码不用怎么费心思就看懂了，可以来看看： public abstract class CountDownTimer { private final long mMillisInFuture; private final long mCountdownInterval; private long mStopTimeInFuture; private boolean mCancelled = false; /** * @param millisInFuture The number of millis in the future from the call * to {@link #start()} until the countdown is done and {@link #onFinish()} * is called. * @param countDownInterval The interval along the way to receive * {@link #onTick(long)} callbacks. */ public CountDownTimer(long millisInFuture, long countDownInterval) { mMillisInFuture = millisInFuture; mCountdownInterval = countDownInterval; } /** * Cancel the countdown. */ public synchronized final void cancel() { mCancelled = true; mHandler.removeMessages(MSG); } /** * Start the countdown. */ public synchronized final CountDownTimer start() { mCancelled = false; if (mMillisInFuture &lt;= 0) { onFinish(); return this; } mStopTimeInFuture = SystemClock.elapsedRealtime() + mMillisInFuture; mHandler.sendMessage(mHandler.obtainMessage(MSG)); return this; } /** * Callback fired on regular interval. * @param millisUntilFinished The amount of time until finished. */ public abstract void onTick(long millisUntilFinished); /** * Callback fired when the time is up. */ public abstract void onFinish(); private static final int MSG = 1; /** * Handles counting down. */ private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { synchronized (CountDownTimer.this) { if (mCancelled) { return; } final long millisLeft = mStopTimeInFuture - SystemClock.elapsedRealtime(); if (millisLeft &lt;= 0) { onFinish(); } else { long lastTickStart = SystemClock.elapsedRealtime(); onTick(millisLeft); long lastTickDuration = SystemClock.elapsedRealtime() - lastTickStart; // take into account user's onTick taking time to execute long delay; if (millisLeft &lt; mCountdownInterval) { delay = millisLeft - lastTickDuration; // just delay until done if (delay &lt; 0) delay = 0; // special case: user's onTick took more than interval to complete, trigger onFinish without delay } else { delay = mCountdownInterval - lastTickDuration; while (delay &lt; 0) delay += mCountdownInterval; // special case: user's onTick took more than interval to complete, skip to next interval } sendMessageDelayed(obtainMessage(MSG), delay); } } } }; } 先看构造方法，millisInFuture 设置的是倒计时的总时长，countDownInterval 设置的倒计时的间隔时间，单位都是毫秒。 倒计时总时长好理解，countDownInterval 这个参数解释一下，打个比方，如果总时长是 6 秒，间隔时间是 1 秒，计时器就会按照 6-5-4-3-2-1-0 的方式计时；如果总时长是 6 秒，间隔时间是 2 秒，计时器就会按照 6-4-2-0 的方式计时。 如前文所说，重点实现就是在 Handler 中，有 onTick() 和 onFinish() 两个抽象方法，我们只需重写这两个方法来实现自己的逻辑即可，每个计时间隔 onTick() 都会触发一次，当计时结束后 onFinish() 才会触发。 结合短信验证码的需求来看看使用示例： Button btnGetSms = findViewById(R.id.get_sms_btn); btnGetSms.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { CountDownTimer countDownTimer = new CountDownTimer(60 * 1000, 1 * 1000) { @Override public void onTick(long millisUntilFinished) { btnGetSms.setEnabled(false); btnGetSms.setText(millisUntilFinished / 1000 + &quot;s&quot;); } @Override public void onFinish() { btnGetSms.setEnabled(true); btnGetSms.setText(&quot;点击获取&quot;); } }; countDownTimer.start(); requestSmsCode(tel); // 向服务器发送获取短信验证码请求 } } 在构造方法中传入两个时间参数，比如我这里就设置其计时 60 秒，计时间隔为 1 秒，然后重写 onTick() 和 onFinish() 两个方法，使这个 Button 在倒计时期间不可用，以避免用户重复点击，同时，将倒计时显示在 Button 上，让用户知道重新可点击的时间，当倒计时结束后，将 Button 重新置为可用状态，并修改上面的文字以提示用户。 最后我们还需要调用 start() 来让计时器启动，是不是跟线程的启动差不多？这就说明这个计时是异步的，我们可以在倒计时的同时做其他操作，比如在这里就是向服务器发送获取验证码的请求，这样短信验证码就可以通过运营商下发到用户的手机了。 看回 CountDownTimer 的源码，是不是发现还有个 cancel() 方法没有使用？ 正是由于 CountDownTimer 使用了 Handler，所以很容易造成内存泄漏问题，养成良好的编码习惯，要记得把 cancel() 方法补上，因为其里面有资源回收的操作，不调用的话就有可能会造成内存泄漏。 比如，在 Activity 或者 Fragment 被回收时并未调用 CountDownTimer 的 cancel() 方法结束自己，这个时候 CountDownTimer 的 Handler 如果判断到当前的时间未走完，那么会继续调用 onTick() 方法，Activity 或者 Fragment 已经被系统回收，从而里面的变量被设置为 Null，同时 CountDownTimer 中的 Handler 还在继续运行，这一块空间始终无法被系统回收，也就造成了内存泄漏。 我们可以在 CountDownTimer 的 onTick() 方法中对当前对象做判空处理。在 Activity 中可使用： if (!activity.isFinishing()) { // 处理相应逻辑 } 在 Fragment 中可使用： if (!fragment.isDetached()) { // 处理相应逻辑 } 在 Activity 或 Fragment 生命周期结束时，要记得调用 cancel() 方法，如： @Override protected void onDestroy() { super.onDestroy(); if (countDownTimer != null) { countDownTimer.cancel(); countDownTimer = null; } } 最后，再提一个小细节，在执行 onTick() 方法时，源码里面减去了程序执行到当前行时所消耗的时间，所以一个 60 秒的倒计时，点击后看到第一个显示的是 59 而不是 60，不难看出 Google 在这方面还是很严谨的。 ","link":"https://LiarrDev.github.io/post/Android-CountDownTimer/"},{"title":"Android 自定义 Dialog 布局","content":"现在大多数 App，只要不是纯 Material Design 风格的 App，基本都会对 Dialog 的样式进行一些自定义。一方面可能是因为美工只针对 iOS 做了一套设计，而 Android 就只能跟随这套设计走，另一方面，对 Dialog 样式的自定义也是为了能够在各场景下有合理的应用。 之前『Android 使用 Dialog 样式的 Activity』一文中利用设置 Activity 的 android:theme 属性来仿造了一个自定义样式的 Dialog，但其实际本质仍然是一个 Activity，且如果在每个需要自定义 Dialog 的场景都使用这种方式，无疑是大材小用，并且会使 App 变得笨重。这也是 Dialog 这个控件存在的意义。 那么该如何自定义 Dialog 的样式呢？ 其实并不难，Android 中的样式大多数情况都是可以根据 Layout 来布局的，如果没有深度的自定义 View 绘制需求，使用自带的控件组合就可以轻易的帮我们完成自定义的 Dialog 布局。 以之前『Android 解码 Base64 图片』一文中的验证码需求为示例，可以写出如下简单的布局： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/code_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_marginTop=&quot;24dp&quot; android:src=&quot;@drawable/loading&quot; /&gt; &lt;EditText android:id=&quot;@+id/code_edit&quot; android:layout_width=&quot;256dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;12dp&quot; android:layout_gravity=&quot;center&quot; android:inputType=&quot;number&quot; android:maxLength=&quot;4&quot; android:gravity=&quot;center&quot; /&gt; &lt;/LinearLayout&gt; ImageView 用于展示图形验证码，EditText 用于接收用户输入的验证码，很好理解吧。由于图片是通过网络获取的，所以这里默认图我给了一张 Loading 的图片，等通过网络请求到实际的验证码图片时再替换；至于输入框，则加入了最大长度以及输入类型等限制，这里涉及到具体的业务逻辑，不做过多解释。 不难发现，对于 Dialog 的样式定制，其实跟我们平时写 Activity 的布局相差无几。 通过『Android Studio』的实时布局预览面板，也可以像平时写布局一样预览到效果： 在自定义 Dialog 时，我们需要将对应的布局找到，并且绑定到对应 Dialog 中： View imageCodeDialog = getLayoutInflater().inflate(R.layout.image_code_layout, null); ImageView codeView = (ImageView) imageCodeDialog.findViewById(R.id.code_view); EditText codeEdit = (EditText) imageCodeDialog.findViewById(R.id.code_edit); ... new AlertDialog.Builder(this) .setView(imageCodeDialog) .setPositiveButton(&quot;提交&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { … } }) .setCancelable(false) .show(); 可以看到，需要先通过 inflate() 方法获取到刚刚的布局文件后，才可以通过 findViewById() 来绑定对应的控件，在这里你可以将 inflate() 理解为类似控件中 findViewById() 方法所做的操作，只不过 findViewById() 绑定的是控件 ID，而 inflate() 绑定的是布局文件。 获取到对应的控件实例后就可以跟平时一样对其做事件响应了，这里不是重点，省略。 当你把事件响应都编写完后，最重要的弹出 Dialog 步骤来了，其实跟一般情况下弹出 Dialog 区别也不大，只不过是在 show() 方法执行之前，调用 setView() 方法将通过 inflate() 绑定的 View 设置进来就可以了，setView() 也可以理解为类似 Activity 中的 setContentView() 方法所做的操作。 效果如下： ","link":"https://LiarrDev.github.io/post/Android-Customize-Dialog-Layout/"},{"title":"Android 解码 Base64 图片","content":"开发中需要做图形验证码校验的功能，验证码由后端生成，然后传输到前端显示。 为了传输方便，我们不能直接使用 JPG 或者 PNG 格式，而是采用 Base64 格式。 什么是 Base64？ Base64 是网络上最常见的用于传输 8Bit 字节码的编码方式之一，Base64 就是一种基于 64 个可打印字符来表示二进制数据的方法。 Base64 编码要求把 3 个 8 位字节（3*8=24）转化为 4 个 6 位的字节（4*6=24），之后在 6 位的前面补两个 0，形成 8 位一个字节的形式。如果剩下的字符不足 3 个字节，则用 0 填充，输出字符使用 =，因此编码后输出的文本末尾可能会出现 1 或 2 个 =。 为了保证所输出的编码为可读字符，Base64 制定了一个编码表，以便进行统一转换。编码表的大小为 2⁶=64，这也是 Base64 名称的由来。 码值 字符 码值 字符 码值 字符 码值 字符 0 A 16 Q 32 g 48 w 1 B 17 R 33 h 49 x 2 C 18 S 34 i 50 y 3 D 19 T 35 j 51 z 4 E 20 U 36 k 52 0 5 F 21 V 37 l 53 1 6 G 22 W 38 m 54 2 7 H 23 X 39 n 55 3 8 I 24 Y 40 o 56 4 9 J 25 Z 41 p 57 5 10 K 26 a 42 q 58 6 11 L 27 b 43 r 59 7 12 M 28 c 44 s 60 8 13 N 29 d 45 t 61 9 14 O 30 e 46 u 62 + 15 P 31 f 47 v 63 / 这样也就了解 Base64 的编码方式了。 Android 端拿到 Base64 后，是不能够像 JPG 或者 PNG 图片一样直接显示的，还需要对其进行转码操作。 在网上搜了一下，发现 Android SDK 就为我们提供了相应的 API： 拿来即用，发现怎么也解不了，把从服务器获取到的 Base64 放到测试网站上查看了一下，发现是可以加载的，那就肯定是上面这种加载方法有问题了。 我的用法是，从服务器获取到 Base64 的字符串，Base64 的字符串格式如下： iVBORw0KGgoAAAANSUhEUgAAAFAAAAAeCAMAAACMnWmDAAAAGFBMVEUAAABQUFAAAAAAAAAAAAAAAAAAAAAAAABiRp8mAAAACHRSTlMA/wAAAAAAACXRGJEAAAmJSURBVHjaAX4JgfYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQAAAAAAAAAAAAAAAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQAAAAAAAAAAAAAAAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAAAAAEBAQEBAQAAAAAAAAAAAAAAAAABAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAAAAAEBAQEBAQAAAAAAAAAAAAAAAAEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAAAAAAAAAAAAAAAAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQAAAAAAAAAAAAAAAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAAAAAAAAAAAAAAAAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQAAAAAAAAAAAAAAAQABAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAQEBAQABAQEAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQAAAAAAAAAAAAAAAAEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAABAQEAAQEBAQAAAAAAAAAAAAAAAAEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAQEAAQEBAQAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQAAAAAAAAAAAAAAAAAAAQEBAQAAAQEBAQAAAAAAAAAAAAAAAAABAQEAAQEBAQAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQAAAAAAAAAAAAAAAAAAAQEBAQAAAQEBAQAAAAAAAAAAAAAAAAEBAQAAAQEBAQAAAAAAAAAAAAABAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQAAAAAAAAAAAAAAAAEBAQAAAQEBAQAAAAAAAAAAAAABAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQAAAAAAAAAAAAAAAAEBAQAAAQEBAQAAAAAAAAAAAAABAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQAAAQEBAQAAAAAAAAAAAAAAAQEBAAAAAQEBAQAAAAAAAAAAAAEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQAAAQEBAQAAAAAAAAAAAAAAAQEBAQEBAQEBAQEAAAAAAAAAAAEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQAAAQEBAQAAAAAAAAAAAAAAAQEBAQEBAQEBAQEAAAAAAAAAAAEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQAAAQEBAQAAAAAAAAAAAAAAAQEBAQEBAQEBAQEAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQAAAAAAAAAAAAAAAQEBAQEBAQEBAQEAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB5zgFrGnILCQAAAABJRU5ErkJggg== 由于其并没有上面示例的 Base64 的解析头 data:image/png;base64,…，所以我便自作主张给它添加上去了，而且在使用一些 Base64 解码工具时，也要求有该部分内容才能成功解码，所以我一直认为这样做并没有错。 后来真的想不到原因就抱着试一下的心态把这部分内容去掉了，发现居然可以用，被网上的那些人给坑惨了。 所以正确的使用方式应该如下： public static void setImageViewWithBase64(ImageView imageView, String base64) { if (TextUtils.isEmpty(base64)) { throw new NullPointerException(&quot;The string of Base64 is empty&quot;); } if (base64.startsWith(&quot;data:image/png;base64,&quot;) || base64.startsWith(&quot;data:image/*;base64,&quot;) || base64.startsWith(&quot;data:image/jpg;base64,&quot;)) { base64 = base64.split(&quot;,&quot;)[1]; } byte[] decodedString = Base64.decode(base64, Base64.DEFAULT); Bitmap decodedByte = BitmapFactory.decodeByteArray(decodedString, 0, decodedString.length); imageView.setImageBitmap(decodedByte); } 为了能够正常显示图片，这里先对 Base64 的字符串进行判空，如果为空则抛出 NullPointerException 异常，接着再看这个字符串是否以 Base64 的解析头开头，如果是，就把这部分去掉，最后再把 Base64 解码转为 Bitmap，并显示到 ImageView 中去。 即使我们对 Base64 字符串进行了判空和去掉解析头的操作，这个字符串仍然有可能是错误的，即它有可能不是一个符合 Base64 规范的字符串，别担心，这种情况下 Base64 的库会帮我们抛出 IllegalArgumentException 的异常。 ","link":"https://LiarrDev.github.io/post/Android-decode-Base64-Picture/"},{"title":"一行代码实现网页变灰效果","content":"2020 年 4 月 4 日，清明。同时由于 COVID-19，这天还是全国悼念的日子。 上网的你会发现，许多网站在这天都将网站首页和部分内容变成灰色： 你可能会认为这是通过更换一个统一的 CSS 样式，图片也加上蒙版等操作实现的。但这样成本未免也太高了，有效期只有一天，而且万一某个控件忘了设置灰色的样式也会显得格外突兀。 其实，我们有更简单的实现方法，只需要一行代码即可搞定。 在这里我就拿我自己的 Blog 来做演示，先看看还没有更改前的效果图： 在需要修改的元素中添加如下 CSS 样式： filter: grayscale(); 比如我想将整个页面都改为灰色，那么只需为 &lt;html&gt; 标签设置该样式即可： html { ... filter: grayscale(); } 设置后效果如下： 如果我只想 &lt;body&gt; 变灰，那我只需在 &lt;body&gt; 中设置该样式： body { ... filter: grayscale(); } 设置后就只有该标签内的内容才会变灰： 我们还可以设置灰度： html { ... filter: grayscale(50%); } 比如我设置灰度为 50% 后效果是这样的： 这个值是转换比例，取值范围为 0%～100%，也就是 0～1，接受浮点数，当为 0% 时图像无变化，为 100% 时完全转为灰度图像。 不过，因为众所周知的兼容性问题，建议还是添加多几个类似的属性： html { ... -webkit-filter: grayscale(); -moz-filter: grayscale(); -ms-filter: grayscale(); -o-filter: grayscale(); filter: grayscale(); filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); } 其中最后一行是用于兼容『Internet Explorer』的，这个其实 filter 是 CSS1 的属性了，但是因为老版本的『Internet Explorer』（IE 4.0 ~ IE 9）对此支持不怎么感冒，对浏览器的支持也不稳定，因此这个属性只能当做实验性技术来观察。至于为什么要在开头写上 progid:DXImageTransform.Microsoft，其实我也不是很清楚，有可能只是为了区分。 filter 属性见名知义，就是滤镜的意思，可以将模糊或颜色偏移等图像效果应用于元素，通常用于调整图像、背景和边框的渲染。CSS 标准内已实现了预定义效果的函数，所以我们可以拿来即用。 最后，再看看浏览器对 filter 的兼容性： 可以看到，除了『Internet Explorer』，其他浏览器都支持 filter，另外『Firefox』还单独对 SVG 图像提供了支持。 参考内容： filter - CSS（层叠样式表） | MDN 不得不收藏的——IE中CSS-filter滤镜小知识大全 ","link":"https://LiarrDev.github.io/post/Turn-Webpage-Gray-with-One-Line-of-Code/"},{"title":"在 macOS 上使用 ADB","content":"逐渐开始转用 macOS 进行开发工作，可是有时候按照 Windows 的套路在 macOS 上却总是行不通，比如需要在 macOS 往 Android 手机安装一个软件。在 Windows 上，只需把 Android 手机和 PC 使用 USB 数据线连接，即可实现两者互相传送文件，但是在 macOS 上，使用 USB 数据线将两者连接之后，是看不到连接的 Android 手机的。 在尽量不安装多余软件的情况下解决问题，我最先想到的是 ADB，即 Android Debug Bridge，因为作为 Android 开发者，最常使用的 Android SDK 里就已集成了 ADB，这在之前『Android Device Monitor 权限笔记』中有使用过，不过我当时使用的也是 Windows 系统。 macOS 上，直接在『Terminal』中输入 adb devices，提示找不到相应的命令： 出现这个问题应该考虑是否已经配置环境变量，在没有配置环境变量的情况下是不能够全局调用的。 不过你直接进入到 ADB 所在目录执行也是会提示相同的错误： 要把 ADB 的完整路径写上才可以正常执行： 但是写完整路径终究是不方便，还是配置环境变量才能够一劳永逸。 首先打开『Terminal』终端命令窗口，进入 HOME 目录下： ➜ cd ~ 如果本来就在这个目录可以不用执行这条命令。 接着使用 touch 命令执行： ➜ touch .bash_profile 该命令有两个功能： 如果文件存在，把已存在文件的时间标签更新为系统当前时间。 如果文件不存在，就创建新的空文件。 由于 macOS 不像 Windows 一样可以直接使用右键在当前目录下创建文件，所以一般都会使用 touch 命令来新建文件。 创建完成后输入命令打开文件： ➜ open -e .bash_profile 在打开的文件最后增加如下两行代码再保存： export ANDROID_SDK=/Users/&lt;Username&gt;/Library/Android/sdk export PATH=${PATH}:${ANDROID_SDK}/platform-tools ANDROID_SDK 指向的路径需要替换成自己的 SDK 路径。 最后再用命令更新修改： ➜ source .bash_profile 环境变量即配置成功。 ","link":"https://LiarrDev.github.io/post/use-ADB-on-macOS/"},{"title":"Android 子线程调用 Toast","content":"Android 中经常需要开启子线程进行耗时操作，而在耗时操作结束后，我们又常需要使用 Toast 告知用户，但如果直接在子线程中调用 Toast，往往不能如愿，得到如下 Warn 级报错： W/System.err: java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare() W/System.err: at android.os.Handler.&lt;init&gt;(Handler.java:200) W/System.err: at android.os.Handler.&lt;init&gt;(Handler.java:114) W/System.err: at android.widget.Toast$TN$2.&lt;init&gt;(Toast.java:340) W/System.err: at android.widget.Toast$TN.&lt;init&gt;(Toast.java:340) W/System.err: at android.widget.Toast.&lt;init&gt;(Toast.java:103) W/System.err: at android.widget.Toast.makeText(Toast.java:256) W/System.err: at com.example.liarr.View.Activity.LoginActivity$4.run(LoginActivity.java:209) W/System.err: at java.lang.Thread.run(Thread.java:760) 那么问题就来了，在我印象中 Toast 是不需要依赖于 UI 线程的，所以不需要 runOnUiThread() 来加载，同样也不需要像『Android 使用 Dialog 样式的 Activity』中提到的 Dialog 一样需要依赖于 Activity，那到底是什么原因导致 Toast 不能正常显示呢？ 从这个错误中，我们可以看到，是因为 Looper 对象的原因。 下面分析一下 Toast 在主线程与子线程运行的缺失项，来看看 Toast 的部分源码： /** * Show the view for the specified duration. */ public void show() { if (mNextView == null) { throw new RuntimeException(&quot;setView must have been called&quot;); } INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; final int displayId = mContext.getDisplayId(); try { service.enqueueToast(pkg, tn, mDuration, displayId); } catch (RemoteException e) { // Empty } } private static INotificationManager sService; static private INotificationManager getService() { if (sService != null) { return sService; } sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;)); return sService; } Toast 内部有两类 IPC 过程，第一类是 Toast 访问 NotificationManagerService，第二类是 NotificationManagerService 回调 Toast 里面的 TN 接口，这里涉及到 AIDL 进程间通讯，TN 继承自远程 NotificationService 的代理类，实际弹 Toast 的工作是在 TN 这个类里面完成的： private static class TN extends ITransientNotification.Stub { ... final Handler mHandler; TN(String packageName, @Nullable Looper looper) { ... if (looper == null) { // Use Looper.myLooper() if looper is not specified. looper = Looper.myLooper(); if (looper == null) { throw new RuntimeException(&quot;Can't toast on a thread that has not called Looper.prepare()&quot;); } } mHandler = new Handler(looper, null) { @Override public void handleMessage(Message msg) { switch (msg.what) { case SHOW: { IBinder token = (IBinder) msg.obj; handleShow(token); break; } case HIDE: { handleHide(); // Don't do this in handleHide() because it is also invoked by handleShow() mNextView = null; break; } case CANCEL: { handleHide(); // Don't do this in handleHide() because it is also invoked by handleShow() mNextView = null; try { getService().cancelToast(mPackageName, TN.this); } catch (RemoteException e) {} break; } } } }; } /** * schedule handleShow into the right thread */ @Override public void show(IBinder windowToken) { if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.obtainMessage(SHOW, windowToken).sendToTarget(); } /** * schedule handleHide into the right thread */ @Override public void hide() { if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this); mHandler.obtainMessage(HIDE).sendToTarget(); } public void cancel() { if (localLOGV) Log.v(TAG, &quot;CANCEL: &quot; + this); mHandler.obtainMessage(CANCEL).sendToTarget(); } public void handleShow(IBinder windowToken) { ... } public void handleHide() { ... } } 可以看到，TN 里的 show() 运行在 Binder 线程池中，所以需要使用 Handler 将其切换到当前线程中，实际上 show() 和 hide() 方法实际上都是 TN 类通过 Handler 向当前线程发送消息，执行相应的任务。 这里又涉及到 Handler 的消息机制。Handler 的消息机制涉及到三个重要的类：Handler、MessageQueue 和 Looper，该消息机制要完整运行这三个必不可少，而 Handler 的创建过程中： /** * Use the {@link Looper} for the current thread with the specified callback interface and set whether the handler should be asynchronous. * * Handlers are synchronous by default unless this constructor is used to make one that is strictly asynchronous. * * Asynchronous messages represent interrupts or events that do not require global ordering with respect to synchronous messages. Asynchronous messages are not subject to the synchronization barriers introduced by {@link MessageQueue#enqueueSyncBarrier(long)}. * * @param callback The callback interface in which to handle messages, or null. * @param async If true, the handler calls {@link Message#setAsynchronous(boolean)} for each {@link Message} that is sent to it or {@link Runnable} that is posted to it. * * @hide */ public Handler(@Nullable Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); } } mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException(&quot;Can't create handler inside thread &quot; + Thread.currentThread() + &quot; that has not called Looper.prepare()&quot;); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } 必要条件之一是需要一个 Looper, 这里就已经看到开头的那个报错了。 没错，就是因为缺少 Looper。那为什么主线程不会报错呢？因为主线程在创建的时候已经默认执行了 Looper.prepare() 这个方法并且调用 Looper.loop() 使其开始轮询工作。而子线程是默认没有初始化这个 Looper 的，这也就解释了为什么 Looper.myLooper() 返回的是一个空的对象。 扒源码扒了这么久，简单来说，Android 的主 UI 线程中其 Android 框架已经默认给出了一个 Looper 对象， 而我们自己创建的子线程中，Looper 对象需要自己给构建出来。这也就是为什么我们在子线程中直接使用 Toast 的时候会报出上面异常。 既然已经知道了问题是如何产生的，那么我们现在就只需要在我们的子线程中把 Toast 所需要的 Looper 对象给构建出来就可以了。 new Thread(new Runnable() { @Override public void run() { ... Looper.prepare(); Toast.makeText(context, &quot;Toast Content&quot;, Toast.LENGTH_SHORT).show(); Looper.loop(); } }).start(); 在子线程里面初始化一个 Looper 对象并开始轮询，这样 Toast 就可以加入到消息队列中，才能够进行输出。 当然，也可以使用 runOnUiThread() 来解决： new Thread(new Runnable() { @Override public void run() { ... runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(context, &quot;Toast Content&quot;, Toast.LENGTH_SHORT).show(); } }); } }).start(); Toast 的代码创建在 Runnable 中，然后在需要 Toast 时，把这个 Runnable 对象传给 runOnUiThread()，这样 Runnable 对象就能在 UI 线程中被调用了。 我在『简书』上留意到曾任新浪高级架构师、58同城项目负责人的 @初一十五a 在文章『Android进阶：六、在子线程中直接使用 Toast 及其原理』中封装一个可以在任何线程中使用 Toast 的工具类，其代码如下： @初一十五a 还解释道：初始化 Toast 之前先判断当前线程的 Looper 是否为空，为空则初始化一个新的 myLooper，然后在调用 Toast 的 show() 方法之后让 Looper 启动起来即可。因为 Looper.loop() 方法是无限循环的，为了防止 Looper 阻塞线程，导致内存泄漏应该及时退出 Looper。 相信很多人一看，觉得挺有道理，拿来即用，并不会考虑太多，实际上这段代码依然是有 Bug 的，可见 @初一十五a 的测试用例并不完善，可能是他太多注重在子线程的兼容，以至于遗漏了最简单的情况： public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ToastUtil.showToast(MainActivity.this, &quot;Toast Content&quot;); } } 实际效果是这样的： 一开始看到 Toast 被正常弹出，你可能会觉得这是没问题的，但是实际上整个 App 都处于白屏状态，当你按下 Back 键之后你就知道程序被卡死了。 问题出在 Looper.loop() 中，其实我们应当判断当前线程是主线程还是子线程，再决定需不需要构建新的 Looper： public class ToastUtil { public static void showToast(Context context, String text) { if (isMainThread()) { Toast.makeText(context, text, Toast.LENGTH_SHORT).show(); } else { Looper mLooper = Looper.myLooper(); if (mLooper == null) { Looper.prepare(); mLooper = Looper.myLooper(); } Toast.makeText(context, text, Toast.LENGTH_SHORT).show(); if (mLooper != null) { Looper.loop(); mLooper.quit(); } } } private static boolean isMainThread() { return Looper.getMainLooper() == Looper.myLooper(); } } 这里可以使用之前『Android 判断当前是否在主线程』一文中提到的方法来判断当前线程，如果是主线程的话，那就直接弹出 Toast 即可，如果是子线程，则构建 Looper。 但你依然需要了解，Looper.loop() 是会阻塞线程的，也就是说 Looper.loop() 后面的语句并不会执行（不过许多情况下弹 Toast 的确是当前逻辑的最后一步操作），即使你调用了 quit() 也无济于事，所以我个人还是更加喜欢用 Handler 来辅助封装： public class ToastUtil { public static void showToast(final Context context, final String text) { if (isMainThread()) { Toast.makeText(context, text, Toast.LENGTH_SHORT).show(); } else { Handler handler = new Handler(Looper.getMainLooper()); handler.post(new Runnable() { @Override public void run() { Toast.makeText(context, text, Toast.LENGTH_LONG).show(); } }); } } private static boolean isMainThread() { return Looper.getMainLooper() == Looper.myLooper(); } } 跟之前一样，如果是主线程那就直接弹出 Toast，如果不是，则通过 Looper.getMainLooper() 获取主线程的 Looper，Handler 会关联 Looper 对应的 MessageQueue，于是这里就将 Toast 放到主线程的 MessageQueue 中进行处理。这种方法其实和 runOnUiThread() 的原理是相似的。 其实很多入门者会认为 Toast 在子线程中不能正常弹出是因为子线程中进行 UI 更新是非安全操作，但实际上并不是抛出异常的真正原因，因为根本还没有执行到更新 UI 那一步。 Toast 本质上是一个 Window，跟 Activity 是平级的，checkThread() 只是 Activity 维护的 View 树的行为。Toast 操作的是 Window，不属于 checkThread() 抛非主线程不能更新 UI 异常的管理范畴，它用 Handler 只是为了用队列和时间控制排队显示 Toast 罢了。 ","link":"https://LiarrDev.github.io/post/Android-calls-up-Toast-in-child-thread/"},{"title":"Android 判断当前是否在主线程","content":"在 Android 开发中，我们经常需要了解当前编码的逻辑处于哪个线程，因为我们知道，耗时操作应该放在子线程，而 UI 操作则应该在主线程。 当我们封装一些工具类的时候，为了可复用性，需要对当前的线程进行判断，否则如果操作不当，就会抛出异常。 那么，如何判断当前的线程是主线程还是子线程呢？ 借助 Looper 我们可以很方便地知道答案： public boolean isMainThread() { return Looper.getMainLooper() == Looper.myLooper(); } 我们也可以利用 Looper 获取当前的线程： public boolean isMainThread() { return Looper.getMainLooper().getThread() == Thread.currentThread(); } 还可以通过 Looper 获取当前线程的 ID 进行比较： public boolean isMainThread() { return Looper.getMainLooper().getThread().getId() == Thread.currentThread().getId(); } 可以看到，Looper 在这三个方法中都起到重要的作用，这就涉及到 Android 的消息机制，简单来说就是只有主线程中 Android 默认为我们构建了 Looper，而在子线程中并没有，所以主线程和子线程当 Looper 是不会相等的，也就可以很方便地知道当前线程是否在主线程中了。 ","link":"https://LiarrDev.github.io/post/Android-determines-main-Thread/"},{"title":"用 Node.js 写一个下载图片的爬虫","content":"尝试学了一下 Node.js，虽说之前有学习使用过 React Native，但可能 Java 的根深蒂固，让我很难理解 JavaScript 和 Node.js 的思想。 都说写一个项目胜过看十天书，那就直接开练吧。 本想写个简单的后台熟悉一下，但是考虑到花费的时间可能会比较长，而且没什么方向，所以也是无从下手。 后来发现，Node.js 原来也可以写爬虫，那就写了个爬虫玩一下呗，也算是了却我一直想学 Python 写爬虫玩数据分析的心愿。 想了一想也不知道爬点啥，打开『Bing』搜索的时候突然想到，Microsoft 的『Bing』不是每天都更新壁纸的吗，那我能不能把『Bing』的壁纸爬下来呢？ 好的开搞。 首先打开『必应壁纸』首页。 然后查看页面源代码，我使用的浏览器快捷键是 Ctrl+U，一按，结果没反应，右键菜单进入吧，右键，结果还是没反应。 卧槽，没想到『必应壁纸』的工程师居然做了这样的设置，不过的确用户体验是挺好的，只不过对我们这群“搞破坏的”不友好罢了。 既然不能查看页面源代码，那我能不能使用它的检查元素功能呢？ 我的浏览器快捷键是 Ctrl+Shift+C，一按，有了！ 这样看起来还是不太方便，既然检查元素的窗口已经打开了，那我能不能在这里进入页面源代码的窗口呢，Ctrl+U 尝试一下，欸，进去了。 先看一下『必应壁纸』首页的前端源代码，太凌乱了，它的图片链接也不好找，这样爬起来肯定就十分麻烦了，还是放弃吧，于是我把爬取对象转向了其他壁纸网站。 最终确定是『Stocksnap.io』。 为什么选它呢，首先它的页面除了壁纸以外并没有其他的多余元素，另外它的页面源代码可读性也比『必应壁纸』要高，图片链接也十分清晰，就它了。 接下来就是编写代码了。 编写代码之前肯定需要 Node.js 环境，直接去官网下载就可以了，而我在之前『Windows 平台 React Native 开发环境搭建笔记』中我已经安装过 Node.js 的环境了，所以就不用重新安装。 直接上代码。 var https = require('https'); var fs = require('fs'); var path = require('path'); var url = 'https://stocksnap.io'; // 检查目录中是否存在 images 文件夹，如果没有就创建 fs.mkdir('./images', function(err) { if(err) { console.log('Directory already exists.'); } else { console.log('Directory creation success.'); } }); https.get(url, function(res) { var content = null; res.on('data', function(chunk) { content += chunk; }); res.on('end', function() { var reg = /src=&quot;(.*?\\.jpg)&quot;/img; // 全局匹配以【src=】开头，并以【.jpg】结尾的内容 var filename; while (filename = reg.exec(content)) { getImage(filename[1]); // 子匹配 } }); }); function getImage(url) { var imageName = path.parse(url).base; var stream = fs.createWriteStream('./images/' + imageName); https.get(url, function(res) { res.pipe(stream); console.log(imageName + ' download completed！'); }); } 解释一下源代码。 首先是引入各模块，这里由于需要发起 HTTPS 请求，需要写入文件，还需要分析 URL 的路径，所以就引入这三个模块。 接着需要一个目录来存储从网站上抓取下来的图片，为了不使文件夹里的文件类别凌乱，我就在项目的根目录创建一个名为「images」的文件夹用于存放，如果该文件夹已存在，则不需要重复创建，并在控制台中打印相关信息。 做好这些前期准备之后，就可以向『Stocksnap.io』发起 HTTPS 请求了。 先把整个页面的前端代码爬下来，如果数据量大的话，肯定不能一次性就能把所有的内容获取，所以使用拼接的方式把获取的片段连接完整。 当请求结束之后，会触发 end 事件，就在 end 事件中处理我们对其页面代码的解析。 我们再次来看看『Stocksnap.io』的前端代码： 比『必应壁纸』的代码清晰多了，定位一下我需要的内容，我需要的是图片，一般图片都会使用 &lt;img&gt; 标签。 太好了，就一个完整的链接，不需要进行 URL 的拼接操作。 我只需要写个正则表达式将它匹配上就可以了，匹配规则也很简单，以 src=&quot; 开头，并以 .jpg&quot; 结尾的链接就是我们想要得到的图片链接。 根据之前在『常用正则表达式』中的参考，我们可以写出相应的正则表达式：/src=&quot;(.*?\\.jpg)&quot;/。 那后面的 /img 是什么意思呢？由于我对正则也是一知半解，就照搬一下网上的解释： 这些是模式修正符，是解说正则表达式模式中使用的修正符。其中，/i 表示模式中的字符将同时匹配大小写字母；/m 表示“行起始”和“行结束”除了匹配整个字符串开头和结束外，还分别匹配其中的换行符的之后和之前；/g 表示全局循环。 另外，/s 表示模式中的圆点元字符（.）匹配所有的字符，包括换行符；/x 表示模式中的空白字符除了被转义的或在字符类中的以外完全被忽略，在未转义的字符类之外的 # 以及下一个换行符之间的所有字符，包括两头，也都被忽略；/e 表示 preg_replace() 在替换字符串中对逆向引用作正常的替换。 当正则匹配完成后，匹配结果是一个数组对象，有两项，格式如下： [ 'src=&quot;https://cdn.stocksnap.io/img-thumbs/280h/G5Q3IISSYX.jpg&quot;', 'https://cdn.stocksnap.io/img-thumbs/280h/G5Q3IISSYX.jpg' ] 可以发现它已经帮我们把图片的 URL 解析出来了，那我们只需获取解析好的链接进行下载即可。 根据数组的下标特性，下标为 1 的项就是图片的 URL。 在下载图片的函数中，调用 path 模块的 parse() 方法，可以对 URL 中的信息再次进行解析，得到如下 JSON 对象： { root: '', dir: 'https://cdn.stocksnap.io/img-thumbs/280h', base: 'G5Q3IISSYX.jpg', ext: '.jpg', name: 'G5Q3IISSYX' } 其中，base 就是图片的文件名，通过连缀 .base 就可以获取了，获取的作用就是为了帮我们把下载的图片命名。 最后，通过管道流 pipe() 方法把图片下载下来就可以了。 如果程序没有报错，可以在项目根目录发现有一个「images」文件夹，里面已经有我们刚才爬下来的图片了。 不过，由于首页展示的只是缩略图，所以这个图片比较小，另外，由于页面使用的是滑动到底部自动加载的技术，所以爬取的数量也不会太多。 由于这对于我来说也只能算是一个练手的小项目，我也不打算继续深入研究了，如果有兴趣的朋友可以对其功能进行扩展以及改进。 我顺便也把这个项目放到了 Github 上，有兴趣的朋友可以去看看。 ","link":"https://LiarrDev.github.io/post/An-Images-Crawler-Written-with-NodeJS/"},{"title":"腾讯应用开放平台上线 App 踩坑记录","content":"经过漫长而痛苦的改 Bug 折磨，我为公司开发的 App 终于要上线了！ 我仿佛看到了工资在向我招手，仿佛听到了年终奖为我欢呼！ 然而，现实总是充满了坑，没想到上线应用的路依然曲折，今天就来说说我在上线 App 时踩过的坑。 这次上架的只有 Android 版的 App，经 Leader 决定，只在『应用宝』上线，虽然这样限制了分发渠道，但也是减少了我的工作量，而且在『应用宝』上线的一个好处就是可以利用微信及其开放平台进行跳转下载。 好的，开搞。 首先得在『腾讯开放平台』注册开发者账号，不过得益于腾讯平台社交能力，支持使用 QQ 授权登陆，但是也仅能支持 QQ 授权登录。 这种方式对于个人开发者而言，是十分方便的，而对于公司来说，就会涉及到个人隐私问题，就像我们公司，需要员工注册一个新的 QQ 号，并使用员工的手机号码进行绑定，鉴于国内隐私保护能力，这样对员工的影响也是不小的，所以我认为应该增加一个邮箱注册登录的入口更加合适。 另外需要注意的是，『腾讯开放平台』在我使用期间表现十分不稳定，通过搜索引擎结果登录后常常进不去，我后来发现可以通过其邮件上的链接跳转，而进去后部分页面也会出现加载时间过长的情况。 登录后还需要作一系列的信息认证，个人开发者需要上传身份证等信息，公司开发者还需要上传公司的信息，比如营业执照等。 做完一系列的认证就可以上传开发好的应用了，在「管理中心」中创建应用即可。 随后跳转到「选择平台」的页面，这里可以选择 Android、iOS 以及 Web 三个平台。 由于我目前只开发了 Android 版本的 App，所以这里我选择 Android，然后点击「创建应用」，则会弹出对话框选择应用类型。 有「游戏」和「软件」两个选项，我这里选择「软件」。 关于应用分成的问题，我在『Quick App』一文中有聊过，有兴趣可以了解一下。 接着就到关键一步了，填写应用的相关信息。 这就经历了我踩坑最多的地方，因为我一共提交了 7 次审核，历时三周。 先打个比方说一下我公司的背景，假设有 A 和 B 两个公司，其中 B 是 A 的独立子公司，我就职于 B 公司。这怎么理解呢，可以参考一下手机品牌中的 HUAWEI 和 ZTE 等，Honor 是 HUAWEI 的独立子品牌，nubia 是 ZTE 的独立子品牌；也可以参考一下 Alphabet，Google 就是 Alphabet 的子公司，所以我所在的公司是子公司，上面还有一个母公司。 第一次提交，驳回原因是该应用存在版权问题，需提供应用软件著作权证书，请在版权证明处上传相关材料扫描件后重新提交。 原因是未上传版权证明，由上图可以看出，版权证明中并无必填项，所以我一开始并没有上传。 后来我才发现，版权证明下有一行小字： 应用必须提供版权证明，开发者版权证明提交，请参考版权证明指引，大小2M以内，支持JPG/PNG格式的图片。 过分！明明说必须提供，但是却没有标记为必填项，这不是浪费我时间嘛！ 上网查了一下相关手续，极其繁琐，需要填写各种资料，更麻烦的是需要上传源码及文档共 120 页的鉴定材料，而且邮寄提交后需要等待一个月的时间，由于文档我在开发的时候并没有写（坏习惯），所以要完成这一整套流程估计也得一个半月，于是我就给 Leader 提了两个方案： 一是等待我完成所有鉴定材料再申请，但是这个时长具有不确定性，因为这个材料即使提交了，也可能因为各种原因不能通过，被打回来还要修改，然后重新提交上去后再审核，每个审核周期大约是一个月，所以往坏的想，申请一个这样的证书可能需要几个月甚至是半年的时间。 二是交给第三方平台来辅助完成，这些平台基本上都自称包过，而且加钱还可以加急，可以保证在短时间内拿到这个软件著作权证书，但价格也不便宜。 当我搜集了一天的资料递给 Leader 后，他说可以拿母公司的软件著作权证书来代替。 突然就觉得我这一整天瞎忙活了… 上传母公司的著作权证书，静候佳音。 第二天再次驳回，原因是该应用经下载检测，应用内容无法加载，请修复并核实后重新提交。 出现这个问题是因为之前在『WeChat H5 Payment for Android』和『Android M 从 Service 中启动 Activity』等文章中提到这个 App 里包含了大量的 WebView，而由于后台代码还未发版本，仅在测试服务器上可用，而在正式服务器上不能正常显示，所以导致被驳回。 催促后端工程师发版本，使其能正常显示，再次提交申请。 迎来了第三次驳回，原因是该应用经下载体验，无注册端口，请在版权证明处上传测试账号和密码的截图后重新提交。 因为当初我们开发的时候为了方便维护，要求用户在微信端绑定了手机号码后，才能在 App 中使用手机号码登录，这样就不会在 App 端登录的时候需要创建一个新的账号出来，账号中的各种信息也可以同步，但明显『腾讯开放平台』方并不允许我们这样做。 为了通过这个审核，我们只能重新修改代码，使用户在使用 App 时，用手机号码创建一个新的账户，不检测其是否在微信绑定。不过由于我们的后端大佬太忙需求太多，这个后台需求交给了一个菜鸡前端来完成，结果这个功能做好后，其他的功能都出了 Bug。 上线要紧，毕竟我们使用了 WebView，这些功能可以后面再进行热修复，而且由于我们的 App 需要结合硬件使用，所以相信审核的人员也没有条件可以测出我们的 Bug。 提交后，第四次驳回，原因是该应用存在版权问题，提供软件著作权证书归属与上传认证开发商不一致，请提供相关授权后重新提交。 上面提到，我们使用了母公司的软件著作权证书，而在「应用提供方」一项中我填写的是我们子公司，这就导致了不一致，综合考虑，我们把这一项也改成了母公司，并再次提交申请。 第五次驳回，该应用存在版权问题，提供软件著作权人名称与认证开发者名称不一致，请在版权证明处上传真实有效的材料扫描件后重新提交。 这是由于一开始我们在申请该开发者账号的时候，填写的也是子公司的信息，所以同样造成了冲突，把开发者账号的认证信息也修改成母公司，并再次提交审核。 第六次驳回的原因和第五次相同，一开始我还以为我理解错了，去后台查看了一下才发现，开发者账号的认证信息修改也是需要审核的，所以在审核未成功之前，使用的还是之前的信息，也就是子公司的认证信息，因此才会出现同样的驳回原因。 等待认证信息审核成功后，再次提交 App 的上线申请。 终于，在第七次提交的时候成功了。 最后就可以在「管理中心」中查看 App 的相关信息了，比如应用等级和下载量等，也可以更新安装包进行版本迭代，还可以为应用接入广告服务等。 这时候可以去『应用宝』搜索一下确认是否成功上线，因为一开始我接收到腾讯发过来的上线邮件时，我去『应用宝』搜索并没有，然后在网上看了一下发现有人遇到相同的情况，他们是通过提交工单给腾讯方要求其展示的，不过过了十几分钟后我准备采取相同的做法时，却发现在『应用宝』中可以搜索到我们的应用了。 成功上线，皆大欢喜。 ","link":"https://LiarrDev.github.io/post/Releasing-Apps-on-Tencent-Application-Open-Platform/"},{"title":"printf(\"%d\", printf(\"%d%d\", 1, 2));","content":"之前『printf(&quot;%d&quot;, (1, 2), 3);』一文给大家讲解了一段有趣但是没什么卵用的代码，今天再来讲一个： printf(&quot;%d&quot;, printf(&quot;%d%d&quot;, 1, 2)); 老规矩，写个 Demo 跑一遍： #include &lt;stdio.h&gt; int main() { printf(&quot;%d&quot;, printf(&quot;%d%d&quot;, 1, 2)); return 0; } 打印的结果为 122。 这次的代码相比之前的要复杂一丢丢，没关系，跟着我一步步来解释。 最外层是 printf() 函数，其值为后面表达式的值，因此需要先计算后面的表达式。 后面的表达式同样也是一个 printf() 函数，这个表达式就非常简单了，跟我们平常使用无差，就是 12。 所以最外层的 printf() 函数获取的 %d 的值就是 2。这时候你可能会有点儿懵，为什么程序不会报错呢？ 我们经常使用的 printf() 是在 C 语言中产生格式化输出的函数，定义在「stdio.h」头文件中，虽然我们常常是直接写这一行就完事了，但实际上，printf() 是有返回值的，返回值的类型为 int，和 %d 对应上了，因此程序可以正常运行不会报错。 那么这个返回值的含义是什么呢？我们可以写几个 Demo 来看看： #include &lt;stdio.h&gt; int main() { int result = printf(&quot;%s&quot;, &quot;ab&quot;); printf(&quot;%d&quot;, result); return 0; } 打印结果为 ab2，可以知道，打印字符串 ab 的返回值为 2。 #include &lt;stdio.h&gt; int main() { int result = printf(&quot;%s&quot;, &quot;abc&quot;); printf(&quot;%d&quot;, result); return 0; } 打印结果为 abc3，可以知道，打印字符串 abc 的返回值为 3。 根据规律不难得出，该返回值实际上就是格式化数据替换后整个字符串的总字符个数，这也就解释了文章最开始时的程序输出结果。 最后再结合一下上次的文章，下面这段代码的打印结果是什么： printf(&quot;%d&quot;, printf(&quot;%d&quot;, 1, 2)); 结果是 11，因为里层的 printf() 函数只打印了 1 个字符。 另外需要注意的是，像 \\n 之类的转义字符也同样会计入字符个数中。 ","link":"https://LiarrDev.github.io/post/printf-d-printf-d-d-1-2/"},{"title":"原生 Android 和 React Native 交互","content":"在之前的文章『「ZXing」实现 Android 扫描二维码』中提到，由于我在 React Native 中找不到可用的扫描二维码的第三方组件，所以被迫使用 Android 原生来实现该功能，那么就会出现一个新的问题，通过原生 Android 扫码得到的数据，如何传给 React Native 进行处理呢？ 其实原生 Android 扫码后，继续由原生 Android 进行处理也是可以的，这样就避免了再次把数据回传的步骤，但是既然我使用的是 React Native，那么看重的就是其跨平台的特性，即既可以在 Android 系统中运行，也可以在 iOS 系统中运行。 也就是说，如果我在 Android 中进行扫码后继续由原生 Android 做逻辑处理，那我同样需要在 iOS 开发的时候做一套类似的逻辑处理。这无疑是加大时间成本来做相同的事情，与代码复用性相悖了。 所以，这就涉及到了原生 Android 和 React Native 交互的问题（如果以后我尝试做 iOS 开发的话会考虑原生 iOS 和 React Native 的交互）。 话不多说，来看看如何实现。 首先在项目中创建 MyIntentModule 类，并继承 ReactContextBaseJavaModule，这是原生 Activity 和 React 的交互模块。 /** * 原生 Activity 与 React 交互模块 */ public class MyIntentModule extends ReactContextBaseJavaModule { public MyIntentModule(ReactApplicationContext reactContext) { super(reactContext); } @Override public String getName() { return &quot;IntentMoudle&quot;; } @ReactMethod public void startActivityFromJS(String name, String params) { try { Activity currentActivity = getCurrentActivity(); if (null != currentActivity) { Class toActivity = Class.forName(name); Intent intent = new Intent(currentActivity, toActivity); intent.putExtra(&quot;params&quot;, params); currentActivity.startActivity(intent); } } catch (Exception e) { throw new JSApplicationIllegalArgumentException(&quot;Could not open Activity: &quot; + e.getMessage()); } } @ReactMethod public void dataToJS(Callback successBack, Callback errorBack) { try { Activity currentActivity = getCurrentActivity(); String result = currentActivity.getIntent().getStringExtra(&quot;data&quot;); if (TextUtils.isEmpty(result)) { result = &quot;没有数据&quot;; } successBack.invoke(result); } catch (Exception e) { errorBack.invoke(e.getMessage()); } } @ReactMethod public void startActivityForResult(String activityName, int requestCode, Callback successCallback, Callback erroCallback) { try { Activity currentActivity = getCurrentActivity(); if (null != currentActivity) { Class aimActivity = Class.forName(activityName); Intent intent = new Intent(currentActivity, aimActivity); currentActivity.startActivityForResult(intent, requestCode); String result = (String) myBlockingQueue.take(); successCallback.invoke(result); } } catch (Exception e) { erroCallback.invoke(e.getMessage()); throw new JSApplicationIllegalArgumentException(&quot;Could not open the Activity: &quot; + e.getMessage()); } } } 这里需要记住 getName() 方法中的命名名称，在 React Native 中调用需要用到，还要记得在相应的方法中添加 @ReactMethod 的注解，否则该方法将不被添加到 React Native 中。 然后在项目中创建 MyReactPackage 类，实现 ReactPackage 接口暴露给 React Native 调用，在 createNativeModules() 里注册上一步添加的模块： /** * 注册模块 * 实现 ReactPackage 接口暴露给 React Native 调用 */ public class MyReactPackage implements ReactPackage { // 注册 MyIntentModule 添加的交互模块 @Override public List&lt;NativeModule&gt; createNativeModules(ReactApplicationContext reactContext) { return Arrays.&lt;NativeModule&gt;asList(new MyIntentModule(reactContext)); } @Override public List&lt;ViewManager&gt; createViewManagers(ReactApplicationContext reactContext) { return Collections.emptyList(); } } 再在项目的 MainApplication 的 getPackages() 方法中注册 MyReactPackage 模块： @Override protected List&lt;ReactPackage&gt; getPackages() { return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new MyReactPackage() // 注册 MyReactPackage 模块 ); } 这样在 Android 端的配置就基本完成了，你可能会问 Activity 呢？ 其实上文提到我是用在二维码功能上，所以就用『ZXing』中的 CaptureActivity 来作为目标 Activity。 接下来就是在 React Native 中的调用了： export default class FootBar extends Component { _onPressScanBTN() { NativeModules.IntentMoudle.startActivityForResult(&quot;com.google.zxing.activity.CaptureActivity&quot;, 100, (successMsg) =&gt; {alert(successMsg)}, (erroMsg) =&gt; {alert(erroMsg)} ); } render() { return ( &lt;View style={styles.container}&gt; &lt;ImageBackground style={styles.footbarbg} source={require('./images/footbar/footbar_background.png')}&gt; ... &lt;TouchableOpacity onPress={this._onPressScanBTN}&gt; &lt;Image style={styles.scanbtn} source={require('./images/footbar/scan_btn.png')} /&gt; &lt;/TouchableOpacity&gt; ... &lt;/ImageBackground&gt; &lt;/View&gt; ); } } 我在这里就将扫描的结果返回并弹窗提醒，当然实际上我们是将回传的数据作其他操作的，这里只是作简单演示。 效果如下： 该 Demo 已上传至 Github，详情可👉戳此处👈查看。 ","link":"https://LiarrDev.github.io/post/Communicate-with-React-Native-from-Android/"},{"title":"『ZXing』实现 Android 扫描二维码","content":"之前在『React Native Swiper』一文中整理了我在 React Native 中使用的第三方组件 Swiper，而当时项目中还需要集成扫描二维码的功能，于是我就查找了一些扫描二维码的第三方组件，但是装上之后却发现没有一个能够顺利调用，无奈之下就只能选择在原生上实现这个功能。 由于这个 Demo 目前只有 Android 版本，所以也只是集成了在 Android 环境下的扫码功能。 而在 Android 版本中，我使用的是『ZXing』这个第三方库，包括在后来上线的公司项目中，我使用的也是这个库，今天就来整理一下『ZXing』的使用笔记。 『ZXing』我第一次听说的时候还以为是一个中国人开发的项目，后来才知道它是「Zebra Crossing」的简写，它是一个用 Java 实现的开源的多格式 1D/2D 条形码图像处理库。 支持的格式如下： 1D product 1D industrial 2D UPC-A Code 39 QR Code UPC-E Code 93 Data Matrix EAN-8 Code 128 Aztec (beta) EAN-13 Codabar PDF 417 (beta) ITF MaxiCode RSS-14 RSS-Expanded 虽然很多格式我都没听过，但我只需要知道它支持 QR Code 就可以了，毕竟 QR Code 在国内的应用是发挥到了极致。 由于『ZXing』的可定制性高，所以也衍生出了许多基于『ZXing』的第三方开源项目，而且在国内的技术论坛也有很多民间的定制版本。 话不多说，马上来看看『ZXing』的使用方法。 首先得添加依赖： dependencies { implementation 'com.google.zxing:core:(insert latest version)' } 其实现在已经有大量的开发者在『ZXing』上进行了集成、优化或者精简，使得我们这些小白用户能够在未搞懂原理的情况下轻易的接入到项目中。 因为『ZXing』的项目非常庞大，而我在项目中仅需用到扫描二维码的功能，其他许多功能我并不需要，所以我还是使用精简过的『ZXing』比较合适。 找了一圈，发现国内开发者 ahuyangdong 修改过并做的 Demo 简单易用，比较适合我，于是就采用了他的方案，\b项目『QrCodeDemo4』。 另外，国内开发者 HappyMiao 的『QrCodeScan』也有相似性。 『QrCodeDemo4』有持续更新，而我使用的是较老一些的版本。 先把『QrCodeDemo4』中 com.google.zxing 整个包 Copy 到自己的项目，包内共有 5 个目录： 再把『QrCodeDemo4』的布局文件「activity_scanner.xml」和「toolbar_scanner.xml」拉到自己的项目中，这里实现的是扫描二维码的页面，我个人觉得没有必要分开，于是就整合到了一起： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/drop_scanner&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;@color/colorPrimaryDark&quot; android:src=&quot;@drawable/ic_drop&quot; /&gt; &lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;SurfaceView android:id=&quot;@+id/scanner_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;center&quot; /&gt; &lt;com.google.zxing.view.ViewfinderView android:id=&quot;@+id/viewfinder_content&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:corner_color=&quot;@color/corner_color&quot; app:frame_color=&quot;@color/viewfinder_frame&quot; app:label_text=&quot;扫描二维码&quot; app:label_text_color=&quot;@color/colorAccent&quot; app:laser_color=&quot;@color/laser_color&quot; app:mask_color=&quot;@color/viewfinder_mask&quot; app:result_color=&quot;@color/result_view&quot; app:result_point_color=&quot;@color/result_point_color&quot;/&gt; &lt;/FrameLayout&gt; &lt;/LinearLayout&gt; 这里我做了少许修改，因为我已经在超过 3 个项目中集成过『ZXing』，所以在不同项目中我的修改方式都不尽相同，比如在这里我直接使用了 ImageView 来代替 Toolbar，而在有的项目中我则是直接使用 Toolbar。 然后把「raw」目录下的「beep.ogg」也复制到项目： 这个其实是音频文件，是扫描成功时的提示音。 接着再把「values」目录下的「attrs.xml」、「ids.xml」和「colors.xml」这三个文件进行合并或拷贝，即没有该文件则直接 Copy 到项目，有则跟原文件进行合并。 我这里「attrs.xml」和「ids.xml」都没有，所以直接复制，「colors.xml」默认就有了，则在后面追加相应的内容： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;resources&gt; &lt;color name=&quot;colorPrimary&quot;&gt;#008577&lt;/color&gt; &lt;color name=&quot;colorPrimaryDark&quot;&gt;#d9f3ff&lt;/color&gt; &lt;color name=&quot;colorAccent&quot;&gt;#00A0E9&lt;/color&gt; &lt;color name=&quot;waveBackColor&quot;&gt;#66C7F3&lt;/color&gt; &lt;!-- QRCode scanner color begin --&gt; &lt;color name=&quot;viewfinder_mask&quot;&gt;#B0000000&lt;/color&gt; &lt;color name=&quot;result_view&quot;&gt;#B0000000&lt;/color&gt; &lt;color name=&quot;viewfinder_frame&quot;&gt;#90FFFFFF&lt;/color&gt; &lt;color name=&quot;result_point_color&quot;&gt;#C0FFFF00&lt;/color&gt; &lt;color name=&quot;laser_color&quot;&gt;#00A0E9&lt;/color&gt; &lt;color name=&quot;corner_color&quot;&gt;#00A0E9&lt;/color&gt; &lt;!-- QRCode scanner color end --&gt; &lt;/resources&gt; 其实对应的目录也是可以从『ZXing』官方开源项目中找到的，根据个人喜好下载即可。 现在打开 com.google.zxing 包内的文件如无意外应该是会有报错的，应该是 R 文件引用有误，修改为本项目的 R 即可，相应文件参考如下： com.google.zxing.activity.CaptureActivity com.google.zxing.decoding.CaptureActivityHandler com.google.zxing.decoding.DecodeHandler com.google.zxing.view.ViewfinderView 集成部分终于完成了，接下来就该编码实现功能了。 在「AndroidManifest.xml」中添加相应的权限： &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;!-- 网络权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot; /&gt; &lt;!-- 震动权限 --&gt; &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; &lt;!-- 摄像头权限 --&gt; &lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt; &lt;!-- 自动聚焦权 --&gt; 并注册 CaptureActivity，该 Activity 就是扫描二维码页面。 &lt;application ... &gt; ... &lt;activity android:name=&quot;com.google.zxing.activity.CaptureActivity&quot; /&gt; &lt;/application&gt; 需要注意的是，高版本的 Android 中需要动态申请 Camera 权限，调用源码如下： public class MainActivity extends AppCompatActivity { final static int REQ_PERM_CAMERA = 1; final static int REQ_QR_CODE = 2; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button scanButton = (Button) findViewById(R.id.scan_btn); scanButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { startScanQrCode(); } }); } /** * 开始扫描二维码 */ void startScanQrCode() { if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) { // 申请权限 ActivityCompat.requestPermissions(MainActivity.this, new String[] {Manifest.permission.CAMERA}, REQ_PERM_CAMERA); return; } // 二维码扫描 Intent intent = new Intent(MainActivity.this, CaptureActivity.class); startActivityForResult(intent, REQ_QR_CODE); overridePendingTransition(R.anim.activity_open, R.anim.activity_stay); } /** * 动态申请权限 * @param requestCode * @param permissions * @param grantResults */ @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case REQ_PERM_CAMERA: // 摄像头权限申请 if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { startScanQrCode(); } else { // 授权被禁止 Toast.makeText(MainActivity.this, &quot;请至权限中心打开本应用的相机访问权限&quot;, Toast.LENGTH_LONG).show(); } break; default: } } /** * 扫码结果回调 * @param requestCode * @param resultCode * @param data */ @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); // 扫描结果回调 if (requestCode == REQ_QR_CODE &amp;&amp; resultCode == 161) { Bundle bundle = data.getExtras(); String scanResult = bundle.getString(INTENT_EXTRA_KEY_QR_SCAN); // scanResult 就是扫描二维码得到的字符串，再次可以根据自己的逻辑编写代码 } } } 这里有个小问题，在回调的这段代码中： @Override protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); // 扫描结果回调 if (requestCode == REQ_QR_CODE &amp;&amp; resultCode == 161) { ... } } 很多技术博客中使用的是 resultCode==RESULT_OK，其中 RESULT_OK 的值是 -1，但是我发现在我第一个集成的项目（就是用 React Native 写的 Demo）中出现了问题，修改后发现修改为 resultCode==161 后行得通，我也不知道为什么，所以在后期我所有的项目中我都将其写为 161，不知道是因为我项目的特殊性还是什么原因，并没有深究。 放一下当初 React Native 写的 Demo 集成『ZXing』后运行扫描二维码的功能吧： 我尝试去看『ZXing』的源码，探索一下原理，但发现太高深了，很难看懂，还是等哪天技术提升了再来研究吧。 大概说一下几个主要类的功能： CaptureActivity 是扫描界面，也是官方 Demo 的主界面。 CaptureActivityHandler 是辅助扫描界面，进行一些逻辑的处理和消息的转发。 CameraManager 和 Camera 是相机有关的部分，如预览和自动聚焦等。 DecodeThread 和 DecodeHandler 是跟解码有关的类，包括线程和消息处理。 BarcodeFormat 和 DecodeHintType 内有支持的一些类型、格式和配置等。如二维码、各种条形码和字符集。 其他就不一一说明了，看一下扫码流程： ","link":"https://LiarrDev.github.io/post/Android-QR-Code-Scanning-with-ZXing/"},{"title":"printf(\"%d\", (1, 2), 3);","content":"今天发现了一段有趣的代码，如下： printf(&quot;%d&quot;, (1, 2), 3); 好久没碰 C 语言了，看到这段代码有一种熟悉而又陌生的感觉。 那么结果是多少呢？ 写个 Demo 跑一下就知道了呗： #include &lt;stdio.h&gt; int main () { printf(&quot;%d&quot;, (1, 2), 3); return 0; } 编译运行，结果为 2。 但是为什么呢？ 先把这个表达式简化一下： printf(&quot;%d&quot;, 2, 3); 编译运行一下可以发现，值同样为 2。 这样就可以知道 (1,2) 的值就是 2，那么 3 呢？ 其实使用 %d 来匹配的时候，会根据个数来进行匹配，也就是说当 %d 只有一个的时候，就匹配一个表达式，所以这里就匹配了 2。 当有多个 %d 时，就继续匹配后面的表达式，这样的写法也更为熟悉： printf(&quot;%d%d&quot;, 2, 3); 结果为 23。 这个问题解决了，我们再来看看表达式 (1,2) 为什么等于 2。 根据 C 语言语法，, 为语句分隔符，程序先后执行两条语句，因此表达式 (1,2) 的值是最末尾的表达式 2 的值，等于 2。 这属于赋值表达式，我们可以看一个相似的代码： int x = ((1, 2), 3); x 的值为 3，因为按照语句执行顺序 3 为最后执行。 同理即可知道 (1,2) 的值就是 2。 ","link":"https://LiarrDev.github.io/post/printf-d-1-2-3/"},{"title":"Android M 从 Service 中启动 Activity","content":"最近在项目中遇到了一个版本适配问题，由于之前测试的时候一直在我自己的手机上测试的，我手机的 Android 版本是 7.1.2，测试是完全没有问题的，结果有天借了同事的 Lenovo X3c50 过来一测，完了，出 Bug 了。 Lenovo X3c50 的 Android 版本是 6.0.1，API 23，出现 Bug 的具体体现为 App 不能从 Service 中启动 Activity，为了确定是否为 Android M 以下版本的问题，我特意找来了另一台 Android L 的手机，发现出现同样的情况。 由于项目中有使用 WebView，内有大量的网页，而网页使用的 JQuery 在 Android L 及以下版本都都出现了一些异常，所以我需要解决上面提到的 Bug，使其兼容至 Android M。 在 Android N 及以上版本中，从 Service 中启动 Activity 的方式可以与从 Activity 中启动 Activity 的方式类似： Intent intent = new Intent(getApplicationContext(), NewActivity.class); startActivity(intent); 但是在 Android M 中这种方法并不凑效，于是寻求其他方法，发现只需增添一行代码即可： Intent intent = new Intent(getApplicationContext(), NewActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); 为什么 Android 在 Service 里面启动 Activity 要强制规定使用参数 FLAG_ACTIVITY_NEW_TASK 呢？ 因为在 Service 中我们一般会进行耗时操作，也就是说可能这个耗时操作还没执行完，用户就打开了其他的程序，比如『Browser』，而当前的 TASK 就不是原程序中的 TASK，如果此时原程序的 Service 弹出了 Activity，该 Activity 就与『Browser』处于同一个 TASK，用户就会莫名其妙，因为这个 Activity 是属于原程序的，而不是『Browser』的。 所以对于 Service 而言，干脆强制定义启动的 Activity 要创建一个新的 TASK 要合理得多。 ","link":"https://LiarrDev.github.io/post/Start-Activity-from-Service-uppon-Android-M/"},{"title":"Color Themes","content":"之前在『打造个性化「Android Studio」』文末挖了一个坑，要介绍另一个关于『Android Studio』个性化定制的小技巧，今天就来填这个坑。 众所周知，『Android Studio』是基于 JetBrains 家的『IntelliJ IDEA』开发的，那么所有『IntelliJ IDEA』的主题理论上都可以为『Android Studio』所用。 今天就推荐一个提供『IntelliJ IDEA』主题的网站，另外它的主题还适用于『Webstorm』、『PyCharm』、『RubyMine』、『PhpStorm』和『AppCode』等 JetBrains 旗下的 IDE。 它的主题主要适用于 Editor，也就是说修改后的主题效果主要应用在 Editor 区。 先来看下我未设置前的『Android Studio』主题效果。 这是在『打造个性化「Android Studio」』中设置了「Material Theme UI」后的效果，至于「Sexy Editor」，为了在这次的设置中更加容易看出变化，我暂时先把它卸载了。 众所周知，Editor 的设置无非就是背景颜色已经代码高亮，但是由于代码的性质不同，比如关键字、变量、常量、字符串等等，高亮的颜色以及效果都不尽相同，所以想要自己定制一套专属的 Editor 主题，是一件工作量十分庞大的事情。 所以类似『Color Themes』的主题网站则能够大大的减轻我们的工作量，我们只需要在其网站上选择一套适合自己的主题即可，当然如果你有余力也可以定制一套属于自己的主题并上传到其网站上供其他开发者使用。 废话少说，打开『Color Themes』首页，可以看到有大量的主题。 值得注意的是，有一个相似的网站『Color Themes Test』，只有少量的主题，但是由于这两个网站的相似度极高，所以我也不清楚它是否为『Color Themes』的测试网站。 可以看到『Color Themes Test』只有一页的内容，为了更好的选择主题，还是建议使用『Color Themes』。 你可以逐个查看主题以选择适合自己的主题，但同时『Color Themes』也提供了搜索功能，由于我之前已经安装了「Material Theme UI」插件，那么我更希望可以找到风格相搭的 Editor 主题，所以我可以在搜索中输入「Material」进行检索。 检索到了 4 个主题，还可以看到每个主题的下载量，第一个「Material Default」主题感觉跟我已经安装的「Material Theme UI」插件十分相似，为了更好的体现安装前后的对比，我选择第四个紫色的「Material-Custom」进行安装，这个主题应该是用户上传的。 点进去可以对该主题作简单的预览，查看其代码高亮效果是否对自己的胃口。 点击上方的绿色按钮即可下载，下载完成后会得到一个 JAR 包。 接下来打开『Android Studio』或上面提到的其他 IDE，选择菜单「Import Settings」。 这时候就会弹出一个文件选择框，选择刚下载的 JAR 包。 然后就会弹出一个导入选项的对话框。 这里我按照默认全选，最后就会跟之前安装主题插件一样，要求重启『Android Studio』。 重启后就可以看到该主题已经生效了。 字体很可能也被修改了，如果不喜欢则按照之前在『打造个性化「Android Studio」』中提到的方式重新修改即可。 网上的教程大多数到这儿就结束了，而没有删除主题 JAR 包的教程，而当某一天突然不喜欢这个主题的时候只能替换而不知道如何删除，这对于我这种有洁癖的人来说是不能容忍的，接下来就教你如何删除导入的这个主题。 进入到「Color Scheme」的设置中，选择对应的主题，并在右边的下拉菜单中选择 Delete 即可。 Delete 主题后不需要重启『Android Studio』，立即生效。 『Android Studio』改造教程到这儿就暂告一段落了，如果以后还发现有什么好玩的主题插件再做介绍吧。 ","link":"https://LiarrDev.github.io/post/Color-Themes/"},{"title":"打造个性化『Android Studio』","content":"做 Android 开发也好长一段时间了，虽然赶上了 Google 爸爸的『Android Studio』首班车，但一直都专注于开发，没有时间为自己打造一个趁手的开发环境。 正好今天闲下来了，就打算好好美化一下『Android Studio』。 众所周知，『Android Studio』给我们内置了两款主题，一款是默认的纯白色的「IntelliJ」，另一款则是号称程序员专属主题的深灰色的「Darcula」，为了保护眼睛，我就一直使用的「Darcula」作为我的默认主题。 刚开始使用的时候觉得还是挺不错的，但是用到后面却有点视觉疲劳，Editor 中的字体都采用了明度较低的颜色，这样与背景颜色相差不会很大，但有时候阅读代码会比较累。 而下方的 Logcat 只有红色跟白色两种颜色，使得我在调试的时候不得不在所有情况下使用 Log.e() 这种打印日志的方式，而这种方法跟其性质是相悖的。 『Android Studio』为我们规定了 6 个不同等级的 Log，我们应该根据不同情况而对我们的 Log 进行调整，但实际上，默认的 Logcat 只会在「Error」和「Assert」两个等级会显示红色，其他等级则显示白色，这对于我的调试来说，是及其不方便的。 接下来就根据以上的需求，重新改造一下我的『Android Studio』吧。 Font 首先是字体，默认的字体其实看起来并不十分舒服，所以我的所有文本编辑器都使用了等宽无衬线字体，其中号称程序员专属的「Consolas」字体也是我使用最多的字体。 字体大小以及行距根据自己需要设置就行，一般外接显示屏的时候字体大小我会设为 16，在笔记本上则是 14，不过很多人都说我设置得还是有点小，可能我对代码上下文比较关注，字体设小一点可以看到更多的代码，更加清楚自己的编码逻辑。 Logcat 上文也提到，Logcat 单调的颜色让我十分苦恼，于是我参考了『Making Android Studio pretty』这篇文章，改造了一下自己的 Logcat。 这篇文章提到的 Logcat 配色方案如下： Verbose: #BBB Debug: #33B5E5 Info: #9C0 Assert: #A6C Error: #F44 Warning: #FB3 而我自己使用的配色方案也十分相似： Assert: #AA66CC Debug: #33B5E5 Error: #FF4444 Info: #99CC00 Verbose: #FFFFFF Warning: #FFBB33 最终效果如下： 这样就不用再为了更好的查看信息而把一个「Debug」等级的 Log 设置成「Error」等级了。 另外，为了阅读方便，我还为所有的等级 Log 字体都设置了「Bold」属性进行加粗。 Material Theme UI 接着就是界面主题了，这个我将借助插件来实现。 在「Plugins」中搜索「Material Theme UI」，会提示找不到，因为还未下载。 然后点击「Search in repositories」，就可以看到相应的搜索结果。 选择「Material Theme UI」并点击「Install」。 这时候『Android Studio』会弹出一个提示框。 大概意思就是说这是第三方提供的插件，你应该仔细阅读相关的文档，JetBrains 不为你的个人信息负责。这种条款我们一般都是懒得看的，点击「Accept」即可。 这样插件就开始下载了，接下来要做的就是耐心等待，如果网络畅通的话很快就可以下载完成。 下载完成后，要求重启『Android Studio』才能使该插件生效。 当然如果你正忙于编码的话也可以选择稍后再重启，不过由于并不需要花费太多的时间，我选择了马上重启。 接下来就是见证奇迹的时刻，重启后可以很明显的发现「Material Theme UI」已经在我们的界面上应用了。 但是 Editor 区域依然是原来的样式，打开「Color Scheme」可以重新选择 Editor 的主题。 选择对应的主题后并应用，就可以看到 Editor 区域的主题也更换了。 但是默认的字体也更换了，想要更换字体则需要到「Color Scheme Font」中修改。 修改完成并应用，可以发现 Editor 的字体也回到原来熟悉的样子了。 这样就和谐多了。 Sexy Editor 再来介绍另一款插件『Sexy Editor』。 并不知道为什么这款插件的开发者会起一个这样的名字，可能是他觉得写代码是一件非常 Sexy 的事情吧。 安装方式跟上面并没有太大的差别，但是安装完重启后你会发现并没有变化，因为还需要进行一系列的设置。 点击右上方的「ADD EDITOR」可以为 Editor 创建不同的主题，我一般只在一个主题上设置，就不需要修改了，再点击底部的「ADD IMAGE(S)…」按钮可以选择背景图片。 在本地选择一张自己喜欢的图片后就可以应用到 Editor 中去了，如果仍然没有改变的话可以尝试修改一下上方的相关设置。 最终效果如下： 你可以选择不同的图片以打造一个适合自己的 Editor。 activate-power-mode 有人说写代码没激情怎么办，「activate-power-mode」可以让你写代码的时候体验狂拽酷炫的效果，让你的代码充满激情。 其实「activate-power-mode」是根据『Atom』上的同名插件移植过来的，具体效果请看下文。 首先就是在 Editor 的右上角出现了一个大大的计数器，用来记录 Combo。 具体是什么的 Combo… 懂了吧，是不是感觉敲个代码都像在殴打产品经理？ Power Mode II 如果你并不喜欢上面这种 Combo 式的效果，而是想每一次点击都有特效，那就试试「Power Mode II」吧。 特效跟「activate-power-mode」相差不多。 删除某段代码的时候，还会蹦出一个全屏的特效。 不过感觉「Power Mode II」的流畅度没有「activate-power-mode」高，自行选择即可。 以上插件当不需要想要卸载的时候，可以回到「Plugins」中进行管理。 选中相应的插件，再点击右边的「Uninstall」卸载即可。 到这里基本定制内容也差不多结束了。 不过还有另一个定制的小技巧，但是我打算另外写一篇推文进行介绍，请持续关注。 ","link":"https://LiarrDev.github.io/post/Customize-Your-Android-Studio/"},{"title":"React Native Swiper","content":"虽然不做 React Native 开发好久了，但是最近整理文件的时候发现了当初学习 React Native 的时候做的 Demo，那就顺便整理一下开发笔记，温故而知新。 环境搭建可以参考之前的文章『Windows 平台 React Native 开发环境搭建笔记』。 由于 React Native 源于 React，所以其使用的也是 React 相关的语法，也就是 JavaScript，而在页面视图上，则使用了类似 HTML 和 CSS 的 JSX，有过前端基础的我其实上手并不十分困难，不过由于转向 Android 开发很长一段时间了，写起来也并不十分容易。 不过好在很多组件都已经有大神做了封装，并提供给广大开发者使用，这就在很大程度上方便了我们这些搬砖工的开发。 而『react-native-swiper』则是我接触的第一个第三方组件。 在其 Github 项目主页上，它还十分嚣张的打出了自己的 Title：The best Swiper component for React Native. 那么就来看看它是否真的配得上 The Best 这个头衔。 首先通过 npm 工具把『react-native-swiper』安装到项目中： ➜ npm i react-native-swiper --save 然后将这个 Component 导入到需要应用的页面中： import Swiper from 'react-native-swiper'; 接下来就可以在页面中应用了： export default class MainLeafContent extends Component { render() { return ( &lt;View&gt; &lt;View style={styles.banner}&gt; &lt;Swiper style={styles.wrapper} autoplay={true}&gt; &lt;Image style={styles.banner_image_size} source={require('./images/banner/0.png')} /&gt; &lt;Image style={styles.banner_image_size} source={require('./images/banner/1.png')} /&gt; &lt;Image style={styles.banner_image_size} source={require('./images/banner/2.png')} /&gt; &lt;/Swiper&gt; &lt;/View&gt; ... &lt;/View&gt; ); } } const styles = StyleSheet.create({ banner: { height: screenwidth * 673 / 1090, width: screenwidth }, banner_image_size: { height: screenwidth * 673 / 1090, width: screenwidth } ... }); module.exports = MainLeafContent; 使用的是 React 的 JSX 语法，在 &lt;View&gt; 中使用 &lt;Swiper&gt; 标签把需要的 &lt;Image&gt; 设定好，并指定样式和资源就可以使用了。 比如我这里在 &lt;Swiper&gt; 中引入了 3 张本地图片，图片存储在 ./images/banner/ 目录下，而 &lt;Swiper&gt; 的父 View 以及 &lt;Image&gt; 都指定宽度填满屏幕，由于图片的尺寸是固定的，所以我按比例来设定了高度。同时，我还为其设定了自动轮播的功能。 最后我把它导出为一个自定义组件，供我在其他页面使用。效果图如下： 上面用到了 autoplay 属性，其实『react-native-swiper』还为我们提供了其他属性，基本属性如下： Prop Defalt Type Description horizontal true bool 如果值为 true 时，那么滚动的内容将是横向排列的，而不是垂直于列中的 loop true bool 如果设置为 false，那么滑动到最后一张时，再次滑动将不会展示第一张图片 index 0 number 初始进入的页面标识为 0 的页面 showsButton false bool 如果设置为 true，那么就可以使控制按钮（即：左右两侧的箭头）可见 autoplay false bool 设置为 true，则页面可以自动播放 当然还有一些自定义属性允许开发者选择，但由于对我来说使用频率并不高，就不贴上来了，需要的时候查查文档就可以，详情可至其 Github 项目主页查看。 ","link":"https://LiarrDev.github.io/post/React-Native-Swiper/"},{"title":"微信发送定时消息","content":"现在大多数手机都有定时短信的功能了，在中学时代我常用这个功能为好友送上整点的生日祝福。 虽然那个时候 QQ 很流行，但我也记不清为什么要用短信来发生日祝福了，或许是因为当时的 3G 流量不便宜，或许是因为当时学校的信号不好，又或许只是因为套餐内的免费短信太多… 再后来微信崛起了，于是我们就进入了全民微信时代，短信基本只用来查询话费以及接收各种验证码，微信才是 IM 主战场。 但是定时短信功能一直让我念念不忘，特别是随着年龄增大，出来工作后压力也不小，实在是熬不起夜，也更不愿意熬到 12 点整给别人发一条祝福了。 不过我也发现了一种可以使用微信发送定时消息的方法。 当然，这种方法也很程序员，可能这也是当程序员的附加福利和附加诅咒吧。 来看看实现方法。 首先，我们需要登录微信网页版，至于为什么是网页版，是因为在手机客户端以及电脑客户端不能很方便的执行我们自定义的脚本，而浏览器可以。 登录成功后，选择需要发送定时消息的好友或群，即打开对话框，随后对该页面使用「检查元素」，并切换到「Console」的 Tab。 在「Console」的 Tab 中即可编写脚本对该网页进行逻辑控制，我们输入下方代码： var appElement = document.querySelector('[ng-controller=chatSenderController]'); var $scope = angular.element(appElement).scope(); setInterval(function() { var now = new Date(); var date = now.getDate(); var hour = now.getHours(); var min = now.getMinutes(); var second = now.getSeconds(); if (second == 0 &amp;&amp; min == 30 &amp;&amp; hour == 15) { // 发送时间 var output = &quot;This is test message.&quot; // 发送内容 $scope.editAreaCtn = output; $scope.sendTextMessage(); } }, 1000); 我们可以修改对应的时间以及内容，来为我们的需求做定制操作，编写完成并回车，到达指定的时间后，消息即可发送： 如果我们需要发送表情呢？ 也很简单，先在对话框中输入一个表情，然后使用「检查元素」功能找到该表情的代码即可： 比如我在这里选择了「」这个表情，那么可以从「Elements」的 Tab 中看到其代码为： &lt;img class=&quot;qqemoji qqemoji36&quot; text=&quot;[衰]_web&quot; src=&quot;/zh_CN/htmledition/v2/images/spacer.gif&quot;&gt; 将上方代码中发送的内容替换为该表情的代码即可： var appElement = document.querySelector('[ng-controller=chatSenderController]'); var $scope = angular.element(appElement).scope(); setInterval(function() { var now = new Date(); var date = now.getDate(); var hour = now.getHours(); var min = now.getMinutes(); var second = now.getSeconds(); if (second == 0 &amp;&amp; min == 30 &amp;&amp; hour == 15) { // 发送时间 var output = &quot;&lt;img class=\\&quot;qqemoji qqemoji36\\&quot; text=\\&quot;[衰]_web\\&quot; src=\\&quot;/zh_CN/htmledition/v2/images/spacer.gif\\&quot;&gt;&quot; // 发送内容 $scope.editAreaCtn = output; $scope.sendTextMessage(); } }, 1000); 这里需要注意的是，由于表情中含有 &quot; 符号，会有语法冲突，所以我们需要在对应的 &quot; 前加转义字符 \\ 进行转义，或将对应的 &quot; 改为 '： var appElement = document.querySelector('[ng-controller=chatSenderController]'); var $scope = angular.element(appElement).scope(); setInterval(function() { var now = new Date(); var date = now.getDate(); var hour = now.getHours(); var min = now.getMinutes(); var second = now.getSeconds(); if (second == 0 &amp;&amp; min == 30 &amp;&amp; hour == 15) { // 发送时间 var output = &quot;&lt;img class='qqemoji qqemoji36' text='[衰]_web' src='/zh_CN/htmledition/v2/images/spacer.gif'&gt;&quot; // 发送内容 $scope.editAreaCtn = output; $scope.sendTextMessage(); } }, 1000); 回车执行后可以看到表情也如期发送： 有几点需要注意： 一定要保持网络通畅（这不是废话吗）。 定时消息会发送到当前打开的会话窗口中。 脚本读取的是本地时间，所以请以电脑的时间为准，其实最好的方法是设置同步网络时间，方便又可以避免不必要的麻烦。 macOS 需要注意是否在节能时间范围内，Windows 笔记本也需注意这种情况。 接下来就可以给你心仪的 TA 送上最准时的祝福了～ ","link":"https://LiarrDev.github.io/post/Send-Timed-Messages-with-WeChat/"},{"title":"在 IIS 7 配置 TLS 1.2","content":"之前在『IIS 7 为多个域名绑定证书』一文中介绍了如何申请免费的泛域名证书并在服务器上绑定了 SSL 证书，但是如果需要做微信小程序，根据微信小程序的官方开发文档，HTTPS 证书还需支持 TLS 1.2 版本。 TLS 是什么？ TLS（Transport Layer Security，安全传输层协议）用于在两个通信应用程序之间提供保密性和数据完整性。 诶这不是跟 SSL（Secure Socket Layer，安全套接层）很像吗？ SSL 是基于 HTTPS 下的一个协议加密层，起初是因为 HTTP 在传输数据时使用的是明文（虽然说 POST 提交的数据时放在报体里看不到的，但是还是可以通过抓包工具窃取到）是不安全的，为了解决这一隐患 Netscape 公司推出了 SSL 安全套接字协议层，SSL 是基于 HTTP 之下 TCP 之上的一个协议层，是基于 HTTP 标准并对 TCP 传输数据时进行加密，所以 HPPTS 是 HTTP+SSL/TCP 的简称。 由于 HTTPS 的推出受到了很多人的欢迎，在 SSL 更新到 3.0 时，IETF 对 SSL 3.0 进行了标准化，并添加了少数机制（但是几乎和 SSL 3.0 无差异），标准化后的 IETF 更名为 TLS 1.0，可以说 TLS 就是 SSL 的新版本3.1。 TLS 与 SSL 连接过程其实无任何差异。 SSL 与 TLS 两者所使用的算法是不同的，SSL 使用的是 MAC 哈希算法，TLS 使用的是 RFC-2104 定义的 HMAC 算法，两者差异是在填充字节与密钥之间一个使用的是连接运算，一个使用的是异或运算，MAC 和 HMAC 在取值范围也是不同的，但是安全度是相同的。 SSL 可以分为两个协议，SSL 记录协议（SSL Record Protocol）为 TCP 协议在通信提交数据时提供数据封装、压缩、加密等基本操作，SSL 握手协议（SSL Handshake Protocol）建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 TLS 与 SSL 的两个协议工作方式与 SSL 是一样的。 SSL 所使用的版本为 3.0，版本号也为 3.0.x（x 代表未知数因为 SSL 还在更新），而 TLS 版本为 1.0，但版本号却为 SSL 3.1.0。 TLS 增加了许多新的报警代码，比如解密失败（decryption_failed）、记录溢出（record_overflow）、未知 CA（unknown_ca）、拒绝访问（access_denied）等，但同时也支持 SSL 协议上所有的报警代码。 简单来说，TLS 就是在 SSL 的基础上做了少许升级。 抛书包抛了这么久，还是回到项目问题上，由于微信小程序需要支持 TLS 1.2，那么只在服务器上绑定了普通的 SSL 证书，就会导致小程序无法正常运行。 要解决这个问题，首先要确定操作系统环境是否支持 TLS 1.2，参考一下表格： 之前在『IIS 7 为多个域名绑定证书』里也提到，我们服务器的环境是 Windows Server 2008 R2 Enterprise，刚好可以支持 TLS 1.2。 根据网上的说法，十分简单，进入服务器修改注册表即可，于是我把对应注册表的值进行修改。 然后重启 IIS，结果发现并没有成功支持 TLS。 搜寻其他解决方法，找到了一款面向小白的 GUI 工具——『IIS Crypto』。 『IIS Crypto』是一个图形化的 TLS 设置工具。 在服务器上安装好『IIS Crypto』，打开，虽然是全英文的界面，但是看见那几个关键词就大概知道怎么操作了。 它默认已经帮我勾选好 TLS 的三个版本，虽然小程序的官方文档要求最好支持 TLS 1.2 以上的版本，但这里并没有更高版本的选项，不过并不要紧，我们只要能到达 1.2 的版本就够了，当然为了兼容部分旧 Android 机型，把 1.0 和 1.1 的版本也勾上。 然后点击「Apply」，会弹出一个提示框。 仔细阅读提示的内容，发现要求 reboot computer，重启 IIS 的话是没什么问题，但是重启服务器的 Computer，会不会出现什么问题呢，咨询了后端工程师，得到的回复是的确有可能会导致一些不确定的异常，作了一定的衡量之后，既无对策了，就重启吧！ 于是重启后进行检测，使用『GETSSL』的「SSL安装检测工具」检测结果如下： 为了进一步确认，我还找了一个国外的网站进行二次检测，『Qualys SSL Labs』的「SSL Server Test」检测结果如下： 不过「SSL Server Test」的检测结果相对来说比较慢，不知道是需要检测的条目比较多还是什么原因，毕竟我也不是很懂其他条目的作用。 所以最终结果是，TLS 终于设置成功了。 过后想一想，其实之前修改注册表的方法应该也是可以的，只不过我按照网上的说法只是重启了 IIS，而没有重启服务器 Computer，所以导致修改的注册表没有生效，当然也没有验证这个想法，总不能在生产环境中去试验这些东西吧。 ","link":"https://LiarrDev.github.io/post/Configuring-TLS-1_2-in-IIS-7/"},{"title":"IIS 7 为多个域名绑定证书","content":"IIS 7 并不支持为不同域名绑定不同的证书。解决方法就只有两个了，一是升级 IIS 8，二是重新申请一个通配的泛域名 SSL 证书。 升级 IIS 8 也不是一件简单事，因为目前的 IIS 7 是在 Windows Server 2008 R2 Enterprise 上面跑的，如果想升级到 IIS 8，则需要把服务器也升级到 Windows Server 2012，这相当于重装服务器的系统。 通配泛域名 SSL 证书在阿里云上的定价也不便宜。 于是抱着试一试的心态找了找免费的证书颁发机构，结果有心栽花花不开，无心插柳柳成荫，还真让我找到了一个。 Let's Encrypt 『Let's Encrypt』是国外一个公共的免费 SSL 项目，由 ISRG 联手组成证书颁发机构，可以签发免费 SSL/TLS 证书。ISRG（Internet Security Research Group，互联网安全研究小组）是一个关注网络安全的公益组织，其赞助商从非商业组织到财富 100 强公司都有，包括 Mozilla、Akamai、Cisco、Facebook、University of Michigan 等等。 『Let's Encrypt』是为普及 HTTPS 而发起的，它推动了基础 DV SSL 证书的普及。其证书已经被 Mozilla、Google、Microsoft 和 Apple 等主流浏览器支持，只需要 Web 服务器配置好 HTTPS 证书，浏览器会在加载时验证 Web 服务器 HTTPS 证书是否有效。随着 HTTPS 的普及，『Let's Encrypt』目前已成为全球最受欢迎的免费 SSL 证书签发机构。 『Let's Encrypt』的优点有两个：完全免费，避免 ISP 劫持；申请速度快、无需注册账户。 但是有两点也需要注意： 『Let's Encrypt』的基础 DV SSL 证书，只提供了数据加密，不验证身份，无法向用户证明网站的所有者。但即使这样也满足了基本需要了。 『Let's Encrypt』一次只会颁发 3 个月有效期的证书，到期之后需要自己再续上（仍然是免费的）。 既然有了可以免费使用的 SSL 申请机构，那就申请这个免费的泛域名 SSL 证书吧。 Cerbot 『Let's Encrypt』官网引导我们进入『Certbot』进行操作。 不过十分尴尬的是，我看了半天不知如何下手，然后上网查了一圈发现，大神们都是用代码命令来完成这个繁琐的操作的，让我望而却步。 Certify 绝望中又找到了一个可以获取『Let's Encrypt』免费 SSL 证书的软件 —— 『Certify』。 『Certify』是一个可以自动续订『Let's Encrypt』颁发证书的第三方 GUI 软件，使用它可以自动配置、创建和自动续订证书，并且到快要续订的时候会自动发邮件通知我们。 看到没看到没？它说 GUI！图形用户界面！简直小白福音了好吗？ 首先将『Certify』下载到服务器上并安装，注意其依赖 Microsoft .NET Framework 4.5，安装时可能会收到相关提示。 第一次启动程序时会弹出对话框让我们填写个邮箱地址，等证书快要过期的时候我们会收到续订证书的提醒邮件。 然后进到主界面点击左上角的「新建证书」，在「Certificate Domains」中，『Certify』会自动扫描 IIS 中的站点，选择我们要申请证书的域名，在「添加域名」一栏中填写泛域名，即「*.free.com」。 点击「ADD DOMAINS」，然后『Certify』就会弹出以下提示： 点击确定后，就可以看到下方「要包含的域名或子域名」中出现了「*.free.com」和「free.com」。 然后点击右方「Authorization」中修改「Authorization Settings」中的「验证类型」为「dns-01」，并选择「DNS Update Method」为「(Update DNS Manually))」。 这一步我本来想选的是「Aliyun (Alibaba Cloud) DNS API」，因为阿里云毕竟在国内，升级的话总会方便一点，但是发现选择这一项后它要求我填写「DNS Zone Id」，由于不知道这一项怎么填写，所以我还是选了「(Update DNS Manually)」。 然后就可以点击「请求证书」了。 但是，可能会发现遇到 Pause 的情况，这时候就会收到邮件，域名解析需要添加两条 TXT 记录，收到邮件后在阿里云管理控制台中填上去了再次请求证书，就通过了。 待其执行完毕后，返回『Certify』的首页面可以看到站站点已经成功使用了『Let's Encrypt』的证书了。 这时候打开『Internet信息服务（IIS）管理器』就会发现，『Certify』已经自动帮我们绑定好证书了，真是太人性化了，最后再打开 HTTPS 的网站查看一下，正常打开，完美。 SSL For Free 不想下载软件的可以尝试一下『SSL For Free』这个网站，它也是一个可以获取『Let's Encrypt』免费 SSL 证书的网站。 虽然是全英文的网站，但『SSL For Free』这个网站对于小白的我来说已经是非常友好了，首先填写好泛域名，比如我要申请几个类似「*.free.com」的域名，则需要在上方填写「free.com *.free.com」，即需要在输入框输入根域名空格再输入“*.域名”。 与上面步骤类似，域名解析需要添加两条 TXT 记录，进入阿里云管理控制台添加即可。 Something Else... 证书需要推送到「负载均衡（SBL）」中，在阿里云的管理控制台中将其推送即可。 在 Windows「运行」中输入 mstsc 可远程连接服务器桌面。 在 Windows 服务器「运行」中输入 iisreset /stop 以停止 IIS 服务。 在 Windows 服务器「运行」中输入 iisreset /start 以启动 IIS 服务。 ","link":"https://LiarrDev.github.io/post/IIS-7-Binding-Certificates-for-Multiple-Domains/"},{"title":"Android Menu 的样式定制","content":"其实做原生 Android 开发这么久，对 Android 的原生控件还是比较满意的，毕竟 Material Design 也不是吃素的，但是目前不太满意的地方可能就是 Menu 了。 原生 Menu 的默认样式其实和其他控件一样，都是十分简约的。 可以发现，默认的 Menu 当 Item 折叠的时候，下拉的 Menu 是会把 Toolbar 挡住的，虽然这并不影响我们的使用，但是却和我们既有的交互习惯相悖，而且默认的白色背景也和我们的主题颜色不搭，所以我们需要根据我们的需要定制。 但定制的时候，你会发现定制的方式比其他控件要相对繁琐，不像其他控件一样，只需要到相应的 layout 文件中修改控件的属性即可，它还需要修改其 values 文件并在 layout 中引用才行。 首先修改「styles.xml」文件，添加一个 &lt;style&gt; 定义其 Style 属性： &lt;resources&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight.NoActionBar&quot;&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;actionOverflowMenuStyle&quot;&gt;@style/OverflowMenu&lt;/item&gt; &lt;/style&gt; &lt;style name=&quot;OverflowMenu&quot; parent=&quot;Base.Widget.AppCompat.PopupMenu.Overflow&quot;&gt; &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;android:popupBackground&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; 其中 overlapAnchor 是用来修改 Menu 悬浮位置的，默认为 TRUE，当为 FALSE 的时候则不遮挡 Toolbar。 如果使用的是 Toolbar 而不是默认的 ActionBar，则不要忘了在 Toolbar 控件中添加 app:popupTheme 属性： &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;?attr/colorPrimary&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/OverflowMenu&quot; /&gt; 为了符合 Material Design 以及开发方便需要，十分建议使用 Toolbar 而不是 ActionBar，在定制 Menu 这个场景中，如果使用 ActionBar 则还需要使用比较繁琐的方法手动修改 Menu 中的字体颜色，而 Toolbar 只需定义好其主题即可自动修改。 android:popupBackground 则是用来修改下拉 Menu 时的背景颜色，默认是深灰色，我这里则把它设置为与 Toolbar 一样，这样会比较和谐。 Toolbar 上的 Menu 我们一般都会为其设置 ICON，因为用户对图形的感知会强于文字，所以 ICON 很重要，但是 Menu 默认情况下只会在 Toolbar 上显示 ICON，而下拉则仅显示文字，这就十分不友好了，甚至还浪费了美工的设计成果，必须要改。 但是这个居然在样式文件中是不能直接设置的，需要到 Activity 中通过反射设置其显示。 @Override public boolean onMenuOpened(int featureId, Menu menu) { if (menu != null) { if (menu.getClass() == MenuBuilder.class) { try { Method method = menu.getClass().getDeclaredMethod(&quot;setOptionalIconsVisible&quot;, Boolean.TYPE); method.setAccessible(true); method.invoke(menu, true); } catch (Exception e) { e.printStackTrace(); } } } return super.onMenuOpened(featureId, menu); } 这样，就能够将 ICON 和文字同时显示出来了。 还有在最近的开发中我比较喜欢一体化布局，即 Toolbar 和下方融为一体，虽然不知道 Material Design 是否推崇这种设计方式，但我个人还是觉得挺好看的。 那么就会出现一种情况，Menu 的「More」三个点是默认的，颜色也是跟随默认的主题，那么如果我在项目中想修改它的颜色也会比较麻烦，如下： 我一开始的想法是，会有一个关于 Color 的属性让我可以直接设置，但是怎么找都找不到，无奈之下只能选择其他方式，修改这个默认的图标。 先导入一个喜欢的 ICON，我这里在『Android Studio』中提供的图标库中选择了跟原来相同的「more vert」图标，并修改为合适的颜色。 然后在「styles.xml」文件中添加一个新的 &lt;style&gt;： &lt;resources&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;actionOverflowMenuStyle&quot;&gt;@style/OverflowMenu&lt;/item&gt; &lt;item name=&quot;actionOverflowButtonStyle&quot;&gt;@style/OverflowButtonStyle&lt;/item&gt; &lt;/style&gt; ... &lt;style name=&quot;OverflowButtonStyle&quot; parent=&quot;Base.Widget.AppCompat.ActionButton.Overflow&quot;&gt; &lt;item name=&quot;android:src&quot;&gt;@drawable/ic_more&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; 这里通过指定 actionOverflowButtonStyle 的 Style 设定其图标。 同时，我还想指定 Menu 中的字体颜色，那么我可以添加属性： &lt;resources&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;actionOverflowMenuStyle&quot;&gt;@style/OverflowMenu&lt;/item&gt; &lt;item name=&quot;actionOverflowButtonStyle&quot;&gt;@style/OverflowButtonStyle&lt;/item&gt; &lt;item name=&quot;actionMenuTextColor&quot;&gt;@android:color/white&lt;/item&gt; &lt;/style&gt; ... &lt;/resources&gt; 只需指定 actionMenuTextColor 的颜色即可，我在这里直接指定为白色。 其实 Menu 还有其他可定制的属性，比如背景透明之类的，但都不能直接在 layout 中修改控件属性，所以的确是比较折腾的。 ","link":"https://LiarrDev.github.io/post/Android-Menu-Style-Customization/"},{"title":"WeChat H5 Payment for Android","content":"项目 App 需要做到支付功能，首先接入的是 WeChat Pay。业务逻辑需要，支付功能需要在 WebView 中实现，也就是使用 H5 支付。 我只要写一个搭载 WebView 组件的 Activity 并初始化好相关设置，然后剩下的交给 Web 开发就好了。 首先，想要使用 WeChat Pay 的接口，要先向微信支付商户平台提交申请，因为我们是需要在 H5 中调起微信支付，所以就需要申请 H5 支付的权限，提交申请材料后需要等待 3~5 个工作日后才能知道申请结果，由于是测试版本的原因，内容填写的并不是太完善，但是审核也不是太严格。 接下来就是在 H5 中按照微信官方提供的开发文档来搭建这个支付接口了。 Android 方面，也需要配置一定的代码，直接请求的话会出现以下错误： 微信支付的开发文档有相关的错误描述：商家参数格式有误，请联系商家解决。 官方提供的解决方法如下： 当前调起H5支付的referer为空导致，一般是因为直接访问页面调起H5支付，请按正常流程进行页面跳转后发起支付，或自行抓包确认referer值是否为空 如果是APP里调起H5支付，需要在webview中手动设置referer，如（ Map extraHeaders = new HashMap(); extraHeaders.put(&quot;Referer&quot;, &quot;商户申请H5时提交的授权域名&quot;);//例如 http://www.baidu.com )） 不过这个示例也对小白太不友好了，就这么两行代码，十分考验想象力。 在网上查了下前辈们的做法，得出以下代码： webView.getSettings().setJavaScriptEnabled(true); webView.getSettings().setDomStorageEnabled(true); // 判断为微信支付头则调起微信支付 webView.setWebViewClient(new WebViewClient() { @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { if (url.startsWith(&quot;weixin://wap/pay?&quot;)) { Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.setData(Uri.parse(url)); startActivity(intent); return true; } else { Map extraHeaders = new HashMap(); extraHeaders.put(&quot;Referer&quot;, domain); // 商户申请H5时提交的授权域名 view.loadUrl(url, extraHeaders); } return super.shouldOverrideUrlLoading(view, url); } }); webView.loadUrl(payUrl); 这里重写了 WebViewClient 内的 shouldOverrideUrlLoading(WebView, String) 方法，使其检测 URL 中是否带有微信支付头，即 weixin://wap/pay?，如果是，则调起 WeChat Pay，而在实测中，基本都会跑到这个判断中，而不会跑到下方微信提供的方法，所以暂时不知道其有何作用。 另外，使用 shouldOverrideUrlLoading(WebView, String) 的时候发现该方法被标记为已过时，虽然暂时只是不推荐使用，未被抛弃，不过还是尽快转移到更新的方法上比较好，我在文档中看到有一个相似的方法 shouldOverrideUrlLoading(WebView, WebResourceRequest)，粗略的浏览了一下，似乎还没有人使用该方法替代上面的方法，于是自行尝试了一下，发现可以把上方的代码改写为： @Override public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) { if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) { String url = request.getUrl().toString(); if (url.startsWith(&quot;weixin://wap/pay?&quot;)) { Intent intent = new Intent(); intent.setAction(Intent.ACTION_VIEW); intent.setData(Uri.parse(url)); startActivity(intent); return true; } else { Map extraHeaders = new HashMap(); extraHeaders.put(&quot;Referer&quot;, DOMAIN); // 商户申请H5时提交的授权域名 view.loadUrl(url, extraHeaders); } } return super.shouldOverrideUrlLoading(view, request); } 其实差别也不大，只不过 URL 不能从形参中直接获取而是要从 WebResourceRequest 中获取罢了。 有时候不行可能是因为 Referer 没写进去，可以使用以下方法抓取 Referer： MyWebViewClient myWebViewClient = new MyWebViewClient() { @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { ... Log.d(&quot;===WebViewURL===&quot;, view.getUrl()); // 打印当前页面的 Url Uri ref = getReferrer(); // 抓取 Referer if (ref != null) { Log.d(&quot;====REFERER====&quot;, ref.toString()); } else { Log.e(&quot;====REFERER====&quot;, &quot;NULL&quot;); } return super.shouldOverrideUrlLoading(view, url); } }; ","link":"https://LiarrDev.github.io/post/Wechat-H5-Payment-For-Android/"},{"title":"Android 获取和清除 WebView 中的 Cookie","content":"项目中如果用到了 WebView，那就免不了跟 Cookie 打交道。 比如，你时常需要判断用户的登录状态，如果用户未登录，那就必须限制部分功能的使用。 那么原生 Android 该如何获取 WebView 中的 Cookie 呢？ 我们可以定制一个 WebViewClient 并重写内部的相关方法来实现，并不建议使用匿名类的方式。新建一个类 MyWebViewClient 继承自 WebViewClient，然后重写其 onPageFinished(WebView, String) 方法： public class MyWebViewClient extends WebViewClient { String cookieTag = null; String cookieTel = null; @Override public void onPageFinished(WebView view, String url) { super.onPageFinished(view, url); CookieManager cookieManager = CookieManager.getInstance(); String cookieStr = cookieManager.getCookie(url); try { cookieTag = cookieStr.substring(0, 8); // 确定前缀是不是 phoneNum if (cookieTag.equals(&quot;phoneNum&quot;)) { cookieTel = cookieStr.substring(9, 20); // phoneNum 后面的电话号码 } } catch (Exception e) { e.printStackTrace(); } } public String getCookieTag() { return cookieTag; } public String getCookieTel() { return cookieTel; } } 使用 CookieManager 的 getCookie() 方法来获取存储的 Cookie，这里判断 Cookie 中的前缀是否为 phoneNum，如果是的话证明已经登录，并截取后面 11 位数字为用户的手机号码，然后通过 Getter 来提供传值方法。 然后在 WebView 中配置这个自定义的 WebViewClient： MyWebViewClient myWebViewClient = new MyWebViewClient(); webView.setWebViewClient(myWebViewClient); 接着就可以通过相关的 Getter 方法来获取传值： String tel = myWebViewClient.getCookieTel(); 于是获取 Cookie 的方法就完成了。 有了 Cookie，当用户退出登录时，我们也需要清除 Cookie： logOutBtn.setOnClickListener(v -&gt; { CookieSyncManager.createInstance(this); CookieSyncManager.getInstance().startSync(); CookieManager.getInstance().removeSessionCookie(); CookieManager.getInstance().removeAllCookie(); CookieSyncManager.getInstance().sync(); webView.clearCache(true); webView.getSettings().setCacheMode(WebSettings.LOAD_NO_CACHE); webView.loadUrl(loginUrl); // 重新加载登录页面 Intent intent = getIntent(); finish(); startActivity(intent); }); Android 为我们提供了很多与清除 Cookie 相关的操作，我基本都写上去了，你会发现我在下面销毁了当前 Activity 并重新启动，原因是上面清除的是本地的 Cookie，但有些逻辑我们已经从 Cookie 中获取了值并存储在全局变量中，使某些登录后才能使用的功能即使在清除 Cookie 后依然可以使用，所以销毁当前 Activity 可以把依附该 Activity 上的变量或引用随着 Activity 的生命周期而消亡。 当然也可以通过其他的逻辑避免这个问题，不过我觉得会复杂很多，不如这个方法用得方便。 ","link":"https://LiarrDev.github.io/post/Get-and-Clear-Cookies-in-WebView/"},{"title":"Android 使用 Dialog 样式的 Activity","content":"项目中遇到一个需求，需要在 Service 中弹出 Dialog 以显示消费信息，但是 Dialog 需要依附于一个 Activity，但是当用户退出应用之后，该应用的 Activity 就已全部销毁，所以在 Service 中弹出的 Dialog 也就没有了可以依附的 Activity 了。 网上普遍是将这个应用的 Dialog 设置成一个系统级的 Dialog，即一个全局性质的提示框，这样，无论它现在处于何种界面之下，只要调用 show() 就可以弹出提示框了。 该方法由于配置起来相对麻烦，而且各大厂商的权限管理各不相同，于是我改用了一种更为简单粗暴的方法——直接从 Service 中弹出 Activity，Activity 为我们提供了多种主题，我们只需选择一个弹窗类型的主题即可。 首先创建一个新的 Activity，然后在「AndroidManifest.xml」中修改这个 Activity 的主题： &lt;activity android:name=&quot;.DialogActivity&quot; android:theme=&quot;@style/Theme.AppCompat.Light.Dialog.Alert&quot; /&gt; 其实 Dialog 主题也挺多的，有美有丑，得益于 IDE 的智能提醒，输入“Dialog”就列出了一大堆，我也懒得一个个试了，挑了两三个看下效果，发现最好看就是上面这个，所以就选它了。 然后开始写布局文件，虽然是 Dialog 样式，但只需按照平常写 Activity 布局的习惯来写即可。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:padding=&quot;10dp&quot; tools:context=&quot;.DialogActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/dialog_message&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;15dp&quot; /&gt; &lt;Button android:id=&quot;@+id/dialog_positive_button&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot; android:background=&quot;@color/colorPrimary&quot; android:text=&quot;确定&quot; android:textColor=&quot;#FFFFFF&quot; /&gt; &lt;/LinearLayout&gt; 布局十分简单，一个纵向线性布局，里面就一个文本显示框和一个按钮，宽度都填满父视图，高度则包裹该组件，这应该是多年 Windows 系统以及多种操作系统和应用达成的一种不成文的共识，使我们作为用户也形成了固有的印象。 最后就是逻辑代码实现了，同样极其简单，就像平常写 Activity 的逻辑一样。 public class DialogActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_dialog); TextView dialogMessage = (TextView) findViewById(R.id.dialog_message); String details = getIntent().getStringExtra(&quot;dialogMessage&quot;); dialogMessage.setText(details); Button dialogPositiveButton = (Button) findViewById(R.id.dialog_positive_button); dialogPositiveButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { finish(); } }); } } 获取到 TextView 和 Button 的实例，TextView 通过 getIntent() 获取 Service 中传过来的内容并显示，而 Button 则负责关闭这个 Activity。 实际效果如下： ","link":"https://LiarrDev.github.io/post/Android-Activity-with-Dialog-Theme/"},{"title":"Android 为 WebView 重写 Back 键","content":"现在很多 App 上许多内容都采用 WebView 来展示 H5 内容，以减少开发时间和开发成本，但是这也就遇到了一个问题。 在 Android 应用中，是以栈来展示不同的 UI 界面的，栈的概念相信学过开发的人都不会陌生，先进后出嘛。 但是，WebView 相当于一个浏览器容器，是嵌在一个 Activity 中的，所以遇到的问题就是，当应用检测到用户触摸 Back 键时，会把这个 Activity 从栈中移除，也就是说，如果我在第一个 Activity 中使用 WebView 的话，无论用户在这个 WebView 中进行了什么操作，只要触摸 Back 键，就相当于退出程序。 这显然不是我们想要的。 我们可以通过重写 Back 键的响应方法，让程序监测到当用户触摸 Back 键时，如果 WebView 能够返回，则使网页返回上一页，如果没有上一页，则按照正常的 Back 键逻辑操作。 方法一，重写 onKeyDown() 方法，代码如下： @Override public boolean onKeyDown(int keyCode, KeyEvent event) { if(keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; webView.canGoBack()) { webView.goBack(); return true; } return super.onKeyDown(keyCode, event); } 监测当 keyCode 为 Back 键并且网页可回退时则使网页返回。返回值在这里表示是否能完全处理该事件，在此处返回 TRUE，以防止此事件被进一步传播，如果返回 FALSE，则表示还没有处理完这个事件，它应该继续传播到其他监听。 方法二：重写 onBackPressed() 方法，代码如下： @Override public void onBackPressed() { if (webView.canGoBack()) { webView.goBack(); } else { super.onBackPressed(); } } 需要注意的是，super.onBackPressed() 会自动调用 finish() 方法，关闭当前 Activity，所以这里放在 ELSE 分支执行，即当网页不可回退的情况下销毁当前 Activity。 这两个方法其实大同小异，都是先使用 WebView.canGoBack() 方法来判断网页是否可以回退，如果可以的话就执行 WebView.goBack() 使其返回上一页，如果不可以回退，则调用父类的方法，销毁当前 Activity，唯一的区别就是，onKeyDown() 方法监听的是手机上所有按键，然后再在该方法内部进行判断是否为 Back 键，而 onBackPressed() 方法则仅监听 Back 键。 当然，这样还会遇到一个交互十分不友好的情况，就是如果用户在 WebView 中进行了多步操作，当用户想要退出应用时，需要连续点击多次 Back 键，使 WebView 中的网页回到最开始的页面才能退出。 对于这种情况，我的做法是在 Toolbar 上添加一个一键退出的按钮，直接把这个 Activity 给 finish() 掉，这也是目前大多数 App 使用的方案。 ","link":"https://LiarrDev.github.io/post/Override-Key-BACK-for-WebView-in-Android/"},{"title":"一次实战爱上『Glide』","content":"最近写了一个单机版的商城项目『HacppleStore』，涉及到了商品展示等内容，需要加载大量图片，因为我是使用原生 Android 进行开发，而不是像现实中大多数商城一样使用 H5 加载，所以图片的加载与存储就会在本地进行。 另外，我还希望能够对图片的操作更加简便，并且最好能对图片进行一定的压缩处理，以提高性能。 根据从『第一行代码——Android』学来的经验，我首先就想到了『Glide』。 『Glide』是一个被 Google 所推荐的图片加载库，由 bumptech（Bump Technologies）开发。这个库被广泛运用在 Google 的开源项目中，包括 2014 年的 Google I/O 大会上发布的官方 App。 提到『Glide』就不得不提提『Picasso』了，『Glide』是 Google 员工的开源项目（这也解释了为什么 Google 如此推荐它），是基于『Picasso』的一个图片加载框架。 那『Picasso』又是啥？ 还记得在『一次实战爱上「OkHttp」』中提到的 Square 吗？除了『OkHttp』以外，Square 还开发了许多实用的开源框架，Square 出品必属精品，『Picasso』就是其一。 敢于冠上毕加索之名，相信也不会太差，主要特点就是使用简单，扩展性强，支持各种来源的图片，包括网络、Resources、Assets、Files、Content Providers 等。内部集成了『OkHttp』的网络框架，所以如果项目中使用了 Square 公司的其他框架，那么就更推荐使用『Picasso』了。 由于『Glide』在『Picasso』基础上进行的二次开发的，所以两者有近 90% 的相似度，而其优势也是显而易见的。 当然，『Picasso』我目前仅仅简单了解，并未深入学习，由于『Glide』的易用性我一直使用的都是『Glide』，所以如果以后闲下来有机会深探『Picasso』的时候可以单独唠一唠。 『Glide』的代码风格与『Picasso』非常相似，增加了更多的功能，非常重要的就是支持 GIF，当然它的包会大一些。 Glide 是滑行的意思，可以看出这个库的主旨就在于让图片加载变的流畅。它不仅可以用于加载本地图片，还可以加载网络图片、GIF 图片、甚至是本地视频。我只能用超级强大这个词来形容它了。 吹完『Glide』的优点，就直接介绍用法吧。 第一件事依然是添加依赖： dependencies { implementation 'com.github.bumptech.glide:glide:(insert latest version)' } 『Glide』的用法非常简单，使用简明的流式语法 API，它允许你在大部分情况下只需一行代码就能轻松实现复杂的图片加载功能： Glide.with(context).load(url).into(imageView); 这就是『Glide』一个完整的请求至少需要的三个参数，with() 中传入一个 Context、Activity 或 Fragment，然后调用 load() 方法去加载图片，可以是一个 URL 地址，也可以是一个本地路径，或者是一个资源 ID，最后调用 into() 方法将图片设置到具体某一个 ImageView 中就可以了。 在『HacppleStore』的开发中，我惊讶的发现，『Glide』还支持对二进制图片的加载，这就使我们的开发更加方便了。 在『一次实战爱上「LitePal」』一文中，我把图片存储在了『SQLite』中，当读取出来加载时，也经历了不少麻烦的操作。 一开始我是使用原生的写法，将二进制图片转为 Bitmap 再进行加载。 ImageView goodsImageView = (ImageView) findViewById(R.id.goods_image_view); byte[] goodsImg; List&lt;Goods&gt; goods = LitePal.where(&quot;name = ?&quot;, goodsName).find(Goods.class); for (Goods good: goods) { goodsImg.setImageBitmap(BitmapFactory.decodeByteArray(good.getImage(), 0, good.getImage().length)); } 而后来查阅文档后发现，使用『Glide』不用进行转换就可以一步到位。 ImageView goodsImageView = (ImageView) findViewById(R.id.goods_image_view); byte[] goodsImg; List&lt;Goods&gt; goods = LitePal.where(&quot;name = ?&quot;, goodsName).find(Goods.class); for (Goods good: goods) { goodsImg = good.getImage(); Glide.with(this).load(goodsImg).into(goodsImageView); } 当然，『Glide』也是可以加载 Bitmap 的，只不过在这个场景下，由于其强大的 API，所以我并不需要做多余的操作。 当然，除了加载图片方便这个原因，『Glide』还有一个特点让我坚持使用，因为我使用的很多图片像素都非常高，如果不进行压缩就直接展示的话，很容易就会引起内存溢出。而使用『Glide』就完全不需要担心这回事，因为『Glide』在内部做了许多非常复杂的逻辑操作，其中就包括了图片压缩，我们只需安心按照它的标准用法去加载图片即可。 『Glide』默认的 Bitmap 格式是 RGB_565，值得一提的是，『Picasso』用的是 ARGB_8888，所以总体来说，『Glide』加载的图片在质量上不如『Picasso』。 但是由于手机屏幕尺寸的限制，用户往往很难察觉出这种差别，所以『Glide』的优势就展现出来了。 你以为我说的优势是对用户眼睛的欺骗？并不是。 『Glide』加载的 RGB_565 格式的图片仅仅消耗『Picasso』ARGB_8888 格式图片一半的内存： 当然，由于条件不一样，所以这样对比也并不太妥当。但是『Glide』同样支持把图片的格式转换为 ARGB_8888，那就公平的来比一次吧。 修改是全局修改，即整个项目使用『Glide』都会自动转换为 ARGB_8888。 首先自定义一个全局的 GlideModule： public class GlideConfiguration implements GlideModule { @Override public void applyOptions(Context context, GlideBuilder builder) { // Apply options to the builder here. builder.setDecodeFormat(DecodeFormat.PREFER_ARGB_8888); } @Override public void registerComponents(Context context, Glide glide) { // register ModelLoaders here. } } 然后在「AndroidManifest.xml」中配置：. &lt;meta-data android:name=&quot;packagename.MyGlideModule &quot; android:value=&quot;GlideModule&quot;/&gt; 之后就可以在项目中按照标准方式使用了。 这种方法优点是一次设置，全局使用，十分方便，但是缺点也十分明显，所有加载的图片都使用高质量会大大增加内存的消耗，有些得不偿失。 当然还有第二种方法，我打算放到下文再讲。 按照第一种方法设置成功后可以看下对比图： 图片质量是一模一样的。 再看看两者之间的内存消耗： 虽然用的图片格式一样，并且『Glide』加载的几乎是先前的两倍内存，但是『Picasso』消耗的内存仍然远大于『Glide』。 其原因在于两者的加载方式不同，上方图片原尺寸是 1920×1080 像素，加载到 768×432 像素的 ImageView 中，『Picasso』使用的方法是加载了完整尺寸的图片进入内存，当绘图的时候，让 GPU 即时的恢复到所需要的尺寸，然而『Glide』则加载精确的 ImageView 尺寸进入内存，所以避免了内存损耗。 『Glide』还可以取消图片的加载： Glide.with(context).clear(imageView); 不过该方法并不常使用，因为图片会跟随 Context 的生命周期消亡而消亡的。 接下来可以谈谈『Glide』其他的一些用法了。 先说前文提到的修改图片质量。 『Glide』使用注解处理器生成一个流式 API，其目的一是为了更好地扩展自定义选项，其二是为了方便打包常用选项组。 使用 Generated API 仅仅需要两步。第一步，依然是添加依赖： dependencies { annotationProcessor 'com.github.bumptech.glide:compiler:(insert latest version)' } 第二步，我们需要创建一个类继承 AppGlideModule，并为该类添加 @GlideModule 注解。 import com.bumptech.glide.annotation.GlideModule; import com.bumptech.glide.module.AppGlideModule; @GlideModule public class ExampleAppGlideModule extends AppGlideModule {} AppGlideModule 虽然是抽象类，却可以不用重写任何方法。但必须使用 @GlideModule 注解标记该类，否则没法顺利的生成 GlideApp的API，因为该 Module 将不会被『Glide』发现。 第一次添加 AppGlideModule 或者对 AppGlideModule 做了某些修改时，我们需要重新构建项目重新生成 API。如果『Android Studio』没法自动完成构建，可以使用「Make Project」手动重新构建。 生成 API 的默认名为 GlideApp，其包名与所在的 Module 的包名相同，而基本用法也于之前相同，只是将 Glide 替换成了 GlideApp，就可以使用了。 比如上文中的加载图片可以写成： GlideApp.with(context).load(url).into(imageView); 而修改图片质量则写成： GlideApp.with(context).load(url).format(PREFER_ARGB_8888).into(imageView);. 使用这个方法可以单独在一个加载项中设置想要的图片质量，而不用去全局设定，可以大大的减少内存占用。 另外，『Glide』允许用户使用这种方法指定三种不同类型的占位符，分别在三种不同场景使用。 其中，Placeholder 是当请求正在执行时被展示的 Drawable。当请求成功完成时，Placeholder 会被请求到的资源替换。如果被请求的资源是从内存中加载出来的，那么 Placeholder 可能根本不会被显示。如果请求失败并且没有设置 Error，则 Placeholder 将被持续展示。类似地，如果请求的 url/model 为 null，并且 Error 和 Fallback 都没有设置，那么 Placeholder 也会继续显示。 Error 在请求永久性失败时展示。Error 同样也在请求的 url/model 为 null，且并没有设置 Fallback 时展示。 Fallback 在请求的 url/model 为 null 时展示。设计 Fallback 的主要目的是允许用户指示 null 是否为可接受的正常情况。例如，一个 null 的个人资料 URL 可能暗示这个用户没有设置头像，因此应该使用默认头像。然而，null 也可能表明这个元数据根本就是不合法的，或者取不到。默认情况下『Glide』将 null 作为错误处理，所以可以接受 null 的应用应当显式地设置一个 Fallback。 使用方法如下： GlideApp.with(context) .load(url) .placeholder(R.drawable.placeholder) .error(R.drawable.error) .fallback(R.drawable.fallback) .into(imageView); 『Glide』还为我们提供了过渡效果，允许定义如何从占位符到新加载的图片，或从缩略图到全尺寸图像过渡。 由于版本的升级，『Glide』将不会默认应用交叉淡入或任何其他的过渡效果，每个请求必须手动应用过渡。使用方法如下： Glide.with(context) .load(url) .transition(DrawableTransitionOptions.withCrossFade()) .into(imageView); TransitionOptions 用于给一个特定的请求指定过渡，而不同的资源类型能决定使用什么类型的过渡选项。Bitmap 和 Drawable 可以对应使用使用 BitmapTransitionOptions 或 DrawableTransitionOptions 来指定类型特定的过渡动画。对于 Bitmap 和 Drawable 之外的资源类型，可以使用 GenericTransitionOptions。 『Glide』提供了变换功能，在获取到请求的图片之后，能对图片进行一些处理，例如：裁剪、模糊等；而它的强大在于可以自定义，这样一来不仅能处理 Bitmap，同样可以用于处理 GIF 动画和自定义资源类型。 使用方法如下： Glide.with(context) .load(url) .apply(fitCenterTransform()) .into(imageView); 如果使用 Generated API，那么这些变换方法已经被内联了，所以使用起来甚至更为轻松： GlideApp.with(context) .load(url) .fitCenter() .into(imageView); 不过我个人更倾向于在编写布局文件的时候就设置 ImageView 的 ScaleType 属性，这样能使界面和逻辑更好的区分开来。 同时，我们还可以对图片的大小进行修改： GlideApp.with(context) .load(url) .override(width, height) // 单位是 px .into(imageView); 前文提到，加载 GIF 图是『Glide』比较特别的功能之一，而且使用起来同样十分简单： Glide.with(context) .load(gifUrl) .placeholder(R.drawable.placeholder) .error(R.drawable.error) .into(imageView); 如果希望加载 GIF 时只加载 GIF 的第一帧，把 GIF 当作普通图片一样加载，那么只需要做如下修改即可： Glide.with(context) .load(gifUrl) .asBitmap() .error(R.drawable.error) .into(imageView); 如果希望加载的只是 GIF 图，如果不是 GIF 就显示错误图片，则： Glide.with(context) .load(gifUrl) .asGif() .error(R.drawable.error) .into(imageView); 上面还提到了缩略图，再来看看缩略图的加载方法： Glide.with(context) .load(url) .thumbnail(0.1f) .into(imageView); 这里传入一个浮点数，它代表尺寸的倍数。比如我传了 0.1f 作为参数，那么『Glide』则会显示原图大小的 10%。如果原图的尺寸是 1000×1000 像素，那么缩略图就是 100×100 像素。由于缩略图会比 ImageView 要小许多，所以要确保一个准确的缩放比例。 最后再说一个非常强大但却使用得比较少的功能，就是上方提到的加载视频，因为作为一个图片加载库可以加载视频的确是很强大，只不过很多人都不会用它来加载视频。 Glide.with(context) .load(Uri.fromFile(new File(filePath))) .into(view); 『Glide』只能加载本地视频，网络视频或其他途径获得的视频是无效的。 据开发者统计，『Glide』提供了两千多个方法，相信数量还在增加，所以，就不一一介绍了，上方提到的方法应该算是比较经典的，如果有需要还是靠官方文档吧。 更值得一提的是，『Glide』有中文文档！ ","link":"https://LiarrDev.github.io/post/Enjoy-Glide-in-One-Shot/"},{"title":"一次实战爱上『LitePal』","content":"『SQLite』是一款轻量级的关系型数据库，是遵守 ACID 的关系型数据库管理系统，它包含在一个相对小的 C 库中。它的设计目标是嵌入式的，而且目前已经在很多嵌入式产品中使用了它，在嵌入式设备中，它的运算速度非常快，占用资源很少，通常只需要几百 KB 的内存就足够了，它实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎，因而特别适合在移动设备上使用。『SQLite』是在世界上最广泛部署的 SQL 数据库引擎，它的源代码不受版权限制。 一个完整的『SQLite』数据库是存储在一个单一的跨平台的磁盘文件，这也为其便携性提供了良好的条件。而且『SQLite』不仅支持标准的 SQL 语法，还遵循了数据库的 ACID（指数据库事务正确执行的四个基本要素。包含：Atomicity &lt;原子性&gt;、Consistency &lt;一致性&gt;、Isolation &lt;隔离性&gt;、Durability &lt;持久性&gt;。一个支持 Transaction &lt;事务&gt; 的数据库，必须要具有这四种特性，否则在 Transaction processing &lt;事务过程&gt; 当中无法保证数据的正确性，交易过程极可能达不到交易方的要求）事务，所以只要以前使用过其他的关系型数据库，就可以很快地上手『SQLite』。 而『SQLite』又比一般的数据库要简单得多，它甚至不用设置用户名和密码就可以使用。Android 正是把这个功能极为强大的数据库嵌入到了系统当中，使得本地数据持久化的功能有了一次质的飞跃。 抛完书包来看看在 Android 中『SQLite』的使用方式。 一开始我依然是坚持原生的写法，Android 为了让我们能够更加方便地管理数据库，专门提供了一个 SQLiteOpenHelper 帮助类，借助这个类就可以对数据库进行创建和升级。 由于 SQLiteOpenHelper 是一个抽象类，这就意味着如果想要使用它的话就需要创建一个自己的帮助类去继承它。 public class DatabaseHelper extends SQLiteOpenHelper { public static final String CREATE_TABLE = &quot;CREATE TABLE TABLE_NAME (&quot; // TABLE_NAME 是表名 + &quot;ID integer primary key autoincrement, &quot; // integer 对应 int 类型 + &quot;NAME text, &quot; // text 对应 String 类型 + &quot;PRICE real)&quot;; // real 对应 double 类型 private Context mContext; /** * @param context 上下文，必须存在才能进行数据库操作 * @param name 数据库名 * @param factory 允许在查询数据的时候返回一个自定义的 Cursor，一般传入 null 即可 * @param version 当前数据库版本号，可用于对数据库进行升级操作 */ public DatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) { super(context, name, factory, version); mContext = context; } @Override public void onCreate(SQLiteDatabase db) { db.execSQL(CREATE_TABLE); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {} } 然后在创建数据库的地方进行相应的操作，比如： DatabaseHelper dbHelper = new DatabaseHelper(this, &quot;DATABASE_NAME.db&quot;, null, 1); SQLiteDatabase db = dbHelper.getWriteableDatabase(); 构建一个 DatabaseHelper 对象，并通过构造函数的参数将数据库名指定为 DATABASE_NAME.db，版本号指定为 1，并调用 getWriteableDatabase() 方法，系统会检测当前程序中有没有「DATABASE_NAME.db」这个数据库，如果没有就会创建该数据库并调用 DatabaseHelper 中的 onCreate() 方法，这样 TABLE_NAME 表也就得到了创建，如果系统检测到当前程序中已存在「DATABASE_NAME.db」数据库，就不会再创建一次了。 添加数据操作如下： ContentValues values = new ContentValues(); // 组装第一条数据 values.put(&quot;NAME&quot;, NAME_1); values.put(&quot;PRICE&quot;, PRICE_1); // 插入第一条数据 db.insert(TABLE_NAME, null, value); // 第一个参数是表名，第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值 NULL，第三个参数将表中每个列名以及相应的待添加数据传入的 ContentValues 对象 // 清空 values 中的数据 values.clear(); // 组装第二条数据 values.put(&quot;NAME&quot;, NAME_2); values.put(&quot;PRICE&quot;, PRICE_2); // 插入第二条数据 db.insert(TABLE_NAME, null, values); 更新数据的方式也是十分相似： ContentValues values = new ContentValues(); values.put(&quot;PRICE&quot;, PRICE_3); db.update(TABLE_NAME, values, &quot;NAME = ?&quot;, new String[] { NAME_1 }); 其中第一个参数毫无疑问是表名，第二个参数则是 ContentValues 对象，第三个参数对应的是 SQL 语句中的 WHERE 部分，表示更新所有 NAME 等于 ? 的行，而 ? 则是一个占位符，可以通过第四个参数提供的一个字符串数组为第三个参数中的每个占位符指定相应的内容。 删除数据则更加简单： db.delete(TABLE_NAME, &quot;NAME = ?&quot;, new String[] { NAME_2 }); 查询数据则要复杂一些，要知道 SQL 的全称是 Structured Query Language，翻译成中文就是结构化查询语句，它的大部分功能都体现在“查”这个字上，SQLiteDatabase 中提供了一个 query() 方法用于对数据库进行查询，但是这个方法的参数也是非常复杂，最短的一个方法重载也需要传入 7 个参数： query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy); 第一个参数不用说，当然还是用于指定查询的表名，对应 SQL 中的 FROM TABLE_NAME。第二个参数用于指定查询的列名，对应 SQL 中的 SELECT column_1, column_2，如果不指定则默认查询所有列。第三、四个参数用于约束查询的列，对应 SQL 中的 WHERE column = value，不指定则默认查询所有行的数据，与上方更新与删除类似，第三个参数指定 WHERE 的约束条，第四列为 WHERE 中的占位符提供具体的值。第五个参数用于指定需要 GROUP BY 的列，对应 SQL 中的 GROUP BY column，不指定则表示不对查询结果进行 GROUP BY 操作。第六个参数用于对 GROUP BY 之后的数据结果进行进一步的约束过滤，对应 SQL 中的 HAVING column = value，不指定则表示不进行过滤。第七个参数用于指定查询结果的排序方式，对应 SQL 中的 ORDER BY column_1, column_2，不指定则表示默认的排序方式。 而其他几个 query() 方法的重载其实也大同小异，比如增加了 LIMIT 功能等。 实际使用代码如下： Cursor cursor = db.query(TABLE_NAME, null, null, null, null, null, null); // 查询表中所有数据 if (cursor.moveToFirst) { do { // 遍历 Cursor 对象，取出数据 String name = cursor.getString(cursor.getColumnIndex(&quot;NAME&quot;)); double price = cursor.getDouble(cursor.getColumnIndex(&quot;PRICE&quot;)); // 对数据做相应的逻辑操作 ... } while (cursor.moveToNext()); cursor.close(); } 查询完之后可以得到一个 Cursor 对象，接着调用它的 moveToFirst() 方法将数据的指针移动到第一行的位置，然后进入一个循环当中，去遍历查询到的每一行数据，在这个循环中可以通过 Cursor 的 getColumnIndex() 方法获取到某一列在表中对应的位置索引，然后将这个索引传入到对应的取值方法中，就可以得到从数据库中读取到的数据了。 需要注意，对 SQLite 的操作结束后一定要记得关闭，养成良好的编码习惯，否则在当你尝试导出的时候，有可能会遇到数据库不能正常打开的情况： cursor.close(); db.close(); 虽然 Android 已经提供了很多非常方便的 API 用于操作数据库，不过总会有时候使用起来力不从心，不如 SQL 语言方便，而 Android 也提供了一系列的方法使得可以直接通过 SQL 来操作数据库，完成 CRUD 操作，比如适合于增删改的 execSQL() 方法和适用于查的 rawQuery() 方法。 以上的 API 用起来也算是方便了，包括我在学习 Android 开发前期也是使用上面的方法。 但是当开发经验逐渐积累的时候，就会发现使用这种方法在升级数据库的时候变得十分麻烦，虽然 SQLiteOpenHelper 中提供了 onUpgrade() 方法，但升级的时候依然会出现很多不必要的麻烦，这就终于要进入本文的正题了。 还是来源于《第一行代码——Android》的学习经验，我开始在我的每一个项目中使用『LitePal』这个开源库，『LitePal』是一款开源的 Android 数据库框架，它采用了对象关系映射（ORM）的模式，并将我们平时开发最常用到的一些数据库功能进行了封装，使得易用性要高于 SQLiteOpenHelper。 其实之前一直也没发现，原来『LitePal』的开发者正是《第一行代码——Android》的作者郭霖，不过郭神也是比较谦虚，虽然这是在书中第一个介绍的开源库，但是郭神也只字未提这是他所开发的框架，我也是到后来使用多了而频繁进入其 Github 项目主页才发现了这个真相。 还值得一提的是，郭霖已经维护『LitePal』五年之久了，截至目前，已经发布了 Version 3.x，而我也从 Version 1.x 一直学习到了 Version 3.x，也算是了解其 API 的变化了，另外其在 2018 年就连续更新了两次大版本，Version 3.x 更是分裂成了分别支持 Kotlin 和 Java 的两个项目，除了牛逼我已经找不到其他词来形容了！ 赶紧来看看使用的方法。 首先得在「app/build.gradle」文件中声明依赖，上面也提到，为了更好地兼容 Kotlin 语言，『LitePal』现在不再是一个库了，而是变成了两个库，根据使用的语言不同，引入的库也不同。 如果使用的是 Java，则引入如下配置： dependencies { implementation 'org.litepal.android:java:(insert latest version)' } 如果使用的是 Kotlin，则引入如下配置： dependencies { implementation 'org.litepal.android:kotlin:(insert latest version)' } 如果使用 Version 2.x 及之前版本的话，则引入如下配置： dependencies { implementation 'org.litepal.android:core:(insert version)' } 由于拆分成了两个库，所以在使用 Version 2.x 的项目中，『Android Studio』并不会对『LitePal』进行升级提醒，也就是说『Android Studio』默认把 Version 2.1.0 作为未拆分库前的最新版，而分库后则以项目文档为准，另外，因为我一直都是使用 Java 进行 Android 开发，所以下面的介绍也都用 Java 进行示例。 把『LitePal』成功引入到项目中后，则需要配置 LitePalApplication 了，在「AndroidManifest.xml」中指定 Application 的 android:name，代码如下： &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; package=&quot;com.liar.litepaldemo&quot;&gt; &lt;application ... android:name=&quot;org.litepal.LitePalApplication&quot; &gt; ... &lt;/application&gt; &lt;/manifest&gt; 当然，有时候我们还会为项目配置属于自己的 Application，比如： &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; package=&quot;com.liar.litepaldemo&quot;&gt; &lt;application ... android:name=&quot;com.liar.MyOwnApplication&quot; &gt; ... &lt;/application&gt; &lt;/manifest&gt; 而一个 Application 只能有一个 android:name，这样麻烦就比较大了，但『LitePal』已经为我们考虑了这一点，只需在我们自定义的 Application 中调用『LitePal』提供的方法即可： public class MyOwnApplication extends Application { @Override public void onCreate() { super.onCreate(); LitePal.initialize(this); } ... } 配置完 Application，我们就可以创建数据库了。 对比之前自定义类继承自 SQLiteOpenHelper 并在 onCreate() 方法中编写建表语句来实现的方法，『LitePal』提供的方法十分颠覆却又更加好用。 前面提到『LitePal』采取的是对象关系映射（ORM）的模式，那么什么是对象关系映射呢？简单点说，我们使用的编程语言是面向对象语言，而使用的数据库则是关系型数据库，那么将面向对象的语言和面向关系的数据库之间建立一种映射关系，就是对象关系映射了。 对象关系映射模式赋予了我们一个强大的功能，就是可以用面向对象的思维来操作数据库，而不用再和 SQL 语句打交道。创建一张表，我们应先分析表中应包含哪些列，在『LitePal』中，可以用面向对象的思维来实现，比如我创建一个 Users 表，希望有 name、email、password 三个字段，我就可以定义一个 Users 类来完成这件事情： public class Users extends LitePalSupport { private String name; private String email; private String password; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } 这是一个典型的 Java Bean，在『Android Studio』中可以通过快捷键（Windows 系统中是 Alt+Insert，Mac 系统中是 Command+N）在弹出的菜单中选择「Getter and Setter」并选中所有字段来快速生成，在 Users 类中定义了上述的三个字段，并生成了相应的 Getter 和 Setter 方法，这样表就创建完成了。 需要注意的是，这个类需要继承自 LitePalSupport 类才行，其实『LitePal』进行表管理操作时不需要模型类有任何的继承结构，但是进行 CRUD 操作时就不行了，必须得继承自 LitePalSupport 类，而这个类也是在 Version 2.0.0 中才修改的，在 Version 1.x 中继承自 DataSupport 类。 从 Version 2.0.0 开始，几乎所有的 API 接口全部都变了。但是请不要惊慌，Version 2.0.0 是完全向下兼容的，也就是说，大家不用担心升级之后会出现大量的错误，之前所有的代码都还是可以正常运行的，只是原来旧的 API 会被标识为废弃，提醒大家尽快使用新的 API 而已。 当然，大家也不用一听到所有的 API 都变了就觉得恐慌，虽然我刚过渡版本的时候也有点手足无措，但是阅读了文档之后就发现，其实一切的变更都是有规律可循的，具体下文会继续介绍。 继续来看使用方法，当模型类创建完成后就该配置「litepal.xml」文件了，在 app/src/main/assets 目录下新建「litepal.xml」文件，编辑代码如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;litepal&gt; &lt;dbname value=&quot;HacppleStore&quot; /&gt; &lt;!-- 数据库名称 --&gt; &lt;version value=&quot;1&quot; /&gt; &lt;!-- 数据库版本 --&gt; &lt;!-- 指定所有的映射模型 --&gt; &lt;list&gt; &lt;mapping class=&quot;com.liar.hacpplestore.database.Users&quot; /&gt; &lt;/list&gt; &lt;!-- 设置数据库在 SD 卡中的存储目录 --&gt; &lt;storage value=&quot;liar/database&quot; /&gt; &lt;/litepal&gt; 这里用 &lt;mapping&gt; 标签来声明我们要配置的映射模型类，注意一定要使用完整的类名。不管有多少模型类需要映射，都使用同样的方法配置在 &lt;list&gt; 标签下即可。 &lt;storage&gt; 标签则是用于将数据库保存到 SD 卡，这个功能是在 Version 1.6.0 中加入的，我在一般情况下是不会用到。 将数据库保存到 SD 卡的功能一直呼声是挺高的，不过『LitePal』一开始并没有加入这个功能，因为数据库文件保存到 SD 卡是一件很不安全的事情，这就意味着应用程序的数据将会面临泄露的风险，但是在 Version 1.6.0 开始支持数据加密功能，因此开放将数据库存储到 SD 卡的这个功能也就变得顺理成章了。 其实在绝大多数情况下，我们都是非常不建议将数据库文件保存到 SD 卡的，但是保存到 SD 卡也确实存在着一些好处： 一是方便调试。因为数据库的默认存储路径是在应用的沙盒当中，即使作为开发者的我们也是访问不到的。因此有时候编程出现了问题，但是我们又看不到数据库原文件，调试起来非常不方便。而将数据库文件保存到 SD 卡，我们就可以轻易地访问到了。 二是应用卸载后数据不丢失。由于数据库文件默认存储在应用的沙盒目录当中，一旦应用被卸载了，数据库文件也会一同被清除。如果你想实现这样的功能：应用被卸载了，然后用户又重新安装，依然能够读取到之前的数据，那么就必须将数据库文件保存到 SD 卡。 回到上方的示例，郭神在设计『LitePal』的接口时，永远都会将易用性放在第一位，所以上方示例中的一行代码就已经能够将数据库文件保存到 SD 卡的 liar/database 目录下了。注意不需要将 SD 卡的完整路径配置进去，只需要配置相对路径即可。 另外还有非常重要的一点需要注意，由于从 Android M 开始访问 SD 卡需要申请运行时权限，而『LitePal』中既没有 Activity 也没有 Fragment，所以『LitePal』是不会去帮你申请运行时权限的，因此如果你选择将数据库文件存储在 SD 卡上，那么请一定要确保你的应用程序已经对访问 SD 卡权限进行了运行时权限处理，否则『LitePal』的所有操作都将会失败。 这样就把所有准备工作就做完了，只要进行任意一次数据库操作，「HacppleStore.db」数据库就会自动创建出来了，如： LitePal.getDatabase(); 前面也提到，使用 SQLiteOpenHelper 来升级数据库会遇到非常严重的问题，容易造成数据丢失，当然有经验的程序员可以通过复杂的逻辑控制来避免这种情况，但是维护成本很高。而有了『LitePal』，这些就都不再是问题了，使用『LitePal』来升级数据库非常非常简单，完全不用思考任何逻辑，只需要更改想要更改的内容，然后将版本号加1就可以了。 比如我在上面的 Users 表中增加一个 tel 列，那么我直接修改 Users 类中的代码，添加一个 tel 字段即可： public class Users extends LitePalSupport { ... private String tel; public String getTel() { return tel; } public void setTel(String tel) { this.tel = tel; } ... } 与此同时，我还想添加一张 Orders 表，那么只需新建一个 Orders 类即可： public class Orders extends LitePalSupport { private String orderNum; private String buyerName; private String buyerTel; private String buyerAddress; private String transactionTime; public String getOrderNum() { return orderNum; } public void setOrderNum(String orderNum) { this.orderNum = orderNum; } public String getBuyerName() { return buyerName; } public void setBuyerName(String buyerName) { this.buyerName = buyerName; } public String getBuyerTel() { return buyerTel; } public void setBuyerTel(String buyerTel) { this.buyerTel = buyerTel; } public String getBuyerAddress() { return buyerAddress; } public void setBuyerAddress(String buyerAddress) { this.buyerAddress = buyerAddress; } public String getTransactionTime() { return transactionTime; } public void setTransactionTime(String transactionTime) { this.transactionTime = transactionTime; } } 当改完了所有我们想改的东西，只需要记得将版本号加 1 即可，如果添加了一个新的模型类，因此也需要将它添加到映射模型列表中。修改「litepal.xml」中的代码： &lt;litepal&gt; &lt;dbname value=&quot;HacppleStore&quot; /&gt; &lt;version value=&quot;2&quot; /&gt; &lt;list&gt; &lt;mapping class=&quot;com.liar.hacpplestore.database.Users&quot; /&gt; &lt;mapping class=&quot;com.liar.hacpplestore.database.Orders&quot; /&gt; &lt;/list&gt; ... &lt;/litepal&gt; 运行后就可以发现『LitePal』在内部已经自动帮我们保留了所有数据并完成了升级。 接下来就该介绍 CRUD 了。 其实回观前面的添加数据的方法并不十分复杂，但『LitePal』则把这一切做得更加简单了： Users user = new Users(); user.setName(name); user.setTel(tel); user.setEmail(email); user.setPassword(password); user.save(); 还记得我们在模型类中的 Java Bean 吗？添加数据只需调用 Users 类中的各种 set 方法对数据进行设置，最后再调用从 LitePalSupport 类中继承而来的 save() 方法就能完成数据添加操作了。 更新数据则要比添加数据要稍微复杂一点，因为它的 API 接口比较多，而我最常用的就是 updateAll() 方法： Users user = new Users(); user.setTel(NEW_TEL); user.setPassword(NEW_PASSWORD); user.updateAll(&quot;name = ? and email = ?&quot;, name, email); 这里首先 new 出了一个 Users 实例，然后直接调用 set 方法来设置要更新的数据，最后在调用 updateAll() 方法去执行更新操作。注意 updateAll() 方法中可以指定一个条件约束，和 SQLiteDatabase 中 update() 方法的 where 参数部分有点类似，但更加简洁，不过不指定条件语句的话，就表示更新所有数据。 在使用 updateAll() 方法时，还有一个非常重要的知识点，就是当想把一个字段的值更新成默认值时，是不可以使用上面的方式来 set 数据的。众所周知在 Java 中任何一种数据类型的字段都会有默认值，例如 int 类型的默认值是 0，boolean 类型的默认值是 false，String 类型的默认值是 null，那么当 new 出一个模型类对象时，其实所有字段都已经被初始化成默认值了。因此如果我们向把数据库表中的某 int 类型列的更新成 0，直接调用 setVariable(0) 是不可以的，因为即使不调用这行代码，variable 这个字段本身也是 0，『LitePal』此时是不会对这个列进行更新的。 对于所有想要将为数据更新成默认值的操作，『LitePal』统一提供了一个 setToDefault() 方法，然后传入相应的列名就可以实现了： Users user = new Users(); user.setToDefault(&quot;tel&quot;); user.updateAll(); 这段代码的意思是将所有用户的 tel 都设为 null，虽然实际上我们并不会这样做。因为 updateAll() 方法中没有指定约束条件，因此更新操作对所有数据都生效了。 删除数据也是非常简单的，我最常用的方法是直接调用 deleteAll() 方法： LitePal.deleteAll(Users.class, &quot;tel = ?&quot;, tel); 后面的参数同样用于指定约束条件，应该不难理解。另外如果不指定约束条件，就意味着要删除表中所有的数据，这一点和上面 updateAll() 方法是比较相似的。 还值得一提的是，这个方法在 Version 1.x 中的写法为 DataSupport.deleteAll()，在 Version 2.0.0 中被改成了现在的写法。 又到了查询数据部分，使用了『LitePal』后复杂的查询操作就成为了过去式，『LitePal』在查询 API 方面做了非常多的优化，基本上可以满足绝大多数场景的查询需求，并且代码十分简洁，比如向查询 Users 表中所有数据，代码如下： List&lt;Users&gt; users = LitePal.findAll(Users.class); for (Users user: users) { String name = user.getName(); String email = user.getEmail(); // 对数据做相应的逻辑操作 ... } findAll() 方法的返回值是一个 List 集合，也就是说，我们不用像之前那样再通过 Cursor 对象一行行去取值了，『LitePal』已经自动帮我们完成了赋值操作。 除了 findAll() 方法之外，『LitePal』还提供了很多其他非常有用的查询 API，比如想要查询表中的第一条数据就可以写： Users firstUser = LitePal.findFirst(Users.class); 同样的，查询表中最后一条数据可以这样写： Users lastUser = LitePal.findLast(Users.class); 我们还可以通过连缀查询来定制更多的查询功能，比如： List&lt;Users&gt; users = LitePal.select(&quot;name&quot;, &quot;tel&quot;) .where(&quot;name = ?&quot;, name) .order(&quot;tel desc&quot;) .limit(10) .offset(10) .find(Users.class); 不难理解，select() 方法用于指定查询哪几列的数据，where() 方法用于指定查询的约束条件，order() 方法用于指定结果的排序方式，limit() 方法用于指定查询结果的数量，offset() 用于指定查询结果的偏移量。 上方的这段代码就表示，查询 Users 表中第 11~20 条满足名字为 name（即同名）这个条件的 name 和 tel 这两列数据，并将查询结果按照 tel 降序排列，如果只指定 .order(&quot;tel&quot;) 则按照升序排列。 这些 API 已经足够我们应对绝大多数场景的查询需求了，如果实在有一些特殊需求，上述 API 都满足不了使用的时候，『LitePal』仍然支持使用原生的 SQL 来进行查询： Cursor cursor = LitePal.findBySQL(&quot;SELECT * FROM Users WHERE name = ?&quot;, name); 注意 findBySQL() 方法返回的是一个 Cursor 对象，接下来还需要通过之前的老方式将数据一一取出才行。 同样，上方的 LitePal.***() 方法都是在 Version 2.0.0 中从 DataSupport.***() 中升级过来的。总结一下其实主要就只有两点，如果是在继承结构中使用了 DataSupport，那么就将它改为 LitePalSupport，如果是调用了 DataSupport 中的静态方法，那么就将它改为 LitePal。 在开发项目过程中，我还遇到了需要存储图片的需求，而我查了文档才知道原来『LitePal』在 Version 1.3.1 开始就支持存储图片了。 『LitePal』之前支持存储的数据类型有：int、long、short、float、double、boolean、char、String、Date九种，Version 1.3.1 中引入了第十种数据类型：byte[]。也就是说，只要在 Model 中声明一个 byte[] 类型的字段，这个字段就会被自动映射到数据库表当中了。 byte[]类型的字段灵活性非常高，它可以用来存储图片，但又不仅限于存储图片，任何二进制的数据都是可以存储的，比如一段小语音，或者是小视频，不过依然不建议在手机数据库中存储较大的二进制数据。 首先需要在 Modle 中添加一个相应的字段，比如我用来存储图片： public class Product extends LitePalSupport { private String name; private byte[] image; public String getName() { return name; } public void setName(String name) { this.name = name; } public byte[] getImage() { return image; } public void setImage(byte[] image) { this.image = image; } } 当我存储图片的时候就可以这样写： byte[] imageBytes = getImageBytesFromSomewhere(); Product product = new Product(); product.setName(name); product.setImage(imageBytes); product.save(); 查询的方法也跟上面一致： byte[] imageBytes = product.getImage(); 对于图片的处理就不在此讨论范围了，在以后的项目总结中我会详述这一过程。 我还思考过一个问题，如果我希望在『SQLite』中存储一个 List&lt;Object&gt; 会怎么样，之所以说思考过是因为我在项目中还未遇到过这样的需求，也没有尝试过，但是查看了『LitePal』的文档，发现在 Version 1.4.0 中加入了这个功能。 其实对于 ORM 映射来说，集合数据真的是非常难处理的。首先最基本的 ORM 映射规则就是将 Java 中的类映射成数据库中的表，将 Java 中的字段映射成数据库中的列，然后每一个 Java 对象就对应着数据库表中的一行记录。那么 Java 中的 8 种基本数据类型以及 String 类型当然是非常好处理的，将它们直接存储到对应的列中就可以了。 但集合数据不行，因为集合数据中可能是有任意多条记录的，而每个 Java 对象就只能对应数据库表中的一行记录而已，因此根本没有地方可以去存放集合数据。 而郭神模仿数据库关联表的方式来实现了这个功能。 比如说现在我们的 Album 实体类中有一个集合字段： public class Album extends LitePalSupport { private String name; private List&lt;String&gt; titles = new ArrayList&lt;&gt;(); public String getName() { return name; } public void setName(String name) { this.name = name; } public List&lt;String&gt; getTitles() { return title; } public void setTitles(List&lt;String&gt; title) { this.title = title; } } 这个 titles 集合记录了这张专辑里面有哪些歌名，下面我们将这个 Album 存储到数据库中： Album album = new Album(); album.setName(&quot;范特西&quot;); album.getTitles().add(&quot;爱在西元前&quot;); album.getTitles().add(&quot;双截棍&quot;); album.getTitles().add(&quot;安静&quot;); album.save(); 然后我们去查看 Album 表，你会发现里面就只有 id 和 name 这两列： id name 1 范特西 这也是之前版本『LitePal』表现的行为。而在 Version 1.4.0 中，『LitePal』会额外进行一个操作，就是创建一个 album_titles 表，并将集合中的数据存储在这里，如下所示： titles album_id 爱在西元前 1 双截棍 1 安静 1 可以看到，这里记录了所有集合中的数据，并将这些数据和 album 的 id 进行了关联，从而可以区分出每条数据到底是属于哪一个 Album 对象的。 当然了，这些都是『LitePal』底层的实现原理，我们在使用的时候即使不了解这些原理也完全没问题，因为『LitePal』都将这些功能封装好了。 这样当我们去查询 Album 数据的时候，会自动将它所关联的集合数据一起查出来： Album album = LitePal.findFirst(Album.class); List&lt;String&gt; titles = album.getTitles(); for (String title : titles) { Log.d(TAG, &quot;title is &quot; + title); } 这样就可以把所有 title 都打印出来了。 除了支持 List&lt;String&gt; 集合之外，还有 List&lt;Integer&gt;、List&lt;Boolean&gt;、List&lt;Long&gt;、List&lt;Float&gt;、List&lt;Double&gt;、List&lt;Character&gt; 这几种类型的集合也是支持的。 还有一个常用的功能也是值得介绍的，说其常用，是因为很多情况下都会遇到这么一种情况，如果数据不存在，则存储，如果数据已存在，则更新。其实实现这个功能并不复杂，只需进行一次逻辑判断，然后根据判断的结果进行相应的逻辑处理就可以了： Users user = new Users(); user.setName(name); user.setEmail(email); List&lt;Users&gt; users = LitePal.where(&quot;name = ?&quot;, name).find(Users.class); if (users.isEmpty()) { user.save(); } else { Users users = user.get(0); users.setEmail(user.getEmail()); users.save(); } 可以看到，这里先是通过『LitePal』的查询方法来查一下 Users 表中是不是有 name，如果没有的话，就将 name 保存到表中，如果有的话，就将表中的数据进行更新。 不过，即使将逻辑梳理的很清楚了，不得不承认，上述代码依然有那么一丁点儿繁琐，『LitePal』之前确实是没有什么特别好的办法来处理这种需求。但是懒惰是第一生产力，从 Version 1.5.0 开始，这种需求就再也不是问题了，『LitePal』新增了一个 saveOrUpdate() 方法，专门用来处理这种不存在就存储，已存在就更新的需求： Users user = new Users(); user.setName(name); user.setEmail(email); user.saveOrUpdate(&quot;name = ?&quot;, user.getName()); 没错，就是这么简单。调用 saveOrUpdate() 方法后，『LitePal』内部会自动判断，如果表中已经存在 name 这条记录了，就会自动更新，如果不存在的话，就会自动插入。和刚才前面那段代码相比，省去了绝大部分繁琐的逻辑操作。 最后再介绍一个重磅功能，就是上文提到的数据加密解密功能，这个功能是在 Version 1.6.0 中实现的。 一直以来，我们使用『LitePal』将数据存储到数据库中都是直接以明文形式存储的。虽说各个应用的数据库都是存放在独立的沙盒环境中，无法被其他应用所访问，也无法被用户看到，而且重要的数据我们也基本不会存储在本地，但是如果用户将手机 ROOT 了之后，就可以随意地查看每个应用的数据库文件，所有数据一览无余。 当然，会去 ROOT 手机的用户毕竟在少数，因此大多数情况下，我们可能并不需要考虑这种情况。但是，如果你存储在数据库中的数据真的十分机密，并且要求较高安全性的话，那么最好还是加密一下再存储到数据库当中。 之前的版本不支持数据加密功能，因此如果想要实现这个功能还得靠大家自己去写加解密算法。值得高兴的是，从 Version 1.6.0 开始就不用再这么麻烦了，『LitePal』内置了对数据进行加解密的功能，并且，用法还是一如既往的简单，主要支持 AES 和 MD5 两种加密算法。 AES 加密算法想必大家应该都不会陌生，它的全称是 Advanced Encryption Standard，中文名叫高级加密标准，同时它也是美国联邦政府采用的一种区块加密标准。我们如果使用它来对数据进行加密的话，则可以大大提升数据的安全性。 比如我们有一个 Book 类，类中有一个 name 字段和一个 page 字段，现在我们希望将 name 字段的值进行加密，那么只需要这样写： public class Book extends LitePalSupport { @Encrypt(algorithm = AES) private String name; private int page; // Getter and Setter } 没错，就是这么简单。只需要在 name 字段的上方加上 @Encrypt(algorithm = AES) 这样一行注解即可，其他的任何操作都无需改变，我们原来该怎样存储数据还是怎样存储数据。比如插入一条这样的数据： Book book = new Book(); book.setName(&quot;第一行代码&quot;); book.setPage(500); book.save(); 那么现在我们到数据库中来查看一下这条数据，结果如下图所示： 可以看到，这里书名已经被加密了，我们直接查看数据库将完全无法得知它真实的数据是什么。 更加方便的是，这种 AES 加密只是针对于破解者的一种防护措施，但是对于开发者而言，加解密操作是完全透明化的。也就是说，作为开发者我们并不用考虑某个字段有没有被加密，然后要不要进行解密等等，我们只需要仍然使用标准的『LitePal』API 来查询数据即可，『LitePal』在后台已经默默帮我们做了解密操作了，因此整个加解密工作对于开发者而言都是完全透明的。 另外，可以为 AES 算法来指定一个你自己的加密密钥。使用不同的密钥，加密出来的结果也是不一样的。如果你没有指定密钥，『LitePal』会使用一个默认的密钥来进行加密。因此，尽可以地调用 LitePal.aesKey() 方法来指定一个你自己的加密密钥，这样会让你的数据更加安全。 加密后的数据字段不能再通过 where() 语句来进行查询、修改或删除。也就是说，执行类似于 where(&quot;name = ?&quot;, &quot;第一行代码&quot;) 这样的语句将无法查到任何数据，因为在数据库中存储的真实值已经不是这个值了。 MD5 算法则更常见了，它的全称是 Message Digest Algorithm 5，中文名叫信息摘要算法第五版。要说到 MD5 加密算法的特点其实有很多很多，但是它最为突出的一个特点就是，使用这种加密算法计算出来的结果是不可逆的。通俗点来说，就是 MD5 算法只能进行加密但不能进行解密。 那有的朋友可能会疑惑了，如果数据加密了之后就不能再解密，那我要这个数据还有什么用？然而，实际上确实存在着不少场景是不用对数据进行解密的。 比如说用户的密码，密码就是属于安全性要求非常高的数据，直接将密码的明文存储在数据库中是一件非常危险的事情，因此这种情况下我们一定要对数据进行加密才行。但是如果使用上述的 AES 算法来对密码进行加密可能并不是一个好主意，因为AES加密的数据是可以被解密的，一旦我们的密钥泄漏了出去，所有用户的密码就都有可能被解密出来。 因此，这种情况下使用类似于 MD5 这种不可逆的加密算法才是最好的选择。因为密码这类数据完全不需要解密，验证用户输入的密码是否正确只需要将输入的内容同样使用MD5算法加密一下，然后和数据库中存储的值进行对比就可以了。 用法想必你也已经能猜到了，和前面的 AES 加密几乎是一模一样的用法，我们只需要将 @Encrypt 中指定的加密算法改成 MD5 即可： public class User extends LitePalSupport { @Encrypt(algorithm = MD5) private String password; private String username; // Getter and Setter } 现在使用同样的代码来存储一条数据： User user = new User(); user.setUsername(&quot;guolin&quot;); user.setPassword(&quot;123456&quot;); user.save(); 然后到数据库中查看一下，结果如下所示： 可以看到，数据同样被加密了，但是密文的格式明显和刚才的AES加密不一样了。而且因为 MD5 不能解密的原因，『LitePal』也不需要在后台对它进行解密处理，即使使用标准的『LitePal』API 来查询数据，得到的依然是密文。 更需要注意的是，AES 算法和 MD5 算法都只对 String 类型的字段有效，如果你尝试给其他类型的字段（比如说 int 字段）指定 @Encrypt 注解，『LitePal』并不会执行任何加密操作。 『LitePal』的基本使用到这里就介绍结束了，其实还有很多很实用的功能，比如异步操作数据库等，由于我并没有在项目中使用过，所以就不一一介绍了，需要了解的话查看官方文档即可。而且『LitePal』在 Kotlin 中的 API 得益于 Kotlin 的特性也得到了极大的优化，官方文档也有详细的介绍。 最后的最后，再来介绍一款『SQLite』的 GUI 工具，由于『Android Studio』的升级，导致在『Android Device Monitor 权限笔记』中提到的调起『Android Device Monitor』方法变得十分困难，而且查看里面的数据也很麻烦，所以我不得不找一款 GUI 工具来代替——『SQLite Developer』。 用法也是非常简单，『Android Studio』界面右下角有一个「Device File Explorer」面板，它实现了之前在『Android Device Monitor』中文件管理的功能，点开它后找到相应的目录，然后右键保存即可。 在弹出的窗口中选择相应的保存路径。 保存成功与否在『Android Studio』右下角也会有通知提醒。 如果保存成功，打开相应的目录就可以看到刚保存的数据库了。 右键该文件选择使用『SQLite Developer』打开，或者直接打开『SQLite Developer』并把数据库文件拖到左侧「数据库列表」的面板中，『SQLite Developer』就会弹出一个「注册数据库」的对话框，点击「确定」即可把刚才的数据库文件注册到『SQLite Developer』中。 这时候可以在左侧的「数据库列表」面板中看到该数据库，双击可查看内部的表或视图等。 比如我想查看 Goods 表，则可双击该表，在右侧即可打开编辑表的窗口，可以查看表的各字段、约束、索引、数据等，还可以查看 DDL 语句。 另外，『SQLite Developer』是存在试用期的，当试用期过了之后就会有提醒，想要继续免费使用的话可以通过删除注册表的方式来绕过它的检测。 在「运行」中输入 regedit，打开「注册表编辑器」，依次展开目录 HKEY_CURRENT_USER\\SharpPlus\\SqliteDev，在右侧把「StartDate」项删除即可。 还有另外一种方法，就是直接在命令行中执行： ➜ reg delete &quot;HKEY_CURRENT_USER\\SharpPlus\\SqliteDev&quot; /v &quot;StartDate&quot; /f 系统会自动帮我们删除该注册表。 这样之后就能一直使用了，如果再过期了就再次执行下这个方法即可。 ","link":"https://LiarrDev.github.io/post/Enjoy-LitePal-in-One-Shot/"},{"title":"在 Java 中获取网络日期和时间","content":"Android 项目中需要获取网络时间以确保消费信息的准确性，查了一下，发现 Java 给我们提供了相应的方法，能让我们简单地通过几行代码就能够获取到网络时间： URL url = new URL(&quot;https://cn.bing.com&quot;); // 从 Bing 取得资源对象 URLConnection urlConnection = url.openConnection(); // 生成连接对象 urlConnection.connect(); // 发出连接 Date date = new Date(urlConnection.getDate()); // 取得网站日期时间并转换为标准时间对象 SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.CHINA); // 设定日期时间格式并设为北京时间 String dateString = formatter.format(date); // 转换日期时间格式 Log.i(&quot;TIME&quot;, dateString); 首先从 Bing 中获取资源对象，至于为什么选 Bing，首先网上大多数教程都选用久久时间网来连接的，但是有技术博客提到，其时间并不准确，可靠性较低，然后我改用中国科学院国家授时中心来进行连接，毕竟 Windows 7 时代我还使用过它来更新 PC 的本地时间呢。 但在测试中却出乎意料的发现，中科院国家授时中心的时间却比实际时间快了几分钟，并不知道原因，赶紧弃坑！ 于是就转战一些互联网巨头的网站吧，至少服务器稳定可靠，首先想到的是 Google，这明显就不现实嘛，这不是要等到用户连接超时吗！所以最后才选择了 Bing。 取得资源对象后，通过 URLConnection 生成连接对象并建立连接，只需要建立连接就可以了，不需要 Request 与 Response，所以比单独写接口效率要高。 接着再把它转为标准时间对象，并按照所需的格式进行转换，因为我的项目只需面向国内的用户，所以用 Locale.CHINA 把它设定为北京时间。 最后再把时间对象转换成字符串就可以了。 ","link":"https://LiarrDev.github.io/post/Get-Network-Date-and-Time-in-Java/"},{"title":"C / C++ 修改控制台颜色","content":"虽然平时写 Java 比较多，但有时候验证个小算法的时候，打开『Eclipse』或者『IntelliJ IDEA』又费时，感觉没有必要，而 C 和 C++ 有很多比较轻量的编译器，几乎是秒开的，比如『GCC』，因此用来写个小算法是最适合不过的。 但当多打开几个控制台的时候，由于背景颜色都是黑色，总不能一次就找到想要的那个，影响效率。 那能不能修改控制台的背景颜色呢？ 当然是可以的，右击控制台的标题栏进入「属性」设置，即可对控制台的字体、颜色、布局等进行修改。 但是修改完后你会发现，虽然修改成功，但所有控制台的属性都会发生变化，这也没有办法提升我们的效率。 那能不能单独修改各个控制台的颜色呢？ 其实，C 和 C++ 的标准库为我们提供了修改控制台文件的函数，我们直接调用即可修改控制台的颜色。 首先我们需要添加标准库的头文件： #include &lt;stdlib.h&gt; 然后在主函数中添加一条 system() 函数的调用代码： system(&quot;COLOR..&quot;); 运行程序，可以在控制台中看到关于颜色设置的介绍。 设置默认的控制台前景和背景颜色。 COLOR [attr] attr 指定控制台输出的颜色属性。 颜色属性由两个十六进制数字指定 -- 第一个 对应于背景，第二个对应于前景。每个数字 可以为以下任何值: 0 = 黑色 8 = 灰色 1 = 蓝色 9 = 淡蓝色 2 = 绿色 A = 淡绿色 3 = 浅绿色 B = 淡浅绿色 4 = 红色 C = 淡红色 5 = 紫色 D = 淡紫色 6 = 黄色 E = 淡黄色 7 = 白色 F = 亮白色 如果没有给定任何参数，此命令会将颜色还原到 CMD.EXE 启动时 的颜色。这个值来自当前控制台 窗口、/T 命令行开关或 DefaultColor 注册表 值。 如果尝试使用相同的 前景和背景颜色来执行 COLOR 命令，COLOR 命令会将 ERRORLEVEL 设置为 1。 控制台的弹窗中说明很清楚，COLOR 后的第一个十六进制数字决定背景颜色，第二个十六进制数字决定文字颜色。 即如果我们添加以下代码： system(&quot;COLOR FC&quot;); 控制台的背景颜色将改为亮白色，文字颜色将改为淡红色。 这样，当我们需要产生多个控制台窗口时，就可以在代码中对其颜色进行定义，方便我们查看不同的内容。 ","link":"https://LiarrDev.github.io/post/C-and-CPP-Change-Console-Color/"},{"title":"一次实战爱上『OkHttp』","content":"Android 中发起 HTTP 网络请求的方法有很多种，在刚开始学 Android 的时候，我总是比较倾向于使用原生提供的 API，其一是因为不需要导入第三方的依赖，其二是因为代码量也不多，而在实习后才发现，框架原来如此方便。 比如我需要写一个登录功能，希望使用 POST 方式提交，先来看看原生中的 HttpURLConnection： private void sendRequestWithHttpURLConnection(final String tel, final String password) { new Thread(new Runnable() { @Override public void run() { HttpURLConnection httpURLConnection = null; try { URL url = new URL(&quot;http://url&quot;); // 接口 String data = &quot;tel=&quot; + tel + &quot;&amp;password=&quot; + password; httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.setConnectTimeout(8000); // 设置连接超时时间 httpURLConnection.setReadTimeout(8000); // 设置读取超时时间 httpURLConnection.setRequestMethod(&quot;POST&quot;); // 设置以 Post 方式提交数据 DataOutputStream out = new DataOutputStream(httpURLConnection.getOutputStream()); out.writeBytes(data); } catch (Exception e) { e.printStackTrace(); } finally { if (httpURLConnection != null) { httpURLConnection.disconnect(); } } } }).start(); } 这里省略了部分代码，包括得到数据后的解析以及校验等等，代码并不多嘛，但是实际上跑起来就是，服务器上没有接收到我提交的数据。 几经周折，终于把残缺的代码补全了： private void sendRequestWithHttpURLConnection(final String tel, final String password) { new Thread(new Runnable() { @Override public void run() { HttpURLConnection httpURLConnection = null; try { URL url = new URL(&quot;http://url&quot;); // 接口 String data = &quot;tel=&quot; + tel + &quot;&amp;password=&quot; + password; httpURLConnection = (HttpURLConnection) url.openConnection(); httpURLConnection.setConnectTimeout(8000); // 设置连接超时时间 httpURLConnection.setReadTimeout(8000); // 设置读取超时时间 httpURLConnection.setDoOutput(true); // 打开输出流，以便向服务器提交数据 httpURLConnection.setRequestMethod(&quot;POST&quot;); // 设置以 Post 方式提交数据 httpURLConnection.setUseCaches(false); // 使用 Post 方式不能使用缓存 httpURLConnection.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); //设置请求体的类型是文本类型 httpURLConnection.setRequestProperty(&quot;Content-Length&quot;, data.length() + &quot;&quot;); // 设置请求体的长度 httpURLConnection.connect(); // 建立连接 httpURLConnection.getOutputStream().write(data.getBytes()); int code = httpURLConnection.getResponseCode(); // 服务器的响应码 200 OK //404 页面找不到 // // 503服务器内部错误 if (code == 200) { InputStream is = httpURLConnection.getInputStream(); // 把is的内容转换为字符串 ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len = -1; while ((len = is.read(buffer)) != -1) { bos.write(buffer, 0, len); } String result = new String(bos.toByteArray()); is.close(); Toast.makeText(LoginActivity.this, result, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(LoginActivity.this, &quot;请求失败，失败原因: &quot; + code, Toast.LENGTH_SHORT).show(); } } catch (Exception e) { e.printStackTrace(); } finally { if (httpURLConnection != null) { httpURLConnection.disconnect(); } } } }).start(); } 我认为最重要的可能是这句： httpURLConnection.connect(); // 建立连接 网上大多数的资料都没有提到，我就不知道他们是怎么连接的了，当我把这句代码补上后，App 才成功和服务器建立起连接。 另外下方关于服务器响应码的那段代码也是必须的，得到响应码，判断与服务器连接是否正常，没了这个判断就不能和服务器进行数据的交互。 这样看下来，跟一开始的“代码并不多”差距就太大了，代码冗余晦涩，阅读起来十分痛苦，于是便打算对这段代码进行重构。 之前阅读『第一行代码——Android』时有学习过 OkHttp，所以我就打算使用它来代替 HttpURLConnection。 为什么我虽然从一开始就知道这个网络通信库却不使用呢？因为前文也提到，我以为 HttpURLConnection 的代码量相比 OkHttp 并没有多出多少，但是出现了如此巨大的 Bug，修复完成后代码量居然增加了一倍，所以必须转投 OkHttp 的怀抱。 首先在项目中添加 OkHttp 库的依赖： dependencies { implementation 'com.squareup.okhttp3:okhttp:(insert latest version)' } 为了使其保持最新版本，最好登录其官网或者其 Github 项目主页进行查询，当然，添加依赖时『Android Studio』内也会有提示。 然后就可以在项目中使用了，将上方的代码进行改造，就可以得出一段简洁的代码： private void sendRequestWithOkHttp(final String tel, final String password) { new Thread(new Runnable() { @Override public void run() { try { OkHttpClient client = new OkHttpClient(); RequestBody requestBody = new FormBody.Builder() .add(&quot;tel&quot;, tel) .add(&quot;password&quot;, password) .build(); Request request = new Request.Builder() .url(&quot;http://url&quot;) // 接口 .post(requestBody) .build(); Response response = client.newCall(request).execute(); String responseCode = response.body().string(); Log.e(&quot;GETCODE&quot;, responseCode); } catch (Exception e) { e.printStackTrace(); } } }).start(); } 真的太好用了有木有！如此清晰简单的代码就完成了上面的内容，并且还十分容易获取从服务器返回的数据，方便我后面对其进行解析，简直要爱上它了！ ","link":"https://LiarrDev.github.io/post/Enjoy-OkHttp-in-One-Shot/"},{"title":"Android Device Monitor 权限笔记","content":"读《第一行代码——Android（第 2 版）》的时候遇到了这样一个问题，在数据持久化方法之文件存储的章节，代码通过 Context 类中提供的 openFileInput() 和 openFileOutput() 方法以及 Java 的各种流来进行读写操作。 然后系统会在 /data/data/&lt;package name&gt;/files/ 目录下创建一个名为「data」的文件，我们可以通过『Android Studio』中的『Android Device Monitor』去查看。 那么问题来了，与书上的介绍不同，我所使用的『Android Studio』并没有『Android Device Monitor』，难道是我打开的方式不对？ 我的「Tools」里根本就没有『Android Device Monitor』啊！ 后来从 Google 官方文档得知，自『Android Studio』Version 3.0 开始就已弃用了『Android Device Monitor』。 However, most components of the Android Device Monitor are deprecated in favor of updated tools available in Android Studio 3.0 and higher. 但是，大多数 Android Device Monitor 组件已弃用，以支持『Android Studio』Version 3.0 和更高版本中提供的更新工具。 那没有『Android Device Monitor』，要怎么继续下一步呢？ 其实进入 Android SDK 的目录看一下可以发现，即使弃用，但 SDK 里面还是提供了『Android Device Monitor』。 可以在命令行中进入 /AndroidSDK/tools/ 目录，然后输入 monitor 即可打开。 也可以直接进入到该目录双击文件「monitor.bat」打开。 本以为打开『Android Device Monitor』就可以继续后面的学习了，这未免也太顺利？ 按照步骤，我需要进入「File Explorer」标签页到 /data/data/&lt;package name&gt;/files/ 目录下去寻找这个名为「data」的文件，但是却发现 /data/ 目录根本打不开。 又进入了知识的盲区，赶紧去补了补课。 可以看到，/data 文件夹的 Permissions 是 drwxrwx--x，这是什么意思？相信学过 Linux 的同学就非常清楚了。因为 Android 的底层是 Linux，所以每个文件夹都是有权限控制的。 具体是什么意思？ 这一个字符串一共有 10 个字符，第一个字符表示的是文件类型。d 表示是文件夹，l 表示连接文件，- 表示文件。 后面 9 个字符又可以分为三个元组，每 3 个字符为一个元组。第一个组表示文件所有者（user）的权限，第二个组表示同组用户（group）的权限，第三个组表示所有其他用户（other）的权限。 元组内字符的顺序是 rwx。 r ：read，可读 w ：write，可写 x ：execute，可执行 - ：无该权限 所以，drwxrwx--x 的意思是，没有 r 和 w，说明 /data 文件夹对其他人来说是不可读不可写的。因此我们则需要修改其对应的权限。 需要用到的是 Android SDK 中的 adb。 adb 在 /AndroidSDK/platform-tools/ 目录下，但是我们不能够通过双击来运行它。 而是需要将 /AndroidSDK/platform-tools/ 这个目录添加到环境变量，执行下一步。 接着直接在 CMD 中输入命令： ➜ adb shell 然后按照下图命令继续操作。 解释一下这几个命令： adb shell ：打开 adb 外壳程序 su ：切换为超级管理员，即获取 root 权限，只有 root 权限才能修改文件的访问权限 chmod &lt;权限&gt; &lt;文件夹&gt; ：为文件夹设置权限 还需要提的是，# 是超级管理员的意思，也就是说可以访问模拟器中的一切数据，而 $ 则表示是普通管理员，输入 su 命令的作用就是切换成超级管理员。 命令的前面两项好理解，关于文件夹权限，这一堆 chmod 777 又是什么意思？ 是把对应的文件或文件夹的访问权限的后 9 位设置成 rwxrwxrwx，777 就三个二进制 111, 合起来就是 111111111（9 个 1），即相当于把后 9 位访问权限都置 1，于是就成了 rwxrwxrwx，即所有用户都具有该文件的全部访问权限。 按道理到这里就已经获取了权限可以访问对应的文件了，但事情并没有我想象中的那么顺利，文件夹依旧打不开… 我就纳闷了… 不知怎么的突然有个想法，手机可以通过获取 root 权限然后在『RE文件管理器』中查看本地数据库，那么我可不可以直接 root 呢，虽然上面的 su 也是获取 root 权限。 抱着试一试的心态，我在 CMD 中输入了： ➜ adb root 结果，文件夹就真的畅通无阻的被我打开了… 事实上，使用 adb root 并没有修改其 rwx 权限，它只是获取了最高级的操作权，可以看到在执行了 adb root 后，adb shell 中的 $ 就已经变成 # 了，无需执行 su。 如果从一开始就执行 adb root 的话，adb shell 中的相关操作则无需执行，也可以查看到 /data/ 目录下的文件。 其他关于『Android Device Monitor』基本可以通过「Reset Perspective」操作或重启解决。 还需要提醒的是，『Android Device Monitor』在『Android Studio』Version 3.1 中已弃用，并在『Android Studio』Version 3.2 中移除了，并提供了新的功能来替代。 ","link":"https://LiarrDev.github.io/post/Permissions-of-Android-Device-Monitor/"},{"title":"Windows 平台 React Native 开发环境搭建笔记","content":"现在各种第三方框架流行，每次安装总要花太多的时间，在重装系统后还要再一步一步的搭起来，实在是太麻烦。 来讲讲 Windows 平台 React Native 的开发环境搭建。 撰文时 React Native 版本为 0.51。 Python 第一步先安装『Python』，进入官网，可以发现有两个版本。 这里需要注意的是一定要下载 Python 2，不要下载 Python 3。 下载下来运行安装即可，中间有一个需要注意的地方，安装进入到以下界面时，需要修改选项。 最后一项，默认是没有选择「Add python.exe to Path」，意思是把『Python』的安装路径添加到系统路径下面，需要把它选上，这样会省去安装完成后还要自己设置路径的功夫。 把它选上安装完成的情况下，在 CMD 中输入 python 就会去调用「python.exe」，如果没有选上这个选项，CMD 则会报以下错误： 'python' 不是内部或外部命令，也不是可运行的程序或批处理文件。 安装完成后，进行下一步。 Node.js 进入『Node.js』官网或中文网下载即可，官网有一个推荐版本和最新版本，我下载的是推荐版本，中文网的版本比官网的推荐版本要低。 Node.js 提供了 JavaScript 代码的编译环境，还提供了 npm 工具，npm 是一个包管理器，是一个专门负责 JavaScript 代码的包管理器。 安装完 Node.js 后建议设置 npm 镜像以加速后面的过程，也可以使用科学上网工具，由于我在用的 VPN 流量有限，而且第一次搭 React Native 环境的时候使用 VPN 速度并没有太理想，所以我用 npm 把服务器设置到国内的淘宝源。 在 CMD 中输入以下两行： ➜ npm config set registry https://registry.npm.taobao.org --global ➜ npm config set disturl https://npm.taobao.org/dist --global 这样就方便我们后面去安装下载 JavaScript 模块的时候速度更快。 Yarn、React Native 的命令行工具 我们使用 npm 安装两种 JavaScript 模块，其中一种是 Yarn 和 CLI 这种可以直接在命令行中执行的命令，使用以下的命令直接在 CMD 中进行安装： ➜ npm install -g yarn react-native-cli npm install -g 表示安装全局模块，Yarn 和 CLI 全局安装是因为它们是直接在命令行中执行的，是在任何目录下都可以直接执行的命令。 另一类则是之后在开发过程中会引用一些第三方的组件或者工具，是代码层而不是命令，这些模块则不需要加 -g 进行安装。 Yarn 是 Facebook 提供的替代 npm 的工具，可以加速 Node 模块的下载，比 npm 更快。CLI 则是 React Native 的外围的工具，它用于执行创建、初始化、更新项目、运行打包服务等任务。 到这里，第三方的工具就安装的差不多了，接下来安装核心的开发工具。 Android Studio 因为我主要还是做 Android 开发，所以这是必装工具。 下载并安装完成后，先创建个项目并在模拟器上运行一下，以确认安装是否正常。 Android SDK 安装完『Android Studio』后能运行项目证明已经安装了基本的 SDK 了，但我们还需要安装其他的 SDK。 进入「SDK Manager」，打开「SDK Tools」标签页，并选择下方的「Show Package Details」，并在「Android SDK Build-Tools」中勾选 23.0.1 的版本，然后按「OK」下载。 网上的教程基本都说有很多项是必须下载的，但是我发现只下载这一项也能够运行，不知道后续的开发会不会受影响，但是目前没有发现问题。 记住 SDK 的安装目录，进入下一步。 配置环境变量 相信所有写过 Java 的人都配置过环境变量了，这里要配置 ANDROID_HOME 环境变量。 在「用户变量」中新建。变量名为 ANDROID_HOME，注意是大写，然后变量值为上一步中 SDK 的目录。 然后还要在「用户变量」的 Path 中添加两个目录，如图所示： 这两个目录中有一些比较重要的 Android 命令，在以后的开发中可能会用到。 JRE 你可能会发现我并没有配置 JDK，这不是 Java 最基本的东西吗？ 其实，从我用『Eclipse』写 Java 开始就没有再配置过 JDK 了，是不是很神奇，『Eclipse』部分版本里面内置了 OpenJDK，并且自带了 JRE，所以无需再自己安装 JDK 了。 从刚才能运行 Android 项目，就可以知道『Android Studio』里面也是内置了 JRE 的，也就是 Java 运行环境，所以我们只要引用其 JRE 路径，就可以在 React Native 项目中使用。 在『Android Studio』的安装目录中找到 JRE 的路径，填入「系统变量」的 Path 中即可。 然后确定，并退出所有窗口。 这时候，在 Windows 系统下 React Native 的 Android 运行环境就基本搭建完成了。 为了更方便的开发 React Native，我还需要一个好用的 IDE。 Atom 考虑到适合 React Native 开发的 IDE 实在不多，比如最好用的可能是与『Android Studio』师出同门的『WebStorm』了，但是收费；比如插件强大的『Sublime Text 3』，也是收费，虽然目前还可以无限期试用，但配置起来相对麻烦；比如 Mircosoft 家的轻量级的开源 Web 集成开发环境『Visual Studio Code』，个人喜好问题，不太喜欢；比如开源的专门为 React Native 打造的『Deco』，可惜目前只支持 Mac OS X。 综合考虑，到最后我选择了『Atom』，由全球最大的同性交友社区『GitHub』打造的编程开发利器。 打开官网进行下载。直接下载安装默认是装在 C 盘，我的 C 盘可没打算给它留位置，仔细看官网可以发现有一行小字： 点击这个「Other platforms」即可跳转到『GitHub』的全平台的下载页。 在里面找到对应的版本下载即可，比如我是 64 位的 Windows 操作系统，则下载「atom-x64-windows.zip」。 下载完成后解压即可。 Nuclide 『Atom』本质上是一个文本编辑器，而不是一个 IDE，因此在用来开发 React Native 时需要配合『Nuclide』一起使用，『Nuclide』是 Facebook 基于『Atom』的基础上开发的一个插件。 在『Atom』中搜索「Nuclide」进行安装即可，不过『Atom』在安装插件的过程中没有进度条，安装时间又长，实在令人抓狂，最好挂梯子。 安装完成后，进入『Nuclide』的「Settings」，勾选「Install Recommended Packets on Startup」。 然后退出『Atom』再打开，会发现自动安装这些依赖包。 另外需要注意的是，『Atom』的插件是默认装在 C 盘的，目前似乎没有办法修改。 Others Chocolatey 官网包括中文网把『Chocolatey』归类到必需的软件中，它是一个 Windows 上的包管理器，类似于应用市场。 可以看到在上面的步骤中并没有安装，因为它的安装和使用都比较困难，由于在国外，所以它的网速会比较慢，因此并没有什么特别的好处，所以就直接跳过了。 Git 官网把『Git』归类到可选的安装项中，不过在之前的版本是必须安装。 『Git』的话在某些情况也是需要用到的，比如有时候需要运行在『GitHub』上的开源项目的时候，没有『Git』会报错，这个在需要的时候安装即可。 在安装过程中注意勾选「Run Git from Windows Command Prompt」，这样才会把 git 命令添加到 PATH 环境变量中，保证我们在命令行中可以调用 git 命令。 到这里环境就基本搭建完成了，然后就可以创建一个项目运行一下。 在 CMD 进入需要创建项目的目录下，输入： ➜ react-native init ProjectName 其中，「ProjectName」代表项目名，注意不要使用中文的项目名，也不要在任何中文目录下执行这个命令，避免不必要的麻烦。 还需要注意的是，不要在命令行默认的「System32」目录中 init 项目！会有各种权限限制导致不能运行！ 然后进入项目文件夹： ➜ cd ProjectName 执行以下命令以运行 Android 项目： ➜ react-native run-android 执行的过程中会弹出一个 Node 窗口，不能关闭这个窗口，否则程序将不能执行。 这是程序在 Node 中执行编译、打包、转码 JavaScript 文件的工具。 可以看到，它运行在 8081 端口上，可能会有某些杀毒软件，比如『McAfee』，也会占用该端口，这种情况下程序是无法正常运行的，所以要停止相关占用端口的软件。 然后等待命令执行，直到最后看到有且仅有「No connected devices!」的错误时，就代表万事俱备，App 已经编译好了，只是没有找到可以安装的设备。 不要被下方的红字所迷惑，它看起来像是报错，而且有提示 FAILED，其实并没有什么信息量，只是一个一般性的提示，它并不是任何错误的具体原因，不管任何报错，都会蹦出这几行红字。 最后就可以连真机运行了。 同样的步骤，不过在真机运行会遇到两种情况。 在低于 Android 5.0 的设备上运行可能会出现报错，如图所示： 我尝试按照网上的各种方法进行调整，手动修改端口等，但目前仍没有解决这个问题。 另外在『Android Studio』中也无法正常运行程序。 但是在高于 Android 5.0 的真机上运行则没有任何问题。 当出现上面这个页面的时候，就证明项目正常运行了。 参考内容：React Native 中文网 ","link":"https://LiarrDev.github.io/post/Set-up-React-Native-Development-Environment-on-Windows/"},{"title":"获取手机应用 ICON 的方法","content":"一直很喜欢微博表情的那两只狗，真的很形象地表达出不屑，大概这也是评论里的友军特喜欢使用的原因之一吧。 于是就很想把它们都转为微信表情包，可惜搜了好久都没找到高清的图片。 然后突发奇想，这些表情本来就内置在 App 内，而软件安装包 APK 文件实质上也是一个压缩包，那我能不能解压它来获取高清原图呢？ 机智如我，开搞。 首先，我们需要从安卓的应用市场上把软件安装包下载到电脑。 任何一个应用市场都是可以的，比如『Google Play』、『豌豆荚』等，我这里选择的是从『小米应用商店』下载。 下载完成后，即可以获得一个 APK 文件。 然后需要修改文件格式为压缩文件 ZIP，直接把后缀改为「.zip」即可。 接着解压这个压缩文件。Windows 10 系统的『文件资源管理器』是具有解压文件功能的，另外也可以使用『WinRAR』、『7-Zip』等工具进行解压。 解压完之后会得到一大堆文件，不要怕，只需要打开名为「res」的文件夹即可，其他文件可以删除或自行处置。 打开「res」文件夹后也会得到很多文件夹，一般表情会放在「drawable」集合的文件夹下。 文件比较多，可以慢慢找。 当然你也可以直接搜索「doge」直接查询到这只狗。 如果你的系统不支持直接查看 WebP 格式的图片，那么找起来会十分麻烦，还是用搜索功能比较方便。 WebP 格式是 Google 开发的一种旨在加快图片加载速度的图片格式。因此，只要使用 Chrome 内核的浏览器都可以打开。 接着直接把这个 WebP 文件发送到手机并添加到微信即可。 现在的智能手机基本都能够识别并打开 WebP 文件，若不能打开，可以先使用格式转换工具把它转为 PNG 格式。 添加表情后，跟网上那些模糊的图相比简直跟加了美颜一样。 搜寻过程中还有其他收获，跟这次主题呼应，获取软件的 ICON。 这对软件 UI 设计的同学可能就比较有帮助了，看到其他软件有好的 ICON，终于不用自己设计或者全网搜素材了，下个安装包直接「借」就可以。 我们做 App 开发的也可以直接拿过来用，省事。 ","link":"https://LiarrDev.github.io/post/How-to-Get-Icons-of-Android-App/"},{"title":"时间差算法","content":"以前在学校做课程设计的时候，有两个算法特别有趣，在这里留个底，以备不时之需。 第一个算法是自动获取本地当前时间的算法，无需手动输入。由于各种不同语言获取的方法各不相同，这里不做介绍，上网搜一下即可。 第二个算法是时间差算法。像很多课程设计一般都搞「停车场管理系统」、「图书馆管理系统」之类的需要计算时间差的系统，这个算法就十分重要了。 即使到了制作在线商城等高级系统时，也是需要计算时间差的，毕竟像淘宝的订单系统也是要计算 15 天自动收货的。 Talk is cheap, show you the code! public static double TimeDiff(int startYear, int startMonth, int startDay, int startHour, int startMinute, int endYear, int endMonth, int endDay, int endHour, int endMinute) { int y, m, d; int Y, M, D; int Day, Hour, Minute; double time; m = (startMonth + 9) % 12; // 用于判断日期是否大于 3 月（2 月是判断闰年的标识），还用于纪录到 3 月的间隔月数 y = startYear - m / 10; // 如果是 1 月和 2 月，则不包括当前年,因为是计算到 0 年 3 月 1 日的天数 d = 365 * y + y / 4 - y / 100 + y / 400 + (m * 306 + 5) / 10 + (startDay - 1); // 365 * y 是不算闰年多出那一天的天数；y / 4 - y / 100 + y / 400 是加所有闰年多出的那一天；(m * 306 + 5) / 10 用于计算当前月到 3 月 1 日间的天数，306 = 365 - 31 - 28（1 月和 2 月），5 是全年中不是 31 天月份的个数；startDay - 1 用于计算当前日到 1 日的间隔天数 M = (endMonth + 9) % 12; Y = endYear - M / 10; D = 365 * Y + Y / 4 - Y / 100 + Y / 400 + (M * 306 + 5) / 10 + (endDay - 1); Day = D - d; Hour = 24 * Day + endHour - startHour; if (endMinute - startMinute &lt; 0) { Hour--; Minute = endMinute + 60 - startMinute; } else { Minute = endMinute - startMinute; } time = (double) Hour + ((double) Minute) / 60; return time; } 因为每个月的天数不同，因此采用直接相减的方法明显是不合理的。 该算法总体思想是计算给定日期到 0 年 3 月 1 日的天数，然后相减，获取天数的间隔。 即采取一个参照点，然后计算两个时间到同一参照点的时间差，再相减获得天数的间隔。 由于折算的单位是天数，因此 D - d 则可获得天数差。 小时差的计算里用到了天数作为借位，如果天数不足 1 天，即 24 * Day 为 0，则没有借位。 同样，在分钟差的计算中，如果差小于 0，则需向小时借位。 这里只精确到分钟的计算，并且最终把结果转为以小时为单位的浮点数。 各位可以根据需要调整精确度和单位。 时间差算法一般和自动获取时间的算法一同使用，课程设计中可视情况采用手动输入时间的方式，但自动获取本地时间相对来说更接近应用层面，而这也恰好是课程设计中的一个重要评分点。 ","link":"https://LiarrDev.github.io/post/Time-Difference-Algorithm/"},{"title":"常用正则表达式","content":"很多不太懂正则的朋友，在遇到需要用正则校验数据时，往往是在网上去找很久，结果找来的还是不很符合要求。所以我最近把开发中常用的一些正则表达式整理了一下，在这里分享一下。给自己留个底，也给朋友们做个参考。 正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），计算机科学的一个概念。正则表通常被用来检索、替换那些符合某个模式（规则）的文本。 校验数字的表达式 数字：^[0-9]*$ n 位的数字：^\\d{n}$ 至少 n 位的数字：^\\d{n,}$ m ~ n 位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带 1 ~ 2 位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有 1 ~ 3 位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 非零的负整数：^\\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为 3 ~ 20 的所有字符：^.{3,20}$ 由 26 个英文字母组成的字符串：^[A-Za-z]+$ 由 26 个大写英文字母组成的字符串：^[A-Z]+$ 由 26 个小写英文字母组成的字符串：^[a-z]+$ 由数字和 26 个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26 个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有 ^%&amp;',;=?$\\&quot; 等字符：[^%&amp;',;=?$\\x22]+ 禁止输入含有 ~ 的字符：[^~\\x22]+ 特殊需求表达式 Email 地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? Internet URL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 电话号码（&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot; 和 &quot;XXXXXXXX）：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 国内电话号码（0511-4405222、021-87888822）：\\d{3}-\\d{8}|\\d{4}-\\d{7} 身份证号（15 位、18 位数字）：^\\d{15}|\\d{18}$ 短身份证号码（数字、字母 X 结尾）：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法（字母开头，允许 5 ~ 16 字节，允许字母数字下划线）：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码（以字母开头，长度在 6 ~ 18 之间，只能包含字母、数字和下划线）：^[a-zA-Z]\\w{5,17}$ 强密码（必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间）：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 一年的 12 个月（01 ~ 09 和 1 ~ 12)：^(0?[1-9]|1[0-2])$ 一个月的 31 天（01 ~ 09 和 1 ~ 31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ XML 文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] （包括汉字在内，可以用来计算字符串的长度：一个双字节字符长度计2，ASCII字符计1） 空白行的正则表达式：\\n\\s*\\r （可以用来删除空白行） HTML 标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/\\1&gt;|&lt;.*? /&gt; （网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力） 首尾空白字符的正则表达式：^\\s*|\\s*$ 或 (^\\s*)|(\\s*$) （可以用来删除行首行尾的空白字符，包括空格、制表符、换页符等等，非常有用的表达式） 腾讯 QQ 号：[1-9][0-9]{4,} （腾讯 QQ 号从 10000 开始） 中国邮政编码：[1-9]\\d{5}(?!\\d) （中国邮政编码为 6 位数字） IP 地址：\\d+\\.\\d+\\.\\d+\\.\\d+ （提取 IP 地址时有用） IP 地址：((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)) 大概就这么多了，知道有这个东西总会省事一点。 网上还有在线正则表达式测试工具，可以校验自己写的表达式。 正则表达式的学习可参考『正则表达式30分钟入门教程』。 ","link":"https://LiarrDev.github.io/post/Common-Regular-Expressions/"},{"title":"Greatest Common Divisor","content":"最大公约数是在很小的时候就学过的东西，似乎日常生活的应用也不广泛，大多数只应用在材料使用率最大化等问题上，但是算法却不见得高效。 那么求最大公约数有哪些算法呢？ Q：要求方法传两个正整型参数，返回值就是他们的最大公约数，尽可能保证性能 暴力枚举法 public static int getGreatestCommonDivisor(int numberA, int numberB) { int smallNumber = numberA &lt; numberB ? numberA : numberB; int bigNumber = numberA &gt;= numberB ? numberA : numberB; if (bigNumber % smallNumber == 0) { return smallNumber; } int greatestCommonDivisor = 1; for (int i = 2; i &lt;= smallNumber / 2; i++) { if (numberA % i == 0 &amp;&amp; numberB % i == 0) { greatestCommonDivisor = i; } } return greatestCommonDivisor; } 思路十分简单，使用暴力枚举的方法，试图寻找到一个合适的整数 i，看看这个整数能否被两个整型参数 numberA 和 numberB 同时整除。 这个整数 i 从 2 开始循环累加，一直累加到 numberA 和 numberB 中较小的参数的一半为止。循环结束后，上一次寻找到的能够被两数整除的最大 i 值，就是两数的最大公约数。 这样虽然可以得到正确结果，但效率却比较低。比如传入两个参数 10000 和 10001，用此方法就需要循环 10000/2-1=4999 次！ 辗转相除法 辗转相除法，又名欧几里得算法（Euclidean algorithm），是古希腊数学家欧几里得发明的，目的是求出两个正整数的最大公约数。它是已知最古老的算法，可追溯至公元前 300 年前。 这条算法基于一个定理：两个正整数 a 和 b（a&gt;b），它们的最大公约数等于 a 除以 b 的余数 c 和 b 之间的最大公约数。 比如：10 和 25，25 除以 10 商 2 余 5，那么 10 和 25 的最大公约数，等同于 10 和 5 的最大公约数。 有了这条定理，求最大公约数就简单了。我们可以使用递归的方法来把问题逐步简化。 首先，我们先计算出 a 除以 b 的余数 c，把问题转化成求出 b 和 c 的最大公约数；然后计算出 b 除以 c 的余数 d，把问题转化成求出 c 和 d 的最大公约数；再然后计算出 c 除以 d 的余数 e，把问题转化成求出 d 和 e 的最大公约数…… 以此类推，逐渐把两个较大整数之间的运算简化成两个较小的整数之间的运算，直到两个数可以整除，或者其中一个数减少到 1 为止。 public static int getGreatestCommonDivisor(int numberA, int numberB) { int result = 1; if (numberA &gt; numberB) { result = gcd(numberA, numberB); } else { result = gcd(numberB, numberA); } return result; } // 递归计算最大公约数 private static int gcd(int a, int b) { if (a % b == 0) { return b; } else { return gcd(b, a % b); } } 不过一个新问题产生了，当两个整型数较大时，做 a%b 取模运算的性能会比较低。 更相减损术 更相减损术，出自中国古代的《九章算术》，也是一种求最大公约数的算法。 原理更加简单：两个正整数 a 和 b（a&gt;b），它们的最大公约数等于 a-b 的差值 c 和较小数 b 的最大公约数。 比如：10 和 25 ，25 减去 10 的差是 15，那么 10 和 25 的最大公约数，等同于 10 和 15 的最大公约数。 由此，我们同样可以通过递归来简化问题。首先，我们先计算出 a 和 b 的差值 c（假设 a&gt;b），把问题转化成求出 b 和 c 的最大公约数；然后计算出 c 和 b 的差值 d（假设 c&gt;d），把问题转化成求出 b 和 d 的最大公约数；再然后计算出 b 和 d 的差值 e（假设 b&gt;d），把问题转化成求出 d 和 e 的最大公约数…… 以此类推，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两数可以相等为止，最大公约数就是最终相等的两个数。 public static int gcd(int numberA, int numberB) { if (numberA == numberB) { return numberA; } else if (numberA &lt; numberB) { return gcd(numberB - numberA, numberA); } else { return gcd(numberA - numberB, numberB); } } 更相减损术避免了大整数取模的性能问题，已经越来越接近最优了，但是，依靠两数求差的方式来递归，运算的次数肯定远大于辗转相除法的取模方式。因此，更相减损术是不稳定的算法，当两数相差悬殊时，比如计算 10000 和 1，就要递归 9999 次。 更相减损术与移位结合 有什么方法，可以既避免大整数取模，又能尽可能减少运算次数呢？ 最优方法——把辗转相除法和更相减损术的优势结合起来，在更相减损术的基础上使用移位运算。 众所周知，移位运算的性能非常快。对于给定的正整数a和b，不难得到如下的结论（其中 gcb(a, b) 的意思是 a 和 b 的最大公约数函数）： 当 a 和 b 均为偶数，gcb(a, b) = 2 * gcb(a/2, b/2) = 2 * gcb(a&gt;&gt;1, b&gt;&gt;1); 当 a 为偶数，b 为奇数，gcb(a, b) = gcb(a/2, b) = gcb(a&gt;&gt;1, b); 当 a 为奇数，b 为偶数，gcb(a, b) = gcb(a, b/2) = gcb(a, b&gt;&gt;1); 当 a 和 b 均为奇数，利用更相减损术运算一次，gcb(a, b) = gcb(b, a-b)，此时 a-b 必然是偶数，又可以继续进行移位运算。 比如计算 10 和 25 的最大公约数的步骤如下： 整数 10 通过移位，可以转换成求 5 和 25 的最大公约数 利用更相减损术，计算出 25-5=20，转换成求 5 和 20 的最大公约数 整数 20 通过移位，可以转换成求 5 和 10 的最大公约数 整数 10 通过移位，可以转换成求 5 和 5 的最大公约数 利用更相减损术，因为两数相等，所以最大公约数是 5 在两数比较小的时候，暂时看不出计算次数的优势，当两数越大，计算次数的节省就越明显。 public static int gcd(int numberA, int numberB) { if (numberA == numberB) { return numberA; } else if (numberA &lt; numberB) { return gcd(numberB, numberA); // 保证参数 numberA 永远大于等于参数 numberB，减少代码量 } else { // 和 1 做按位与运算，判断奇偶 if (!numberA&amp;1 &amp;&amp; !numberB&amp;1) { return gcd(numberA &gt;&gt; 1, numberB &gt;&gt; 1) &lt;&lt; 1; } else if (!numberA&amp;1 &amp;&amp; numberB&amp;1) { return gcd(numberA &gt;&gt; 1, numberB); } else if (numberA&amp;1 &amp;&amp; !numberB&amp;1) { return gcd(numberA, numberB &gt;&gt; 1); } else { return gcd(numberA, numberA - numberB); } } } 总结上述所有算法的时间复杂度 暴力枚举法： 时间复杂度是 O(min(a, b)))。 辗转相除法： 时间复杂度不太好计算，可以近似为 O(log(max(a, b)))，但是取模运算性能较差。 更相减损术： 避免了取模运算，但是算法性能不稳定，最坏时间复杂度为 O(max(a, b)))。 更相减损术与移位结合： 不但避免了取模运算，而且算法性能稳定，时间复杂度为 O(log(max(a, b)))。 写在后面 方法的参数默认必定是正整数，所以在代码中省去了合法性检查。 文中描述的更相减损术是简化了的方式。在九章算术原文中多了一步验证：如果两数都是偶数，计算差值之前会首先让两个数都折半，使得计算次数更少。这种方法做到了部分优化，但古人似乎没想到一奇一偶的情况也是可以优化的。 ","link":"https://LiarrDev.github.io/post/Greatest-Common-Divisor/"}]}